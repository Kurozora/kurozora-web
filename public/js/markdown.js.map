{"version":3,"file":"/js/markdown.js","mappings":"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","sources":["webpack:///./resources/js/helpers/markdown.js","webpack:///./resources/js/markdown.js"],"sourcesContent":["export default class Markdown {\n    constructor() {\n    }\n\n    /**\n     * Parses a Markdown string into an array of tokens.\n     *\n     * @param text {string} The Markdown string.\n     * @param chartLimit {number} The character limit for rendering.\n     * @param charCountCallback {function(count: number)} A callback function to receive the character count.\n     * @param forView {boolean} If true, the output is formatted for view.\n     *\n     * @returns {Object<type:string, content:string>}\n     */\n    parse(text, chartLimit, charCountCallback = null, forView = false) {\n        const ast = this.#parse(text)\n\n        if (forView) {\n            return this.#formatView(ast)\n        } else {\n            return this.#formatEdit(ast, chartLimit, charCountCallback)\n        }\n    }\n\n    /**\n     * Escapes HTML special characters in a string.\n     *\n     * @param text {string} The text to escape.\n     *\n     * @returns {string} The escaped text.\n     */\n    #escapeHTML(text) {\n        return text.replace(/\"/g, \"&quot;\")\n            .replace(/'/g, \"&#39;\")\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\")\n    }\n\n    /**\n     * Calculates the character count in a Markdown AST.\n     *\n     * @param ast {Object<type: string, content: string>[]} The AST of the Markdown.\n     *\n     * @returns {number} The character count of the Markdown AST.\n     */\n    #calculateCharCount(ast) {\n        let count = 0\n\n        for (const token of ast) {\n            switch (token.type) {\n                case 'text':\n                case 'mention':\n                case 'hashtag':\n                case 'reference':\n                    count += [...token.content.replace(/\\r\\n|\\r|\\n/g, '')].length\n                    break\n                case 'emoji':\n                    count += 1\n                    break\n                case 'code':\n                case 'url':\n                    for (const content of token.content) {\n                        count += this.#calculateCharCount(content)\n                    }\n                    break\n                case 'bold':\n                case 'italic':\n                case 'underline':\n                case 'strikethrough':\n                case 'highlight':\n                case 'superscript':\n                case 'subscript':\n                case 'spoiler':\n                case 'link':\n                    count += this.#calculateCharCount(token.content)\n                    break\n                default:\n                    break\n            }\n        }\n\n        return count\n    }\n\n    /**\n     * Parses a Markdown string into an array of tokens using CommonMark subset.\n     * Supported: bold, italics, underline, strikethrough, superscript, subscript, spoiler, emoji, highlight, link, mono, auto-link, escaping,\n     * and detection for username, hashtag, anime, manga, game, song, character, person, studio, episode references.\n     *\n     * @param {string} input\n     * @param {boolean} [asPlainText=false] If true, the input is treated as plain text without Markdown parsing.\n     *\n     * @returns {Array<{type: string, content: any, charCount: number}>} An array of tokens representing the parsed Markdown.\n     */\n    #parse(input, asPlainText = false) {\n        const tokens = []\n        let pos = 0\n\n        const self = this // preserve context for matchPair\n\n        function matchPair(str, start, open, close, type, parseInner) {\n            if (str.startsWith(open, start)) {\n                let end = str.indexOf(close, start + open.length)\n                if (\n                    end !== -1 &&\n                    end > start + open.length &&\n                    !str.slice(start + open.length, end).includes('\\n')\n                ) {\n                    const parsed = parseInner(str.slice(start + open.length, end))\n                    return {\n                        token: self.#tokenWithCount(type, {\n                            prefix: open,\n                            content: parsed\n                        }),\n                        len: end + close.length - start\n                    }\n                }\n            }\n            return null\n        }\n\n        while (pos < input.length) {\n            if (input[pos] === '\\\\' && pos + 1 < input.length && !asPlainText) {\n                const content = input[pos + 1]\n                tokens.push(this.#tokenWithCount('text', {content}))\n                pos += 2\n                continue\n            }\n\n            if (input[pos] === '`' && !asPlainText) {\n                const end = input.indexOf('`', pos + 1)\n                if (end !== -1 && !input.slice(pos + 1, end).includes('\\n')) {\n                    const content = this.#parse(input.slice(pos + 1, end), true)\n                    tokens.push(this.#tokenWithCount('code', {content}))\n                    pos = end + 1\n                    continue\n                }\n            }\n\n            const pairTypes = [\n                ['**', '**', 'bold'],\n                ['*', '*', 'italic'],\n                ['_', '_', 'italic'],\n                ['__', '__', 'underline'],\n                ['~~', '~~', 'strikethrough'],\n                ['==', '==', 'highlight'],\n                ['||', '||', 'spoiler'],\n                ['^', '^', 'superscript'],\n                ['~', '~', 'subscript']\n            ]\n\n            let matched = false\n            for (const [open, close, type] of pairTypes) {\n                const result = matchPair(input, pos, open, close, type, this.#parse.bind(this))\n                if (result && !asPlainText) {\n                    tokens.push(result.token)\n                    pos += result.len\n                    matched = true\n                    break\n                }\n            }\n            if (matched) continue\n\n            if (input[pos] === ':' && input.indexOf(':', pos + 1) !== -1 && !asPlainText) {\n                const end = input.indexOf(':', pos + 1)\n                const name = input.slice(pos + 1, end)\n                if (/^[\\w+\\-]+$/.test(name)) {\n                    tokens.push(this.#tokenWithCount('emoji', {name}))\n                    pos = end + 1\n                    continue\n                }\n            }\n\n            if (input[pos] === '[' && !asPlainText) {\n                const endBracket = input.indexOf(']', pos)\n                const startParen = input.indexOf('(', endBracket)\n                const endParen = input.indexOf(')', startParen)\n                if (\n                    endBracket !== -1 &&\n                    startParen === endBracket + 1 &&\n                    endParen !== -1 &&\n                    !input.slice(pos + 1, endBracket).includes('\\n') &&\n                    !input.slice(startParen + 1, endParen).includes('\\n')\n                ) {\n                    const text = this.#parse(input.slice(pos + 1, endBracket))\n                    const href = this.#parse(input.slice(startParen + 1, endParen))\n                    tokens.push(this.#tokenWithCount('link', {\n                        prefix: '[]()',\n                        content: text,\n                        href\n                    }))\n                    pos = endParen + 1\n                    continue\n                }\n            }\n\n            if ((input.startsWith('http://', pos) || input.startsWith('https://', pos)) && !asPlainText) {\n                const match = input.slice(pos).match(/^(https?:\\/\\/[^\\s`<>\\[\\]()]+)/)\n                if (match) {\n                    const url = match[1]\n                    const prefix = url.startsWith('https://') ? 'https://' : 'http://'\n                    const content = this.#parse(url.slice(prefix.length))\n                    tokens.push(this.#tokenWithCount('url', {prefix, content}))\n                    pos += url.length\n                    continue\n                }\n            }\n\n            if (input[pos] === '@' && !asPlainText) {\n                const match = input.slice(pos).match(/^@([\\w_]+)/)\n                if (match) {\n                    const content = this.#parse(match[1])\n                    tokens.push(this.#tokenWithCount('mention', {prefix: '@', content}))\n                    pos += match[0].length\n                    continue\n                }\n            }\n\n            if (input[pos] === '#' && !asPlainText) {\n                const match = input.slice(pos).match(/^#([\\w-]+)/)\n                if (match) {\n                    const content = this.#parse(match[1])\n                    tokens.push(this.#tokenWithCount('hashtag', {prefix: '#', content}))\n                    pos += match[0].length\n                    continue\n                }\n            }\n\n            const refMatchers = [\n                {prefix: 'a:', type: 'reference', regex: /^a:([\\w_]+)/},\n                {prefix: 'm:', type: 'reference', regex: /^m:([\\w_]+)/},\n                {prefix: 'g:', type: 'reference', regex: /^g:([\\w_]+)/},\n                {prefix: 's:', type: 'reference', regex: /^s:([\\w_]+)/},\n                {prefix: 'c:', type: 'reference', regex: /^c:([\\w_]+)/},\n                {prefix: 'p:', type: 'reference', regex: /^p:([\\w_]+)/},\n                {prefix: 'st:', type: 'reference', regex: /^st:([\\w_]+)/},\n                {prefix: 'e:', type: 'reference', regex: /^e:([\\w_]+)/}\n            ]\n            if (!asPlainText) {\n                let refMatched = false\n                for (const {prefix, type, regex} of refMatchers) {\n                    // Ensure match happens at the start of a word\n                    const isWordBoundary = pos === 0 || /\\W/.test(input[pos - 1])\n\n                    if (!isWordBoundary) {\n                        continue\n                    }\n\n                    const match = input.slice(pos).match(regex)\n\n                    if (match) {\n                        const content = this.#parse(match[1])\n                        tokens.push(this.#tokenWithCount(type, {prefix, content}))\n                        pos += match[0].length\n                        refMatched = true\n                        break\n                    }\n                }\n\n                if (refMatched) {\n                    continue\n                }\n            }\n\n\n            // Default: consume as plain text\n            let next = pos + 1\n\n            while (\n                next < input.length &&\n                input[next] !== '\\\\' &&\n                input[next] !== '`' &&\n                input[next] !== '*' &&\n                input[next] !== '_' &&\n                input[next] !== '~' &&\n                input[next] !== '^' &&\n                input[next] !== '|' &&\n                input[next] !== '=' &&\n                input[next] !== '[' &&\n                input[next] !== ':' &&\n                input[next] !== '@' &&\n                input[next] !== '#' &&\n                !refMatchers.some(({regex}) => input.slice(next).match(regex)) &&\n                !(input.startsWith('http://', next) || input.startsWith('https://', next))\n                ) {\n                next++\n            }\n\n            const content = input.slice(pos, next)\n            tokens.push(this.#tokenWithCount('text', {content}))\n            pos = next\n        }\n\n        return tokens\n    }\n\n    /**\n     * Creates a token with a character count.\n     *\n     * @param type {string} The type of the token.\n     * @param data {Object<content>} Additional data for the token, typically containing content.\n     *\n     * @returns {Object<type: string, content: string, charCount: number>}\n     */\n    #tokenWithCount(type, data = {}) {\n        if (Array.isArray(data.content)) {\n            return {type, ...data, charCount: this.#calculateCharCount(data.content)}\n        } else if (typeof data.content === 'string') {\n            /** @type {Object<type: string, content: string, charCount: number>} */\n            let ast = {type: type, ...data, charCount: 0}\n            ast.charCount = this.#calculateCharCount([ast])\n            return ast\n        } else {\n            return {type, ...data, charCount: 0} // fallback for empty or unexpected content\n        }\n    }\n\n    /**\n     * Formats a Markdown AST into HTML, applying character limits.\n     *\n     * @param ast {Object<type: string, content: string>[]} The AST of the Markdown.\n     * @param charLimit {number} The character limit for rendering.\n     * @param charCountCallback {function(count: number)} A callback function to receive the character count.\n     *\n     * @returns {string} The formatted HTML string.\n     */\n    #formatEdit(ast, charLimit, charCountCallback) {\n        const escapeHTML = this.#escapeHTML\n        let count = 0\n        charCountCallback(count)\n\n        const renderToken = (token) => {\n            return [...token.content].map(ch => {\n                let render = this.#renderOverCharacterLimit(count, charLimit, escapeHTML(ch))\n                    .replace(/\\r\\n|\\r|\\n/g, '<br>')\n                count += ch.replace(/\\r\\n|\\r|\\n/g, '').length\n                charCountCallback(count)\n                return render\n            }).join('')\n        }\n\n        const renderAst = (ast) => {\n            let output = []\n            const render = (token, html) => {\n                const subAST = renderAst(token.content)\n                return html.replace('%s', subAST)\n            };\n\n            for (const token of ast) {\n                switch (token.type) {\n                    case 'text':\n                        output.push(renderToken(token))\n                        break\n                    case 'bold':\n                        output.push(render(token, '<b>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</b>'))\n                        break\n                    case 'italic':\n                        output.push(render(token, '<i>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</i>'))\n                        break\n                    case 'underline':\n                        output.push(render(token, '<u>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</u>'))\n                        break\n                    case 'strikethrough':\n                        output.push(render(token, '<s>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</s>'))\n                        break\n                    case 'highlight':\n                        output.push(render(token, '<span class=\"bg-secondary\">' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</span>'))\n                        break\n                    case 'superscript':\n                        output.push(render(token, '<sup>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</sup>'))\n                        break\n                    case 'subscript':\n                        output.push(render(token, '<sub>' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</sub>'))\n                        break\n                    case 'spoiler':\n                        output.push(render(token, '<span class=\"spoiled\">' + this.#wrapWithOpacity(token.prefix, '%s', count, charLimit) + '</span>'))\n                        break\n                    case 'code':\n                        output.push(this.#renderOverCharacterLimit(count, charLimit, `<code class=\"bg-secondary\">\\`${renderAst(token.content)}\\`</code>`))\n                        break\n                    case 'emoji':\n                        output.push(this.#renderOverCharacterLimit(count, charLimit, this.#renderEmoji(token.name)))\n                        charCountCallback(count++)\n                        break\n                    case 'mention':\n                        output.push(this.#renderMention(renderAst(token.content)))\n                        break\n                    case 'hashtag':\n                        output.push(this.#renderHashtag(renderAst(token.content)))\n                        break\n                    case 'url':\n                        output.push(this.#renderURL(token.prefix, renderAst(token.content)))\n                        break\n                    case 'reference':\n                        output.push(this.#renderReference(token.prefix, renderAst(token.content)))\n                        break\n                    case 'link':\n                        output.push(`<span>[${renderAst(token.content)}](${renderAst(token.href)})</span>`)\n                        break\n                    default:\n                        break\n                }\n            }\n            return output.join('')\n        }\n\n        return renderAst(ast)\n    }\n\n    /**\n     * Formats a Markdown AST into HTML for viewing.\n     *\n     * @param ast {Object<type: string, content: string>[]} The AST of the Markdown.\n     *\n     * @returns {string} The formatted HTML string.\n     */\n    #formatView(ast) {\n        const escapeHTML = this.#escapeHTML\n\n        const renderToken = (token, asPlainText) => {\n            return asPlainText\n                ? escapeHTML(token.content)\n                : `<span>${escapeHTML(token.content)}</span>`\n        }\n\n        const renderAst = (ast, asPlainText = false) => {\n            let output = []\n            const render = (token, html) => {\n                const subAST = renderAst(token.content)\n                return html.replace('%s', subAST)\n            };\n\n            for (const token of ast) {\n                switch (token.type) {\n                    case 'text':\n                        output.push(renderToken(token, asPlainText))\n                        break\n                    case 'bold':\n                        output.push(render(token, '<b>%s</b>'))\n                        break\n                    case 'italic':\n                        output.push(render(token, '<i>%s</i>'))\n                        break\n                    case 'underline':\n                        output.push(render(token, '<u>%s</u>'))\n                        break\n                    case 'strikethrough':\n                        output.push(render(token, '<s>%s</s>'))\n                        break\n                    case 'highlight':\n                        output.push(render(token, '<span class=\"bg-secondary\">%s</span>'))\n                        break\n                    case 'superscript':\n                        output.push(render(token, '<sup>%s</sup>'))\n                        break\n                    case 'subscript':\n                        output.push(render(token, '<sub>%s</sub>'))\n                        break\n                    case 'spoiler':\n                        output.push(render(token, `<span class=\"spoiler\" x-on:click=\"$el.classList.replace('spoiler', 'spoiled')\">%s</span>`))\n                        break\n                    case 'code':\n                        output.push(`<code class=\"bg-secondary\">${renderAst(token.content)}</code>`)\n                        break\n                    case 'emoji':\n                        output.push(this.#renderEmoji(token.name))\n                        break\n                    case 'mention':\n                        const username = renderAst(token.content, true)\n                        output.push(`<a href=\"/profile/${username}\" class=\"text-tint\" wire:navigate.hover>${'@' + username}</a>`)\n                        break\n                    case 'hashtag':\n                        output.push(this.#renderHashtag(renderAst(token.content, true)))\n                        break\n                    case 'url':\n                        const url = renderAst(token.content, true)\n                        output.push(\n                            asPlainText\n                                ? (token.prefix + url)\n                                : `<a href=\"${token.prefix + url}\" target=\"_blank\" class=\"text-tint\">${url}</a>`\n                        )\n                        break\n                    case 'reference':\n                        output.push(`<span class=\"text-tint\">${renderAst(token.content, true)}</span>`)\n                        break\n                    case 'link':\n                        output.push(`<a href=\"${renderAst(token.href, true)}\" target=\"_blank\" class=\"text-tint\">${renderAst(token.content, true)}</a>`)\n                        break\n                    default:\n                        break\n                }\n            }\n            return output.join('')\n        }\n\n        return renderAst(ast)\n    }\n\n    #wrapWithTint(marker, content) {\n        return `<span class=\"text-tint\">${marker}${content}</span>`\n    }\n\n    /**\n     * Wraps the content with opacity for character limit indication.\n     *\n     * @param marker The marker to wrap around the content.\n     * @param content The content to be wrapped.\n     * @param count The current character count.\n     * @param charLimit The character limit to check against.\n     *\n     * @returns {string}\n     */\n    #wrapWithOpacity(marker, content, count, charLimit) {\n        return `<span class=\"opacity-75\">${this.#renderOverCharacterLimit(count, charLimit, marker)}</span>${content}<span class=\"opacity-75\">${this.#renderOverCharacterLimit(count, charLimit, marker)}</span>`\n    }\n\n    /**\n     * Renders a URL token into an HTML anchor tag.\n     *\n     * @param name {string} The emoji name.\n     *\n     * @returns {*|string} The rendered HTML string.\n     */\n    #renderEmoji(name) {\n        const map = {smile: '😄', sad: '😢', fire: '🔥', heart: '❤️'}\n        return map[name] ? map[name] : `:${name}:`\n    }\n\n    /**\n     * Renders a URL token into an HTML anchor tag.\n     *\n     * @param name {string} The username.\n     *\n     * @returns {string} The rendered HTML string.\n     */\n    #renderMention(name) {\n        return `<span class=\"text-tint\">@${name}</span>`\n    }\n\n    /**\n     * Renders a URL token into an HTML anchor tag.\n     *\n     * @param name {string} The hashtag name.\n     *\n     * @returns {string} The rendered HTML string.\n     */\n    #renderHashtag(name) {\n        return `<span class=\"text-tint\">#${name}</span>`;\n    }\n\n    /**\n     * Renders over character limit by wrapping the text in a span with a red background.\n     *\n     * @param currentCount {number} The current character count.\n     * @param limit {number} The character limit.\n     * @param html {string} The HTML content to render.\n     *\n     * @returns {*|string} The rendered HTML string, with text wrapped in a red background if over the limit.\n     */\n    #renderOverCharacterLimit(currentCount, limit, html) {\n        const isOver = currentCount >= limit\n        if (!isOver) {\n            return html\n        }\n\n        const div = document.createElement('div')\n        div.innerHTML = html\n\n        // Recursively wrap the text content of child nodes\n        const wrapTextNodes = node => {\n            node.childNodes.forEach(child => {\n                if (child.nodeType === Node.TEXT_NODE) {\n                    const span = document.createElement('span')\n                    span.className = 'bg-red-500'\n                    span.textContent = child.textContent\n                    node.replaceChild(span, child)\n                } else if (child.nodeType === Node.ELEMENT_NODE) {\n                    wrapTextNodes(child)\n                }\n            })\n        }\n\n        wrapTextNodes(div)\n\n        return div.innerHTML\n    }\n\n    /**\n     * Renders a URL token into an HTML span with a specific scheme.\n     *\n     * @param scheme {string} The URL scheme (e.g., 'http://', 'https://').\n     * @param url {string} The URL to render.\n     *\n     * @returns {string} The rendered HTML string.\n     */\n    #renderURL(scheme, url) {\n        return `<span class=\"text-tint\">${scheme}${url}</span>`\n    }\n\n    /**\n     * Renders a reference token into an HTML span with a specific prefix.\n     *\n     * @param prefix {string} The prefix for the reference (e.g., 'a:', 'm:', 'g:').\n     * @param name {string} The name of the reference.\n     *\n     * @returns {string} The rendered HTML string.\n     */\n    #renderReference(prefix, name) {\n        return `<span class=\"text-tint\">${prefix}${name}</span>`\n    }\n}\n","import Markdown from './helpers/markdown'\n\nwindow.markdown = new Markdown()\n"],"names":["Markdown","_classCallCheck","_classPrivateMethodInitSpec","_Markdown_brand","key","value","text","chartLimit","charCountCallback","arguments","length","undefined","forView","ast","_assertClassBrand","this","_parse","call","_formatView","_formatEdit","_escapeHTML","replace","_calculateCharCount","_step","count","_iterator","_createForOfIteratorHelper","s","n","done","token","type","_toConsumableArray","content","_step2","_iterator2","err","e","f","input","_this","asPlainText","tokens","pos","self","matchPair","str","start","open","close","parseInner","startsWith","end","indexOf","slice","includes","parsed","_tokenWithCount","prefix","len","_loop","push","matched","_i","_pairTypes","_pairTypes$_i","_slicedToArray","result","bind","name","test","endBracket","startParen","endParen","href","match","url","refMatchers","regex","_step3","refMatched","_iterator3","_step3$value","next","some","_ref","data","Array","isArray","_objectSpread","charCount","charLimit","_this2","escapeHTML","renderToken","map","ch","render","_renderOverCharacterLimit","join","renderAst","_step4","output","html","subAST","_iterator4","_wrapWithOpacity","concat","_renderEmoji","_renderMention","_renderHashtag","_renderURL","_renderReference","_this3","_step5","_iterator5","username","marker","smile","sad","fire","heart","currentCount","limit","div","document","createElement","innerHTML","wrapTextNodes","node","childNodes","forEach","child","nodeType","Node","TEXT_NODE","span","className","textContent","replaceChild","ELEMENT_NODE","scheme","window","markdown"],"sourceRoot":""}