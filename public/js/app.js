/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@jaames/iro/dist/iro.es.js":
/*!*************************************************!*\
  !*** ./node_modules/@jaames/iro/dist/iro.es.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * iro.js v5.5.0\n * 2016-2021 James Daniel\n * Licensed under MPL 2.0\n * github.com/jaames/iro.js\n */\n\nvar n,u,t,i,r,o,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;function s(n,l){for(var u in l){ n[u]=l[u]; }return n}function a(n){var l=n.parentNode;l&&l.removeChild(n);}function h(n,l,u){var t,i,r,o,f=arguments;if(l=s({},l),arguments.length>3){ for(u=[u],t=3;t<arguments.length;t++){ u.push(f[t]); } }if(null!=u&&(l.children=u),null!=n&&null!=n.defaultProps){ for(i in n.defaultProps){ void 0===l[i]&&(l[i]=n.defaultProps[i]); } }return o=l.key,null!=(r=l.ref)&&delete l.ref,null!=o&&delete l.key,v(n,l,o,r)}function v(l,u,t,i){var r={type:l,props:u,key:t,ref:i,__k:null,__p:null,__b:0,__e:null,l:null,__c:null,constructor:void 0};return n.vnode&&n.vnode(r),r}function d(n){return n.children}function y(n){if(null==n||\"boolean\"==typeof n){ return null; }if(\"string\"==typeof n||\"number\"==typeof n){ return v(null,n,null,null); }if(null!=n.__e||null!=n.__c){var l=v(n.type,n.props,n.key,null);return l.__e=n.__e,l}return n}function m(n,l){this.props=n,this.context=l;}function w(n,l){if(null==l){ return n.__p?w(n.__p,n.__p.__k.indexOf(n)+1):null; }for(var u;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){ return u.__e; } }return \"function\"==typeof n.type?w(n):null}function g(n){var l,u;if(null!=(n=n.__p)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++){ if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break} }return g(n)}}function k(l){(!l.__d&&(l.__d=!0)&&1===u.push(l)||i!==n.debounceRendering)&&(i=n.debounceRendering,(n.debounceRendering||t)(_));}function _(){var n,l,t,i,r,o,f,e;for(u.sort(function(n,l){return l.__v.__b-n.__v.__b});n=u.pop();){ n.__d&&(t=void 0,i=void 0,o=(r=(l=n).__v).__e,f=l.__P,e=l.u,l.u=!1,f&&(t=[],i=$(f,r,s({},r),l.__n,void 0!==f.ownerSVGElement,null,t,e,null==o?w(r):o),j(t,r),i!=o&&g(r))); }}function b(n,l,u,t,i,r,o,c,s){var h,v,p,d,y,m,g,k=u&&u.__k||e,_=k.length;if(c==f&&(c=null!=r?r[0]:_?w(u,0):null),h=0,l.__k=x(l.__k,function(u){if(null!=u){if(u.__p=l,u.__b=l.__b+1,null===(p=k[h])||p&&u.key==p.key&&u.type===p.type){ k[h]=void 0; }else { for(v=0;v<_;v++){if((p=k[v])&&u.key==p.key&&u.type===p.type){k[v]=void 0;break}p=null;} }if(d=$(n,u,p=p||f,t,i,r,o,null,c,s),(v=u.ref)&&p.ref!=v&&(g||(g=[])).push(v,u.__c||d,u),null!=d){if(null==m&&(m=d),null!=u.l){ d=u.l,u.l=null; }else if(r==p||d!=c||null==d.parentNode){n:if(null==c||c.parentNode!==n){ n.appendChild(d); }else{for(y=c,v=0;(y=y.nextSibling)&&v<_;v+=2){ if(y==d){ break n; } }n.insertBefore(d,c);}\"option\"==l.type&&(n.value=\"\");}c=d.nextSibling,\"function\"==typeof l.type&&(l.l=d);}}return h++,u}),l.__e=m,null!=r&&\"function\"!=typeof l.type){ for(h=r.length;h--;){ null!=r[h]&&a(r[h]); } }for(h=_;h--;){ null!=k[h]&&D(k[h],k[h]); }if(g){ for(h=0;h<g.length;h++){ A(g[h],g[++h],g[++h]); } }}function x(n,l,u){if(null==u&&(u=[]),null==n||\"boolean\"==typeof n){ l&&u.push(l(null)); }else if(Array.isArray(n)){ for(var t=0;t<n.length;t++){ x(n[t],l,u); } }else { u.push(l?l(y(n)):n); }return u}function C(n,l,u,t,i){var r;for(r in u){ r in l||N(n,r,null,u[r],t); }for(r in l){ i&&\"function\"!=typeof l[r]||\"value\"===r||\"checked\"===r||u[r]===l[r]||N(n,r,l[r],u[r],t); }}function P(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=\"number\"==typeof u&&!1===c.test(l)?u+\"px\":null==u?\"\":u;}function N(n,l,u,t,i){var r,o,f,e,c;if(\"key\"===(l=i?\"className\"===l?\"class\":l:\"class\"===l?\"className\":l)||\"children\"===l);else if(\"style\"===l){ if(r=n.style,\"string\"==typeof u){ r.cssText=u; }else{if(\"string\"==typeof t&&(r.cssText=\"\",t=null),t){ for(o in t){ u&&o in u||P(r,o,\"\"); } }if(u){ for(f in u){ t&&u[f]===t[f]||P(r,f,u[f]); } }} }else{ \"o\"===l[0]&&\"n\"===l[1]?(e=l!==(l=l.replace(/Capture$/,\"\")),c=l.toLowerCase(),l=(c in n?c:l).slice(2),u?(t||n.addEventListener(l,T,e),(n.t||(n.t={}))[l]=u):n.removeEventListener(l,T,e)):\"list\"!==l&&\"tagName\"!==l&&\"form\"!==l&&!i&&l in n?n[l]=null==u?\"\":u:\"function\"!=typeof u&&\"dangerouslySetInnerHTML\"!==l&&(l!==(l=l.replace(/^xlink:?/,\"\"))?null==u||!1===u?n.removeAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase()):n.setAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase(),u):null==u||!1===u?n.removeAttribute(l):n.setAttribute(l,u)); }}function T(l){return this.t[l.type](n.event?n.event(l):l)}function $(l,u,t,i,r,o,f,e,c,a){var h,v,p,y,w,g,k,_,C,P,N=u.type;if(void 0!==u.constructor){ return null; }(h=n.__b)&&h(u);try{n:if(\"function\"==typeof N){if(_=u.props,C=(h=N.contextType)&&i[h.__c],P=h?C?C.props.value:h.__p:i,t.__c?k=(v=u.__c=t.__c).__p=v.__E:(\"prototype\"in N&&N.prototype.render?u.__c=v=new N(_,P):(u.__c=v=new m(_,P),v.constructor=N,v.render=H),C&&C.sub(v),v.props=_,v.state||(v.state={}),v.context=P,v.__n=i,p=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=N.getDerivedStateFromProps&&s(v.__s==v.state?v.__s=s({},v.__s):v.__s,N.getDerivedStateFromProps(_,v.__s)),p){ null==N.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&f.push(v); }else{if(null==N.getDerivedStateFromProps&&null==e&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(_,P),!e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(_,v.__s,P)){for(v.props=_,v.state=v.__s,v.__d=!1,v.__v=u,u.__e=null!=c?c!==t.__e?c:t.__e:null,u.__k=t.__k,h=0;h<u.__k.length;h++){ u.__k[h]&&(u.__k[h].__p=u); }break n}null!=v.componentWillUpdate&&v.componentWillUpdate(_,v.__s,P);}for(y=v.props,w=v.state,v.context=P,v.props=_,v.state=v.__s,(h=n.__r)&&h(u),v.__d=!1,v.__v=u,v.__P=l,h=v.render(v.props,v.state,v.context),u.__k=x(null!=h&&h.type==d&&null==h.key?h.props.children:h),null!=v.getChildContext&&(i=s(s({},i),v.getChildContext())),p||null==v.getSnapshotBeforeUpdate||(g=v.getSnapshotBeforeUpdate(y,w)),b(l,u,t,i,r,o,f,c,a),v.base=u.__e;h=v.__h.pop();){ v.__s&&(v.state=v.__s),h.call(v); }p||null==y||null==v.componentDidUpdate||v.componentDidUpdate(y,w,g),k&&(v.__E=v.__p=null);}else { u.__e=z(t.__e,u,t,i,r,o,f,a); }(h=n.diffed)&&h(u);}catch(l){n.__e(l,u,t);}return u.__e}function j(l,u){for(var t;t=l.pop();){ try{t.componentDidMount();}catch(l){n.__e(l,t.__v);} }n.__c&&n.__c(u);}function z(n,l,u,t,i,r,o,c){var s,a,h,v,p=u.props,d=l.props;if(i=\"svg\"===l.type||i,null==n&&null!=r){ for(s=0;s<r.length;s++){ if(null!=(a=r[s])&&(null===l.type?3===a.nodeType:a.localName===l.type)){n=a,r[s]=null;break} } }if(null==n){if(null===l.type){ return document.createTextNode(d); }n=i?document.createElementNS(\"http://www.w3.org/2000/svg\",l.type):document.createElement(l.type),r=null;}return null===l.type?p!==d&&(null!=r&&(r[r.indexOf(n)]=null),n.data=d):l!==u&&(null!=r&&(r=e.slice.call(n.childNodes)),h=(p=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,c||(v||h)&&(v&&h&&v.__html==h.__html||(n.innerHTML=v&&v.__html||\"\")),C(n,d,p,i,c),l.__k=l.props.children,v||b(n,l,u,t,\"foreignObject\"!==l.type&&i,r,o,f,c),c||(\"value\"in d&&void 0!==d.value&&d.value!==n.value&&(n.value=null==d.value?\"\":d.value),\"checked\"in d&&void 0!==d.checked&&d.checked!==n.checked&&(n.checked=d.checked))),n}function A(l,u,t){try{\"function\"==typeof l?l(u):l.current=u;}catch(l){n.__e(l,t);}}function D(l,u,t){var i,r,o;if(n.unmount&&n.unmount(l),(i=l.ref)&&A(i,null,u),t||\"function\"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.l=null,null!=(i=l.__c)){if(i.componentWillUnmount){ try{i.componentWillUnmount();}catch(l){n.__e(l,u);} }i.base=i.__P=null;}if(i=l.__k){ for(o=0;o<i.length;o++){ i[o]&&D(i[o],u,t); } }null!=r&&a(r);}function H(n,l,u){return this.constructor(n,u)}function I(l,u,t){var i,o,c;n.__p&&n.__p(l,u),o=(i=t===r)?null:t&&t.__k||u.__k,l=h(d,null,[l]),c=[],$(u,i?u.__k=l:(t||u).__k=l,o||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:o?null:e.slice.call(u.childNodes),c,!1,t||f,i),j(c,l);}n={},m.prototype.setState=function(n,l){var u=this.__s!==this.state&&this.__s||(this.__s=s({},this.state));(\"function\"!=typeof n||(n=n(u,this.props)))&&s(u,n),null!=n&&this.__v&&(this.u=!1,l&&this.__h.push(l),k(this));},m.prototype.forceUpdate=function(n){this.__v&&(n&&this.__h.push(n),this.u=!0,k(this));},m.prototype.render=d,u=[],t=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,i=n.debounceRendering,n.__e=function(n,l,u){for(var t;l=l.__p;){ if((t=l.__c)&&!t.__p){ try{if(t.constructor&&null!=t.constructor.getDerivedStateFromError){ t.setState(t.constructor.getDerivedStateFromError(n)); }else{if(null==t.componentDidCatch){ continue; }t.componentDidCatch(n);}return k(t.__E=t)}catch(l){n=l;} } }throw n},r=f,o=0;\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) { descriptor.writable = true; }\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) { _defineProperties(Constructor.prototype, protoProps); }\n  if (staticProps) { _defineProperties(Constructor, staticProps); }\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    var arguments$1 = arguments;\n\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments$1[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\n// Some regular expressions for rgb() and hsl() Colors are borrowed from tinyColor\n// https://github.com/bgrins/TinyColor\n// Kelvin temperature math borrowed from Neil Barlett's implementation\n// from https://github.com/neilbartlett/color-temperature\n// https://www.w3.org/TR/css3-values/#integers\nvar CSS_INTEGER = '[-\\\\+]?\\\\d+%?'; // http://www.w3.org/TR/css3-values/#number-value\n\nvar CSS_NUMBER = '[-\\\\+]?\\\\d*\\\\.\\\\d+%?'; // Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome\n\nvar CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')'; // Parse function params\n// Parens and commas are optional, and this also allows for whitespace between numbers\n\nvar PERMISSIVE_MATCH_3 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?';\nvar PERMISSIVE_MATCH_4 = '[\\\\s|\\\\(]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')[,|\\\\s]+(' + CSS_UNIT + ')\\\\s*\\\\)?'; // Regex patterns for functional color strings\n\nvar REGEX_FUNCTIONAL_RGB = new RegExp('rgb' + PERMISSIVE_MATCH_3);\nvar REGEX_FUNCTIONAL_RGBA = new RegExp('rgba' + PERMISSIVE_MATCH_4);\nvar REGEX_FUNCTIONAL_HSL = new RegExp('hsl' + PERMISSIVE_MATCH_3);\nvar REGEX_FUNCTIONAL_HSLA = new RegExp('hsla' + PERMISSIVE_MATCH_4); // Color string parsing regex\n\nvar HEX_START = '^(?:#?|0x?)';\nvar HEX_INT_SINGLE = '([0-9a-fA-F]{1})';\nvar HEX_INT_DOUBLE = '([0-9a-fA-F]{2})';\nvar REGEX_HEX_3 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nvar REGEX_HEX_4 = new RegExp(HEX_START + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + HEX_INT_SINGLE + '$');\nvar REGEX_HEX_6 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$');\nvar REGEX_HEX_8 = new RegExp(HEX_START + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + HEX_INT_DOUBLE + '$'); // Kelvin temperature bounds\n\nvar KELVIN_MIN = 2000;\nvar KELVIN_MAX = 40000; // Math shorthands\n\nvar log = Math.log,\n    round = Math.round,\n    floor = Math.floor;\n/**\r\n * @desc Clamp a number between a min and max value\r\n * @param num - input value\r\n * @param min - min allowed value\r\n * @param max - max allowed value\r\n */\n\nfunction clamp(num, min, max) {\n  return Math.min(Math.max(num, min), max);\n}\n/**\r\n * @desc Parse a css unit string - either regular int or a percentage number\r\n * @param str - css unit string\r\n * @param max - max unit value, used for calculating percentages\r\n */\n\n\nfunction parseUnit(str, max) {\n  var isPercentage = str.indexOf('%') > -1;\n  var num = parseFloat(str);\n  return isPercentage ? max / 100 * num : num;\n}\n/**\r\n * @desc Parse hex str to an int\r\n * @param str - hex string to parse\r\n */\n\n\nfunction parseHexInt(str) {\n  return parseInt(str, 16);\n}\n/**\r\n * @desc Convert nunber into to 2-digit hex\r\n * @param int - number to convert\r\n */\n\n\nfunction intToHex(_int) {\n  return _int.toString(16).padStart(2, '0');\n}\n\nvar IroColor =\n/*#__PURE__*/\nfunction () {\n  /**\r\n    * @constructor Color object\r\n    * @param value - initial color value\r\n  */\n  function IroColor(value, onChange) {\n    // The default Color value\n    this.$ = {\n      h: 0,\n      s: 0,\n      v: 0,\n      a: 1\n    };\n    if (value) { this.set(value); } // The watch callback function for this Color will be stored here\n\n    this.onChange = onChange;\n    this.initialValue = _extends({}, this.$); // copy initial value\n  }\n  /**\r\n    * @desc Set the Color from any valid value\r\n    * @param value - new color value\r\n  */\n\n\n  var _proto = IroColor.prototype;\n\n  _proto.set = function set(value) {\n    if (typeof value === 'string') {\n      if (/^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(value)) {\n        this.hexString = value;\n      } else if (/^rgba?/.test(value)) {\n        this.rgbString = value;\n      } else if (/^hsla?/.test(value)) {\n        this.hslString = value;\n      }\n    } else if (typeof value === 'object') {\n      if (value instanceof IroColor) {\n        this.hsv = value.hsv;\n      } else if ('r' in value && 'g' in value && 'b' in value) {\n        this.rgb = value;\n      } else if ('h' in value && 's' in value && 'v' in value) {\n        this.hsv = value;\n      } else if ('h' in value && 's' in value && 'l' in value) {\n        this.hsl = value;\n      } else if ('kelvin' in value) {\n        this.kelvin = value.kelvin;\n      }\n    } else {\n      throw new Error('Invalid color value');\n    }\n  }\n  /**\r\n    * @desc Shortcut to set a specific channel value\r\n    * @param format - hsv | hsl | rgb\r\n    * @param channel - individual channel to set, for example if model = hsl, chanel = h | s | l\r\n    * @param value - new value for the channel\r\n  */\n  ;\n\n  _proto.setChannel = function setChannel(format, channel, value) {\n    var _extends2;\n\n    this[format] = _extends({}, this[format], (_extends2 = {}, _extends2[channel] = value, _extends2));\n  }\n  /**\r\n   * @desc Reset color back to its initial value\r\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this.hsva = this.initialValue;\n  }\n  /**\r\n    * @desc make new Color instance with the same value as this one\r\n  */\n  ;\n\n  _proto.clone = function clone() {\n    return new IroColor(this);\n  }\n  /**\r\n   * @desc remove color onChange\r\n   */\n  ;\n\n  _proto.unbind = function unbind() {\n    this.onChange = undefined;\n  }\n  /**\r\n    * @desc Convert hsv object to rgb\r\n    * @param hsv - hsv color object\r\n  */\n  ;\n\n  IroColor.hsvToRgb = function hsvToRgb(hsv) {\n    var h = hsv.h / 60;\n    var s = hsv.s / 100;\n    var v = hsv.v / 100;\n    var i = floor(h);\n    var f = h - i;\n    var p = v * (1 - s);\n    var q = v * (1 - f * s);\n    var t = v * (1 - (1 - f) * s);\n    var mod = i % 6;\n    var r = [v, q, p, p, t, v][mod];\n    var g = [t, v, v, q, p, p][mod];\n    var b = [p, p, t, v, v, q][mod];\n    return {\n      r: clamp(r * 255, 0, 255),\n      g: clamp(g * 255, 0, 255),\n      b: clamp(b * 255, 0, 255)\n    };\n  }\n  /**\r\n    * @desc Convert rgb object to hsv\r\n    * @param rgb - rgb object\r\n  */\n  ;\n\n  IroColor.rgbToHsv = function rgbToHsv(rgb) {\n    var r = rgb.r / 255;\n    var g = rgb.g / 255;\n    var b = rgb.b / 255;\n    var max = Math.max(r, g, b);\n    var min = Math.min(r, g, b);\n    var delta = max - min;\n    var hue = 0;\n    var value = max;\n    var saturation = max === 0 ? 0 : delta / max;\n\n    switch (max) {\n      case min:\n        hue = 0; // achromatic\n\n        break;\n\n      case r:\n        hue = (g - b) / delta + (g < b ? 6 : 0);\n        break;\n\n      case g:\n        hue = (b - r) / delta + 2;\n        break;\n\n      case b:\n        hue = (r - g) / delta + 4;\n        break;\n    }\n\n    return {\n      h: hue * 60 % 360,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp(value * 100, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert hsv object to hsl\r\n    * @param hsv - hsv object\r\n  */\n  ;\n\n  IroColor.hsvToHsl = function hsvToHsl(hsv) {\n    var s = hsv.s / 100;\n    var v = hsv.v / 100;\n    var l = (2 - s) * v;\n    var divisor = l <= 1 ? l : 2 - l; // Avoid division by zero when lightness is close to zero\n\n    var saturation = divisor < 1e-9 ? 0 : s * v / divisor;\n    return {\n      h: hsv.h,\n      s: clamp(saturation * 100, 0, 100),\n      l: clamp(l * 50, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert hsl object to hsv\r\n    * @param hsl - hsl object\r\n  */\n  ;\n\n  IroColor.hslToHsv = function hslToHsv(hsl) {\n    var l = hsl.l * 2;\n    var s = hsl.s * (l <= 100 ? l : 200 - l) / 100; // Avoid division by zero when l + s is near 0\n\n    var saturation = l + s < 1e-9 ? 0 : 2 * s / (l + s);\n    return {\n      h: hsl.h,\n      s: clamp(saturation * 100, 0, 100),\n      v: clamp((l + s) / 2, 0, 100)\n    };\n  }\n  /**\r\n    * @desc Convert a kelvin temperature to an approx, RGB value\r\n    * @param kelvin - kelvin temperature\r\n  */\n  ;\n\n  IroColor.kelvinToRgb = function kelvinToRgb(kelvin) {\n    var temp = kelvin / 100;\n    var r, g, b;\n\n    if (temp < 66) {\n      r = 255;\n      g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);\n      b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);\n    } else {\n      r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);\n      g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);\n      b = 255;\n    }\n\n    return {\n      r: clamp(floor(r), 0, 255),\n      g: clamp(floor(g), 0, 255),\n      b: clamp(floor(b), 0, 255)\n    };\n  }\n  /**\r\n   * @desc Convert an RGB color to an approximate kelvin temperature\r\n   * @param kelvin - kelvin temperature\r\n  */\n  ;\n\n  IroColor.rgbToKelvin = function rgbToKelvin(rgb) {\n    var r = rgb.r,\n        b = rgb.b;\n    var eps = 0.4;\n    var minTemp = KELVIN_MIN;\n    var maxTemp = KELVIN_MAX;\n    var temp;\n\n    while (maxTemp - minTemp > eps) {\n      temp = (maxTemp + minTemp) * 0.5;\n\n      var _rgb = IroColor.kelvinToRgb(temp);\n\n      if (_rgb.b / _rgb.r >= b / r) {\n        maxTemp = temp;\n      } else {\n        minTemp = temp;\n      }\n    }\n\n    return temp;\n  };\n\n  _createClass(IroColor, [{\n    key: \"hsv\",\n    get: function get() {\n      // value is cloned to allow changes to be made to the values before passing them back\n      var value = this.$;\n      return {\n        h: value.h,\n        s: value.s,\n        v: value.v\n      };\n    },\n    set: function set(newValue) {\n      var oldValue = this.$;\n      newValue = _extends({}, oldValue, newValue); // If this Color is being watched for changes we need to compare the new and old values to check the difference\n      // Otherwise we can just be lazy\n\n      if (this.onChange) {\n        // Compute changed values\n        var changes = {\n          h: false,\n          v: false,\n          s: false,\n          a: false\n        };\n\n        for (var key in oldValue) {\n          changes[key] = newValue[key] != oldValue[key];\n        }\n\n        this.$ = newValue; // If the value has changed, call hook callback\n\n        if (changes.h || changes.s || changes.v || changes.a) { this.onChange(this, changes); }\n      } else {\n        this.$ = newValue;\n      }\n    }\n  }, {\n    key: \"hsva\",\n    get: function get() {\n      return _extends({}, this.$);\n    },\n    set: function set(value) {\n      this.hsv = value;\n    }\n  }, {\n    key: \"hue\",\n    get: function get() {\n      return this.$.h;\n    },\n    set: function set(value) {\n      this.hsv = {\n        h: value\n      };\n    }\n  }, {\n    key: \"saturation\",\n    get: function get() {\n      return this.$.s;\n    },\n    set: function set(value) {\n      this.hsv = {\n        s: value\n      };\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.$.v;\n    },\n    set: function set(value) {\n      this.hsv = {\n        v: value\n      };\n    }\n  }, {\n    key: \"alpha\",\n    get: function get() {\n      return this.$.a;\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, this.hsv, {\n        a: value\n      });\n    }\n  }, {\n    key: \"kelvin\",\n    get: function get() {\n      return IroColor.rgbToKelvin(this.rgb);\n    },\n    set: function set(value) {\n      this.rgb = IroColor.kelvinToRgb(value);\n    }\n  }, {\n    key: \"red\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.r;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        r: value\n      });\n    }\n  }, {\n    key: \"green\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.g;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        g: value\n      });\n    }\n  }, {\n    key: \"blue\",\n    get: function get() {\n      var rgb = this.rgb;\n      return rgb.b;\n    },\n    set: function set(value) {\n      this.rgb = _extends({}, this.rgb, {\n        b: value\n      });\n    }\n  }, {\n    key: \"rgb\",\n    get: function get() {\n      var _IroColor$hsvToRgb = IroColor.hsvToRgb(this.$),\n          r = _IroColor$hsvToRgb.r,\n          g = _IroColor$hsvToRgb.g,\n          b = _IroColor$hsvToRgb.b;\n\n      return {\n        r: round(r),\n        g: round(g),\n        b: round(b)\n      };\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, IroColor.rgbToHsv(value), {\n        a: value.a === undefined ? 1 : value.a\n      });\n    }\n  }, {\n    key: \"rgba\",\n    get: function get() {\n      return _extends({}, this.rgb, {\n        a: this.alpha\n      });\n    },\n    set: function set(value) {\n      this.rgb = value;\n    }\n  }, {\n    key: \"hsl\",\n    get: function get() {\n      var _IroColor$hsvToHsl = IroColor.hsvToHsl(this.$),\n          h = _IroColor$hsvToHsl.h,\n          s = _IroColor$hsvToHsl.s,\n          l = _IroColor$hsvToHsl.l;\n\n      return {\n        h: round(h),\n        s: round(s),\n        l: round(l)\n      };\n    },\n    set: function set(value) {\n      this.hsv = _extends({}, IroColor.hslToHsv(value), {\n        a: value.a === undefined ? 1 : value.a\n      });\n    }\n  }, {\n    key: \"hsla\",\n    get: function get() {\n      return _extends({}, this.hsl, {\n        a: this.alpha\n      });\n    },\n    set: function set(value) {\n      this.hsl = value;\n    }\n  }, {\n    key: \"rgbString\",\n    get: function get() {\n      var rgb = this.rgb;\n      return \"rgb(\" + rgb.r + \", \" + rgb.g + \", \" + rgb.b + \")\";\n    },\n    set: function set(value) {\n      var match;\n      var r,\n          g,\n          b,\n          a = 1;\n\n      if (match = REGEX_FUNCTIONAL_RGB.exec(value)) {\n        r = parseUnit(match[1], 255);\n        g = parseUnit(match[2], 255);\n        b = parseUnit(match[3], 255);\n      } else if (match = REGEX_FUNCTIONAL_RGBA.exec(value)) {\n        r = parseUnit(match[1], 255);\n        g = parseUnit(match[2], 255);\n        b = parseUnit(match[3], 255);\n        a = parseUnit(match[4], 1);\n      }\n\n      if (match) {\n        this.rgb = {\n          r: r,\n          g: g,\n          b: b,\n          a: a\n        };\n      } else {\n        throw new Error('Invalid rgb string');\n      }\n    }\n  }, {\n    key: \"rgbaString\",\n    get: function get() {\n      var rgba = this.rgba;\n      return \"rgba(\" + rgba.r + \", \" + rgba.g + \", \" + rgba.b + \", \" + rgba.a + \")\";\n    },\n    set: function set(value) {\n      this.rgbString = value;\n    }\n  }, {\n    key: \"hexString\",\n    get: function get() {\n      var rgb = this.rgb;\n      return \"#\" + intToHex(rgb.r) + intToHex(rgb.g) + intToHex(rgb.b);\n    },\n    set: function set(value) {\n      var match;\n      var r,\n          g,\n          b,\n          a = 255;\n\n      if (match = REGEX_HEX_3.exec(value)) {\n        r = parseHexInt(match[1]) * 17;\n        g = parseHexInt(match[2]) * 17;\n        b = parseHexInt(match[3]) * 17;\n      } else if (match = REGEX_HEX_4.exec(value)) {\n        r = parseHexInt(match[1]) * 17;\n        g = parseHexInt(match[2]) * 17;\n        b = parseHexInt(match[3]) * 17;\n        a = parseHexInt(match[4]) * 17;\n      } else if (match = REGEX_HEX_6.exec(value)) {\n        r = parseHexInt(match[1]);\n        g = parseHexInt(match[2]);\n        b = parseHexInt(match[3]);\n      } else if (match = REGEX_HEX_8.exec(value)) {\n        r = parseHexInt(match[1]);\n        g = parseHexInt(match[2]);\n        b = parseHexInt(match[3]);\n        a = parseHexInt(match[4]);\n      }\n\n      if (match) {\n        this.rgb = {\n          r: r,\n          g: g,\n          b: b,\n          a: a / 255\n        };\n      } else {\n        throw new Error('Invalid hex string');\n      }\n    }\n  }, {\n    key: \"hex8String\",\n    get: function get() {\n      var rgba = this.rgba;\n      return \"#\" + intToHex(rgba.r) + intToHex(rgba.g) + intToHex(rgba.b) + intToHex(floor(rgba.a * 255));\n    },\n    set: function set(value) {\n      this.hexString = value;\n    }\n  }, {\n    key: \"hslString\",\n    get: function get() {\n      var hsl = this.hsl;\n      return \"hsl(\" + hsl.h + \", \" + hsl.s + \"%, \" + hsl.l + \"%)\";\n    },\n    set: function set(value) {\n      var match;\n      var h,\n          s,\n          l,\n          a = 1;\n\n      if (match = REGEX_FUNCTIONAL_HSL.exec(value)) {\n        h = parseUnit(match[1], 360);\n        s = parseUnit(match[2], 100);\n        l = parseUnit(match[3], 100);\n      } else if (match = REGEX_FUNCTIONAL_HSLA.exec(value)) {\n        h = parseUnit(match[1], 360);\n        s = parseUnit(match[2], 100);\n        l = parseUnit(match[3], 100);\n        a = parseUnit(match[4], 1);\n      }\n\n      if (match) {\n        this.hsl = {\n          h: h,\n          s: s,\n          l: l,\n          a: a\n        };\n      } else {\n        throw new Error('Invalid hsl string');\n      }\n    }\n  }, {\n    key: \"hslaString\",\n    get: function get() {\n      var hsla = this.hsla;\n      return \"hsl(\" + hsla.h + \", \" + hsla.s + \"%, \" + hsla.l + \"%, \" + hsla.a + \")\";\n    },\n    set: function set(value) {\n      this.hslString = value;\n    }\n  }]);\n\n  return IroColor;\n}();\n\nvar sliderDefaultOptions = {\n  sliderShape: 'bar',\n  sliderType: 'value',\n  minTemperature: 2200,\n  maxTemperature: 11000\n};\n/**\r\n * @desc Get the bounding dimensions of the slider\r\n * @param props - slider props\r\n */\n\nfunction getSliderDimensions(props) {\n  var _sliderSize;\n\n  var width = props.width,\n      sliderSize = props.sliderSize,\n      borderWidth = props.borderWidth,\n      handleRadius = props.handleRadius,\n      padding = props.padding,\n      sliderShape = props.sliderShape;\n  var ishorizontal = props.layoutDirection === 'horizontal'; // automatically calculate sliderSize if its not defined\n\n  sliderSize = (_sliderSize = sliderSize) != null ? _sliderSize : padding * 2 + handleRadius * 2;\n\n  if (sliderShape === 'circle') {\n    return {\n      handleStart: props.padding + props.handleRadius,\n      handleRange: width - padding * 2 - handleRadius * 2,\n      width: width,\n      height: width,\n      cx: width / 2,\n      cy: width / 2,\n      radius: width / 2 - borderWidth / 2\n    };\n  } else {\n    return {\n      handleStart: sliderSize / 2,\n      handleRange: width - sliderSize,\n      radius: sliderSize / 2,\n      x: 0,\n      y: 0,\n      width: ishorizontal ? sliderSize : width,\n      height: ishorizontal ? width : sliderSize\n    };\n  }\n}\n/**\r\n * @desc Get the current slider value for a given color, as a percentage\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getCurrentSliderValue(props, color) {\n  var hsva = color.hsva;\n  var rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return rgb.r / 2.55;\n\n    case 'green':\n      return rgb.g / 2.55;\n\n    case 'blue':\n      return rgb.b / 2.55;\n\n    case 'alpha':\n      return hsva.a * 100;\n\n    case 'kelvin':\n      var minTemperature = props.minTemperature,\n          maxTemperature = props.maxTemperature;\n      var temperatureRange = maxTemperature - minTemperature;\n      var percent = (color.kelvin - minTemperature) / temperatureRange * 100; // clmap percentage\n\n      return Math.max(0, Math.min(percent, 100));\n\n    case 'hue':\n      return hsva.h /= 3.6;\n\n    case 'saturation':\n      return hsva.s;\n\n    case 'value':\n    default:\n      return hsva.v;\n  }\n}\n/**\r\n * @desc Get the current slider value from user input\r\n * @param props - slider props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getSliderValueFromInput(props, x, y) {\n  var _getSliderDimensions = getSliderDimensions(props),\n      handleRange = _getSliderDimensions.handleRange,\n      handleStart = _getSliderDimensions.handleStart;\n\n  var handlePos;\n\n  if (props.layoutDirection === 'horizontal') {\n    handlePos = -1 * y + handleRange + handleStart;\n  } else {\n    handlePos = x - handleStart;\n  } // clamp handle position\n\n\n  handlePos = Math.max(Math.min(handlePos, handleRange), 0);\n  var percent = Math.round(100 / handleRange * handlePos);\n\n  switch (props.sliderType) {\n    case 'kelvin':\n      var minTemperature = props.minTemperature,\n          maxTemperature = props.maxTemperature;\n      var temperatureRange = maxTemperature - minTemperature;\n      return minTemperature + temperatureRange * (percent / 100);\n\n    case 'alpha':\n      return percent / 100;\n\n    case 'hue':\n      return percent * 3.6;\n\n    case 'red':\n    case 'blue':\n    case 'green':\n      return percent * 2.55;\n\n    default:\n      return percent;\n  }\n}\n/**\r\n * @desc Get the current handle position for a given color\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getSliderHandlePosition(props, color) {\n  var _getSliderDimensions2 = getSliderDimensions(props),\n      width = _getSliderDimensions2.width,\n      height = _getSliderDimensions2.height,\n      handleRange = _getSliderDimensions2.handleRange,\n      handleStart = _getSliderDimensions2.handleStart;\n\n  var ishorizontal = props.layoutDirection === 'horizontal';\n  var sliderValue = getCurrentSliderValue(props, color);\n  var midPoint = ishorizontal ? width / 2 : height / 2;\n  var handlePos = handleStart + sliderValue / 100 * handleRange;\n\n  if (ishorizontal) {\n    handlePos = -1 * handlePos + handleRange + handleStart * 2;\n  }\n\n  return {\n    x: ishorizontal ? midPoint : handlePos,\n    y: ishorizontal ? handlePos : midPoint\n  };\n}\n/**\r\n * @desc Get the gradient stops for a slider\r\n * @param props - slider props\r\n * @param color\r\n */\n\nfunction getSliderGradient(props, color) {\n  var hsv = color.hsv;\n  var rgb = color.rgb;\n\n  switch (props.sliderType) {\n    case 'red':\n      return [[0, \"rgb(\" + 0 + \",\" + rgb.g + \",\" + rgb.b + \")\"], [100, \"rgb(\" + 255 + \",\" + rgb.g + \",\" + rgb.b + \")\"]];\n\n    case 'green':\n      return [[0, \"rgb(\" + rgb.r + \",\" + 0 + \",\" + rgb.b + \")\"], [100, \"rgb(\" + rgb.r + \",\" + 255 + \",\" + rgb.b + \")\"]];\n\n    case 'blue':\n      return [[0, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + 0 + \")\"], [100, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + 255 + \")\"]];\n\n    case 'alpha':\n      return [[0, \"rgba(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \",0)\"], [100, \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\"]];\n\n    case 'kelvin':\n      var stops = [];\n      var min = props.minTemperature;\n      var max = props.maxTemperature;\n      var numStops = 8;\n      var range = max - min;\n\n      for (var kelvin = min, stop = 0; kelvin < max; kelvin += range / numStops, stop += 1) {\n        var _IroColor$kelvinToRgb = IroColor.kelvinToRgb(kelvin),\n            r = _IroColor$kelvinToRgb.r,\n            g = _IroColor$kelvinToRgb.g,\n            b = _IroColor$kelvinToRgb.b;\n\n        stops.push([100 / numStops * stop, \"rgb(\" + r + \",\" + g + \",\" + b + \")\"]);\n      }\n\n      return stops;\n\n    case 'hue':\n      return [[0, '#f00'], [16.666, '#ff0'], [33.333, '#0f0'], [50, '#0ff'], [66.666, '#00f'], [83.333, '#f0f'], [100, '#f00']];\n\n    case 'saturation':\n      var noSat = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: 0,\n        v: hsv.v\n      });\n      var fullSat = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: 100,\n        v: hsv.v\n      });\n      return [[0, \"hsl(\" + noSat.h + \",\" + noSat.s + \"%,\" + noSat.l + \"%)\"], [100, \"hsl(\" + fullSat.h + \",\" + fullSat.s + \"%,\" + fullSat.l + \"%)\"]];\n\n    case 'value':\n    default:\n      var hsl = IroColor.hsvToHsl({\n        h: hsv.h,\n        s: hsv.s,\n        v: 100\n      });\n      return [[0, '#000'], [100, \"hsl(\" + hsl.h + \",\" + hsl.s + \"%,\" + hsl.l + \"%)\"]];\n  }\n}\n\nvar TAU = Math.PI * 2; // javascript's modulo operator doesn't produce positive numbers with negative input\n// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n\nvar mod = function mod(a, n) {\n  return (a % n + n) % n;\n}; // distance between points (x, y) and (0, 0)\n\n\nvar dist = function dist(x, y) {\n  return Math.sqrt(x * x + y * y);\n};\n/**\r\n * @param props - wheel props\r\n * @internal\r\n */\n\n\nfunction getHandleRange(props) {\n  return props.width / 2 - props.padding - props.handleRadius - props.borderWidth;\n}\n/**\r\n * Returns true if point (x, y) lands inside the wheel\r\n * @param props - wheel props\r\n * @param x\r\n * @param y\r\n */\n\n\nfunction isInputInsideWheel(props, x, y) {\n  var _getWheelDimensions = getWheelDimensions(props),\n      cx = _getWheelDimensions.cx,\n      cy = _getWheelDimensions.cy;\n\n  var r = props.width / 2;\n  return dist(cx - x, cy - y) < r;\n}\n/**\r\n * @desc Get the point as the center of the wheel\r\n * @param props - wheel props\r\n */\n\nfunction getWheelDimensions(props) {\n  var r = props.width / 2;\n  return {\n    width: props.width,\n    radius: r - props.borderWidth,\n    cx: r,\n    cy: r\n  };\n}\n/**\r\n * @desc Translate an angle according to wheelAngle and wheelDirection\r\n * @param props - wheel props\r\n * @param angle - input angle\r\n */\n\nfunction translateWheelAngle(props, angle, invert) {\n  var wheelAngle = props.wheelAngle;\n  var wheelDirection = props.wheelDirection; // inverted and clockwisee\n\n  if (invert && wheelDirection === 'clockwise') { angle = wheelAngle + angle; } // clockwise (input handling)\n  else if (wheelDirection === 'clockwise') { angle = 360 - wheelAngle + angle; } // inverted and anticlockwise\n    else if (invert && wheelDirection === 'anticlockwise') { angle = wheelAngle + 180 - angle; } // anticlockwise (input handling)\n      else if (wheelDirection === 'anticlockwise') { angle = wheelAngle - angle; }\n  return mod(angle, 360);\n}\n/**\r\n * @desc Get the current handle position for a given color\r\n * @param props - wheel props\r\n * @param color\r\n */\n\nfunction getWheelHandlePosition(props, color) {\n  var hsv = color.hsv;\n\n  var _getWheelDimensions2 = getWheelDimensions(props),\n      cx = _getWheelDimensions2.cx,\n      cy = _getWheelDimensions2.cy;\n\n  var handleRange = getHandleRange(props);\n  var handleAngle = (180 + translateWheelAngle(props, hsv.h, true)) * (TAU / 360);\n  var handleDist = hsv.s / 100 * handleRange;\n  var direction = props.wheelDirection === 'clockwise' ? -1 : 1;\n  return {\n    x: cx + handleDist * Math.cos(handleAngle) * direction,\n    y: cy + handleDist * Math.sin(handleAngle) * direction\n  };\n}\n/**\r\n * @desc Get the current wheel value from user input\r\n * @param props - wheel props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getWheelValueFromInput(props, x, y) {\n  var _getWheelDimensions3 = getWheelDimensions(props),\n      cx = _getWheelDimensions3.cx,\n      cy = _getWheelDimensions3.cy;\n\n  var handleRange = getHandleRange(props);\n  x = cx - x;\n  y = cy - y; // Calculate the hue by converting the angle to radians\n\n  var hue = translateWheelAngle(props, Math.atan2(-y, -x) * (360 / TAU)); // Find the point's distance from the center of the wheel\n  // This is used to show the saturation level\n\n  var handleDist = Math.min(dist(x, y), handleRange);\n  return {\n    h: Math.round(hue),\n    s: Math.round(100 / handleRange * handleDist)\n  };\n}\n/**\r\n * @desc Get the bounding dimensions of the box\r\n * @param props - box props\r\n */\n\nfunction getBoxDimensions(props) {\n  var width = props.width,\n      boxHeight = props.boxHeight,\n      padding = props.padding,\n      handleRadius = props.handleRadius;\n  return {\n    width: width,\n    height: boxHeight != null ? boxHeight : width,\n    radius: padding + handleRadius\n  };\n}\n/**\r\n * @desc Get the current box value from user input\r\n * @param props - box props\r\n * @param x - global input x position\r\n * @param y - global input y position\r\n */\n\nfunction getBoxValueFromInput(props, x, y) {\n  var _getBoxDimensions = getBoxDimensions(props),\n      width = _getBoxDimensions.width,\n      height = _getBoxDimensions.height,\n      radius = _getBoxDimensions.radius;\n\n  var handleStart = radius;\n  var handleRangeX = width - radius * 2;\n  var handleRangeY = height - radius * 2;\n  var percentX = (x - handleStart) / handleRangeX * 100;\n  var percentY = (y - handleStart) / handleRangeY * 100;\n  return {\n    s: Math.max(0, Math.min(percentX, 100)),\n    v: Math.max(0, Math.min(100 - percentY, 100))\n  };\n}\n/**\r\n * @desc Get the current box handle position for a given color\r\n * @param props - box props\r\n * @param color\r\n */\n\nfunction getBoxHandlePosition(props, color) {\n  var _getBoxDimensions2 = getBoxDimensions(props),\n      width = _getBoxDimensions2.width,\n      height = _getBoxDimensions2.height,\n      radius = _getBoxDimensions2.radius;\n\n  var hsv = color.hsv;\n  var handleStart = radius;\n  var handleRangeX = width - radius * 2;\n  var handleRangeY = height - radius * 2;\n  return {\n    x: handleStart + hsv.s / 100 * handleRangeX,\n    y: handleStart + (handleRangeY - hsv.v / 100 * handleRangeY)\n  };\n}\n/**\r\n * @desc Get the gradient stops for a box\r\n * @param props - box props\r\n * @param color\r\n */\n\nfunction getBoxGradients(props, color) {\n  var hue = color.hue;\n  return [// saturation gradient\n  [[0, '#fff'], [100, \"hsl(\" + hue + \",100%,50%)\"]], // lightness gradient\n  [[0, 'rgba(0,0,0,0)'], [100, '#000']]];\n}\n\n// Keep track of html <base> elements for resolveSvgUrl\n// getElementsByTagName returns a live HTMLCollection, which stays in sync with the DOM tree\n// So it only needs to be called once\nvar BASE_ELEMENTS;\n/**\r\n * @desc Resolve an SVG reference URL\r\n * This is required to work around how Safari and iOS webviews handle gradient URLS under certain conditions\r\n * If a page is using a client-side routing library which makes use of the HTML <base> tag,\r\n * Safari won't be able to render SVG gradients properly (as they are referenced by URLs)\r\n * More info on the problem:\r\n * https://stackoverflow.com/questions/19742805/angular-and-svg-filters/19753427#19753427\r\n * https://github.com/jaames/iro.js/issues/18\r\n * https://github.com/jaames/iro.js/issues/45\r\n * https://github.com/jaames/iro.js/pull/89\r\n * @props url - SVG reference URL\r\n */\n\nfunction resolveSvgUrl(url) {\n  if (!BASE_ELEMENTS) { BASE_ELEMENTS = document.getElementsByTagName('base'); } // Sniff useragent string to check if the user is running Safari\n\n  var ua = window.navigator.userAgent;\n  var isSafari = /^((?!chrome|android).)*safari/i.test(ua);\n  var isIos = /iPhone|iPod|iPad/i.test(ua);\n  var location = window.location;\n  return (isSafari || isIos) && BASE_ELEMENTS.length > 0 ? location.protocol + \"//\" + location.host + location.pathname + location.search + url : url;\n}\n/**\r\n * @desc Given a specifc (x, y) position, test if there's a handle there and return its index, else return null.\r\n *       This is used for components like the box and wheel which support multiple handles when multicolor is active\r\n * @props x - point x position\r\n * @props y - point y position\r\n * @props handlePositions - array of {x, y} coords for each handle\r\n */\n\nfunction getHandleAtPoint(props, x, y, handlePositions) {\n  for (var i = 0; i < handlePositions.length; i++) {\n    var dX = handlePositions[i].x - x;\n    var dY = handlePositions[i].y - y;\n    var dist = Math.sqrt(dX * dX + dY * dY);\n\n    if (dist < props.handleRadius) {\n      return i;\n    }\n  }\n\n  return null;\n}\n\nfunction cssBorderStyles(props) {\n  return {\n    boxSizing: 'border-box',\n    border: props.borderWidth + \"px solid \" + props.borderColor\n  };\n}\nfunction cssGradient(type, direction, stops) {\n  return type + \"-gradient(\" + direction + \", \" + stops.map(function (_ref) {\n    var o = _ref[0],\n        col = _ref[1];\n    return col + \" \" + o + \"%\";\n  }).join(',') + \")\";\n}\nfunction cssValue(value) {\n  if (typeof value === 'string') { return value; }\n  return value + \"px\";\n}\n\nvar iroColorPickerOptionDefaults = {\n  width: 300,\n  height: 300,\n  color: '#fff',\n  colors: [],\n  padding: 6,\n  layoutDirection: 'vertical',\n  borderColor: '#fff',\n  borderWidth: 0,\n  handleRadius: 8,\n  activeHandleRadius: null,\n  handleSvg: null,\n  handleProps: {\n    x: 0,\n    y: 0\n  },\n  wheelLightness: true,\n  wheelAngle: 0,\n  wheelDirection: 'anticlockwise',\n  sliderSize: null,\n  sliderMargin: 12,\n  boxHeight: null\n};\n\nvar SECONDARY_EVENTS = [\"mousemove\" /* MouseMove */, \"touchmove\" /* TouchMove */, \"mouseup\" /* MouseUp */, \"touchend\" /* TouchEnd */];\r\n// Base component class for iro UI components\r\n// This extends the Preact component class to allow them to react to mouse/touch input events by themselves\r\nvar IroComponentWrapper = /*@__PURE__*/(function (Component) {\n    function IroComponentWrapper(props) {\r\n        Component.call(this, props);\r\n        // Generate unique ID for the component\r\n        // This can be used to generate unique IDs for gradients, etc\r\n        this.uid = (Math.random() + 1).toString(36).substring(5);\r\n    }\n\n    if ( Component ) IroComponentWrapper.__proto__ = Component;\n    IroComponentWrapper.prototype = Object.create( Component && Component.prototype );\n    IroComponentWrapper.prototype.constructor = IroComponentWrapper;\r\n    IroComponentWrapper.prototype.render = function render (props) {\r\n        var eventHandler = this.handleEvent.bind(this);\r\n        var rootProps = {\r\n            onMouseDown: eventHandler,\r\n            // https://github.com/jaames/iro.js/issues/126\r\n            // https://github.com/preactjs/preact/issues/2113#issuecomment-553408767\r\n            ontouchstart: eventHandler,\r\n        };\r\n        var isHorizontal = props.layoutDirection === 'horizontal';\r\n        var margin = props.margin === null ? props.sliderMargin : props.margin;\r\n        var rootStyles = {\r\n            overflow: 'visible',\r\n            display: isHorizontal ? 'inline-block' : 'block'\r\n        };\r\n        // first component shouldn't have any margin\r\n        if (props.index > 0) {\r\n            rootStyles[isHorizontal ? 'marginLeft' : 'marginTop'] = margin;\r\n        }\r\n        return (h(d, null, props.children(this.uid, rootProps, rootStyles)));\r\n    };\r\n    // More info on handleEvent:\r\n    // https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\r\n    // TL;DR this lets us have a single point of entry for multiple events, and we can avoid callback/binding hell\r\n    IroComponentWrapper.prototype.handleEvent = function handleEvent (e) {\n        var this$1 = this;\n\r\n        var inputHandler = this.props.onInput;\r\n        // Get the screen position of the component\r\n        var bounds = this.base.getBoundingClientRect();\r\n        // Prefect default browser action\r\n        e.preventDefault();\r\n        // Detect if the event is a touch event by checking if it has the `touches` property\r\n        // If it is a touch event, use the first touch input\r\n        var point = e.touches ? e.changedTouches[0] : e;\r\n        var x = point.clientX - bounds.left;\r\n        var y = point.clientY - bounds.top;\r\n        switch (e.type) {\r\n            case \"mousedown\" /* MouseDown */:\r\n            case \"touchstart\" /* TouchStart */:\r\n                var result = inputHandler(x, y, 0 /* Start */);\r\n                if (result !== false) {\r\n                    SECONDARY_EVENTS.forEach(function (event) {\r\n                        document.addEventListener(event, this$1, { passive: false });\r\n                    });\r\n                }\r\n                break;\r\n            case \"mousemove\" /* MouseMove */:\r\n            case \"touchmove\" /* TouchMove */:\r\n                inputHandler(x, y, 1 /* Move */);\r\n                break;\r\n            case \"mouseup\" /* MouseUp */:\r\n            case \"touchend\" /* TouchEnd */:\r\n                inputHandler(x, y, 2 /* End */);\r\n                SECONDARY_EVENTS.forEach(function (event) {\r\n                    document.removeEventListener(event, this$1, { passive: false });\r\n                });\r\n                break;\r\n        }\r\n    };\n\n    return IroComponentWrapper;\n}(m));\n\nfunction IroHandle(props) {\r\n    var radius = props.r;\r\n    var url = props.url;\r\n    return (h(\"svg\", { className: (\"IroHandle IroHandle--\" + (props.index) + \" \" + (props.isActive ? 'IroHandle--isActive' : '')), style: {\r\n            top: cssValue(props.y),\r\n            left: cssValue(props.x),\r\n            width: '1px',\r\n            height: '1px',\r\n            position: 'absolute',\r\n            overflow: 'visible'\r\n        } },\r\n        url && (h(\"use\", Object.assign({ xlinkHref: resolveSvgUrl(url) }, props.props))),\r\n        !url && (h(\"circle\", { r: radius, fill: \"none\", \"stroke-width\": 2, stroke: \"#000\" })),\r\n        !url && (h(\"circle\", { r: radius - 2, fill: props.fill, \"stroke-width\": 2, stroke: \"#fff\" }))));\r\n}\r\nIroHandle.defaultProps = {\r\n    fill: 'none',\r\n    x: 0,\r\n    y: 0,\r\n    r: 8,\r\n    url: null,\r\n    props: { x: 0, y: 0 }\r\n};\n\nfunction IroSlider(props) {\r\n    var activeIndex = props.activeIndex;\r\n    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;\r\n    var ref = getSliderDimensions(props);\n    var width = ref.width;\n    var height = ref.height;\n    var radius = ref.radius;\r\n    var handlePos = getSliderHandlePosition(props, activeColor);\r\n    var gradient = getSliderGradient(props, activeColor);\r\n    function handleInput(x, y, type) {\r\n        var value = getSliderValueFromInput(props, x, y);\r\n        props.parent.inputActive = true;\r\n        activeColor[props.sliderType] = value;\r\n        props.onInput(type, props.id);\r\n    }\r\n    return (h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"div\", Object.assign({}, rootProps, { className: \"IroSlider\", style: Object.assign({}, {position: 'relative',\r\n            width: cssValue(width),\r\n            height: cssValue(height),\r\n            borderRadius: cssValue(radius),\r\n            // checkered bg to represent alpha\r\n            background: \"conic-gradient(#ccc 25%, #fff 0 50%, #ccc 0 75%, #fff 0)\",\r\n            backgroundSize: '8px 8px'},\r\n            rootStyles) }),\r\n        h(\"div\", { className: \"IroSliderGradient\", style: Object.assign({}, {position: 'absolute',\r\n                top: 0,\r\n                left: 0,\r\n                width: \"100%\",\r\n                height: \"100%\",\r\n                borderRadius: cssValue(radius),\r\n                background: cssGradient('linear', props.layoutDirection === 'horizontal' ? 'to top' : 'to right', gradient)},\r\n                cssBorderStyles(props)) }),\r\n        h(IroHandle, { isActive: true, index: activeColor.index, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePos.x, y: handlePos.y }))); }));\r\n}\r\nIroSlider.defaultProps = Object.assign({}, sliderDefaultOptions);\n\nfunction IroBox(props) {\r\n    var ref = getBoxDimensions(props);\n    var width = ref.width;\n    var height = ref.height;\n    var radius = ref.radius;\r\n    var colors = props.colors;\r\n    var colorPicker = props.parent;\r\n    var activeIndex = props.activeIndex;\r\n    var activeColor = (activeIndex !== undefined && activeIndex < props.colors.length) ? props.colors[activeIndex] : props.color;\r\n    var gradients = getBoxGradients(props, activeColor);\r\n    var handlePositions = colors.map(function (color) { return getBoxHandlePosition(props, color); });\r\n    function handleInput(x, y, inputType) {\r\n        if (inputType === 0 /* Start */) {\r\n            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise\r\n            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\r\n            // If the input hit a handle, set it as the active handle, but don't update the color\r\n            if (activeHandle !== null) {\r\n                colorPicker.setActiveColor(activeHandle);\r\n            }\r\n            // If the input didn't hit a handle, set the currently active handle to that position\r\n            else {\r\n                colorPicker.inputActive = true;\r\n                activeColor.hsv = getBoxValueFromInput(props, x, y);\r\n                props.onInput(inputType, props.id);\r\n            }\r\n        }\r\n        // move is fired when the user has started dragging\r\n        else if (inputType === 1 /* Move */) {\r\n            colorPicker.inputActive = true;\r\n            activeColor.hsv = getBoxValueFromInput(props, x, y);\r\n        }\r\n        // let the color picker fire input:start, input:move or input:end events\r\n        props.onInput(inputType, props.id);\r\n    }\r\n    return (h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"div\", Object.assign({}, rootProps, { className: \"IroBox\", style: Object.assign({}, {width: cssValue(width),\r\n            height: cssValue(height),\r\n            position: 'relative'},\r\n            rootStyles) }),\r\n        h(\"div\", { className: \"IroBox\", style: Object.assign({}, {width: '100%',\r\n                height: '100%',\r\n                borderRadius: cssValue(radius)},\r\n                cssBorderStyles(props),\r\n                {background: cssGradient('linear', 'to bottom', gradients[1])\r\n                    + ',' +\r\n                    cssGradient('linear', 'to right', gradients[0])}) }),\r\n        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),\r\n        h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));\r\n}\n\nvar HUE_GRADIENT_CLOCKWISE = 'conic-gradient(red, yellow, lime, aqua, blue, magenta, red)';\r\nvar HUE_GRADIENT_ANTICLOCKWISE = 'conic-gradient(red, magenta, blue, aqua, lime, yellow, red)';\r\nfunction IroWheel(props) {\r\n    var ref = getWheelDimensions(props);\n    var width = ref.width;\n    var colors = props.colors;\n    var borderWidth = props.borderWidth;\r\n    var colorPicker = props.parent;\r\n    var activeColor = props.color;\r\n    var hsv = activeColor.hsv;\r\n    var handlePositions = colors.map(function (color) { return getWheelHandlePosition(props, color); });\r\n    var circleStyles = {\r\n        position: 'absolute',\r\n        top: 0,\r\n        left: 0,\r\n        width: '100%',\r\n        height: '100%',\r\n        borderRadius: '50%',\r\n        boxSizing: 'border-box'\r\n    };\r\n    function handleInput(x, y, inputType) {\r\n        if (inputType === 0 /* Start */) {\r\n            // input hitbox is a square, \r\n            // so we want to ignore any initial clicks outside the circular shape of the wheel\r\n            if (!isInputInsideWheel(props, x, y)) {\r\n                // returning false will cease all event handling for this interaction\r\n                return false;\r\n            }\r\n            // getHandleAtPoint() returns the index for the handle if the point 'hits' it, or null otherwise\r\n            var activeHandle = getHandleAtPoint(props, x, y, handlePositions);\r\n            // If the input hit a handle, set it as the active handle, but don't update the color\r\n            if (activeHandle !== null) {\r\n                colorPicker.setActiveColor(activeHandle);\r\n            }\r\n            // If the input didn't hit a handle, set the currently active handle to that position\r\n            else {\r\n                colorPicker.inputActive = true;\r\n                activeColor.hsv = getWheelValueFromInput(props, x, y);\r\n                props.onInput(inputType, props.id);\r\n            }\r\n        }\r\n        // move is fired when the user has started dragging\r\n        else if (inputType === 1 /* Move */) {\r\n            colorPicker.inputActive = true;\r\n            activeColor.hsv = getWheelValueFromInput(props, x, y);\r\n        }\r\n        // let the color picker fire input:start, input:move or input:end events\r\n        props.onInput(inputType, props.id);\r\n    }\r\n    return (h(IroComponentWrapper, Object.assign({}, props, { onInput: handleInput }), function (uid, rootProps, rootStyles) { return (h(\"div\", Object.assign({}, rootProps, { className: \"IroWheel\", style: Object.assign({}, {width: cssValue(width),\r\n            height: cssValue(width),\r\n            position: 'relative'},\r\n            rootStyles) }),\r\n        h(\"div\", { className: \"IroWheelHue\", style: Object.assign({}, circleStyles,\r\n                {transform: (\"rotateZ(\" + (props.wheelAngle + 90) + \"deg)\"),\r\n                background: props.wheelDirection === 'clockwise' ? HUE_GRADIENT_CLOCKWISE : HUE_GRADIENT_ANTICLOCKWISE}) }),\r\n        h(\"div\", { className: \"IroWheelSaturation\", style: Object.assign({}, circleStyles,\r\n                {background: 'radial-gradient(circle closest-side, #fff, transparent)'}) }),\r\n        props.wheelLightness && (h(\"div\", { className: \"IroWheelLightness\", style: Object.assign({}, circleStyles,\r\n                {background: '#000',\r\n                opacity: 1 - hsv.v / 100}) })),\r\n        h(\"div\", { className: \"IroWheelBorder\", style: Object.assign({}, circleStyles,\r\n                cssBorderStyles(props)) }),\r\n        colors.filter(function (color) { return color !== activeColor; }).map(function (color) { return (h(IroHandle, { isActive: false, index: color.index, fill: color.hslString, r: props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[color.index].x, y: handlePositions[color.index].y })); }),\r\n        h(IroHandle, { isActive: true, index: activeColor.index, fill: activeColor.hslString, r: props.activeHandleRadius || props.handleRadius, url: props.handleSvg, props: props.handleProps, x: handlePositions[activeColor.index].x, y: handlePositions[activeColor.index].y }))); }));\r\n}\n\nfunction createWidget(WidgetComponent) {\r\n    var widgetFactory = function (parent, props) {\r\n        var widget; // will become an instance of the widget component class\r\n        var widgetRoot = document.createElement('div');\r\n        // Render widget into a temp DOM node\r\n        I(h(WidgetComponent, Object.assign({}, {ref: function (ref) { return widget = ref; }},\r\n            props)), widgetRoot);\r\n        function mountWidget() {\r\n            var container = parent instanceof Element ? parent : document.querySelector(parent);\r\n            container.appendChild(widget.base);\r\n            widget.onMount(container);\r\n        }\r\n        // Mount it into the DOM when the page document is ready\r\n        if (document.readyState !== 'loading') {\r\n            mountWidget();\r\n        }\r\n        else {\r\n            document.addEventListener('DOMContentLoaded', mountWidget);\r\n        }\r\n        return widget;\r\n    };\r\n    // Allow the widget factory to inherit component prototype + static class methods\r\n    // This makes it easier for plugin authors to extend the base widget component\r\n    widgetFactory.prototype = WidgetComponent.prototype;\r\n    Object.assign(widgetFactory, WidgetComponent);\r\n    // Add reference to base component too\r\n    widgetFactory.__component = WidgetComponent;\r\n    return widgetFactory;\r\n}\n\nvar IroColorPicker = /*@__PURE__*/(function (Component) {\n    function IroColorPicker(props) {\n        var this$1 = this;\n\r\n        Component.call(this, props);\r\n        this.colors = [];\r\n        this.inputActive = false;\r\n        this.events = {};\r\n        this.activeEvents = {};\r\n        this.deferredEvents = {};\r\n        this.id = props.id;\r\n        var colors = props.colors.length > 0 ? props.colors : [props.color];\r\n        colors.forEach(function (colorValue) { return this$1.addColor(colorValue); });\r\n        this.setActiveColor(0);\r\n        // Pass all the props into the component's state,\r\n        // Except we want to add the color object and make sure that refs aren't passed down to children\r\n        this.state = Object.assign({}, props,\r\n            {color: this.color,\r\n            colors: this.colors,\r\n            layout: props.layout});\r\n    }\n\n    if ( Component ) IroColorPicker.__proto__ = Component;\n    IroColorPicker.prototype = Object.create( Component && Component.prototype );\n    IroColorPicker.prototype.constructor = IroColorPicker;\r\n    // Plubic multicolor API\r\n    /**\r\n    * @desc Add a color to the color picker\r\n    * @param color new color to add\r\n    * @param index optional color index\r\n    */\r\n    IroColorPicker.prototype.addColor = function addColor (color, index) {\n        if ( index === void 0 ) index = this.colors.length;\n\r\n        // Create a new iro.Color\r\n        // Also bind it to onColorChange, so whenever the color changes it updates the color picker\r\n        var newColor = new IroColor(color, this.onColorChange.bind(this));\r\n        // Insert color @ the given index\r\n        this.colors.splice(index, 0, newColor);\r\n        // Reindex colors\r\n        this.colors.forEach(function (color, index) { return color.index = index; });\r\n        // Update picker state if necessary\r\n        if (this.state) {\r\n            this.setState({ colors: this.colors });\r\n        }\r\n        // Fire color init event\r\n        this.deferredEmit('color:init', newColor);\r\n    };\r\n    /**\r\n     * @desc Remove a color from the color picker\r\n     * @param index color index\r\n     */\r\n    IroColorPicker.prototype.removeColor = function removeColor (index) {\r\n        var color = this.colors.splice(index, 1)[0];\r\n        // Destroy the color object -- this unbinds it from the color picker\r\n        color.unbind();\r\n        // Reindex colors\r\n        this.colors.forEach(function (color, index) { return color.index = index; });\r\n        // Update picker state if necessary\r\n        if (this.state) {\r\n            this.setState({ colors: this.colors });\r\n        }\r\n        // If the active color was removed, default active color to 0\r\n        if (color.index === this.color.index) {\r\n            this.setActiveColor(0);\r\n        }\r\n        // Fire color remove event\r\n        this.emit('color:remove', color);\r\n    };\r\n    /**\r\n     * @desc Set the currently active color\r\n     * @param index color index\r\n     */\r\n    IroColorPicker.prototype.setActiveColor = function setActiveColor (index) {\r\n        this.color = this.colors[index];\r\n        if (this.state) {\r\n            this.setState({ color: this.color });\r\n        }\r\n        // Fire color switch event\r\n        this.emit('color:setActive', this.color);\r\n    };\r\n    /**\r\n     * @desc Replace all of the current colorPicker colors\r\n     * @param newColorValues list of new colors to add\r\n     */\r\n    IroColorPicker.prototype.setColors = function setColors (newColorValues, activeColorIndex) {\n        var this$1 = this;\n        if ( activeColorIndex === void 0 ) activeColorIndex = 0;\n\r\n        // Unbind color events\r\n        this.colors.forEach(function (color) { return color.unbind(); });\r\n        // Destroy old colors\r\n        this.colors = [];\r\n        // Add new colors\r\n        newColorValues.forEach(function (colorValue) { return this$1.addColor(colorValue); });\r\n        // Reset active color\r\n        this.setActiveColor(activeColorIndex);\r\n        this.emit('color:setAll', this.colors);\r\n    };\r\n    // Public ColorPicker events API\r\n    /**\r\n     * @desc Set a callback function for an event\r\n     * @param eventList event(s) to listen to\r\n     * @param callback - Function called when the event is fired\r\n     */\r\n    IroColorPicker.prototype.on = function on (eventList, callback) {\n        var this$1 = this;\n\r\n        var events = this.events;\r\n        // eventList can be an eventType string or an array of eventType strings\r\n        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\r\n            // Add event callback\r\n            (events[eventType] || (events[eventType] = [])).push(callback);\r\n            // Call deferred events\r\n            // These are events that can be stored until a listener for them is added\r\n            if (this$1.deferredEvents[eventType]) {\r\n                // Deffered events store an array of arguments from when the event was called\r\n                this$1.deferredEvents[eventType].forEach(function (args) {\r\n                    callback.apply(null, args);\r\n                });\r\n                // Clear deferred events\r\n                this$1.deferredEvents[eventType] = [];\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * @desc Remove a callback function for an event added with on()\r\n     * @param eventList - event(s) to listen to\r\n     * @param callback - original callback function to remove\r\n     */\r\n    IroColorPicker.prototype.off = function off (eventList, callback) {\n        var this$1 = this;\n\r\n        (!Array.isArray(eventList) ? [eventList] : eventList).forEach(function (eventType) {\r\n            var callbackList = this$1.events[eventType];\r\n            // this.emitHook('event:off', eventType, callback);\r\n            if (callbackList)\r\n                { callbackList.splice(callbackList.indexOf(callback), 1); }\r\n        });\r\n    };\r\n    /**\r\n     * @desc Emit an event\r\n     * @param eventType event to emit\r\n     */\r\n    IroColorPicker.prototype.emit = function emit (eventType) {\n        var this$1 = this;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\r\n        var activeEvents = this.activeEvents;\r\n        var isEventActive = activeEvents.hasOwnProperty(eventType) ? activeEvents[eventType] : false;\r\n        // Prevent event callbacks from firing if the event is already active\r\n        // This stops infinite loops if something in an event callback causes the same event to be fired again\r\n        // (e.g. setting the color inside a color:change callback)\r\n        if (!isEventActive) {\r\n            activeEvents[eventType] = true;\r\n            var callbackList = this.events[eventType] || [];\r\n            callbackList.forEach(function (fn) { return fn.apply(this$1, args); });\r\n            activeEvents[eventType] = false;\r\n        }\r\n    };\r\n    /**\r\n     * @desc Emit an event now, or save it for when the relevent event listener is added\r\n     * @param eventType - The name of the event to emit\r\n     */\r\n    IroColorPicker.prototype.deferredEmit = function deferredEmit (eventType) {\n        var ref;\n\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\r\n        var deferredEvents = this.deferredEvents;\r\n        (ref = this).emit.apply(ref, [ eventType ].concat( args ));\r\n        (deferredEvents[eventType] || (deferredEvents[eventType] = [])).push(args);\r\n    };\r\n    // Public utility methods\r\n    IroColorPicker.prototype.setOptions = function setOptions (newOptions) {\r\n        this.setState(newOptions);\r\n    };\r\n    /**\r\n     * @desc Resize the color picker\r\n     * @param width - new width\r\n     */\r\n    IroColorPicker.prototype.resize = function resize (width) {\r\n        this.setOptions({ width: width });\r\n    };\r\n    /**\r\n     * @desc Reset the color picker to the initial color provided in the color picker options\r\n     */\r\n    IroColorPicker.prototype.reset = function reset () {\r\n        this.colors.forEach(function (color) { return color.reset(); });\r\n        this.setState({ colors: this.colors });\r\n    };\r\n    /**\r\n     * @desc Called by the createWidget wrapper when the element is mounted into the page\r\n     * @param container - the container element for this ColorPicker instance\r\n     */\r\n    IroColorPicker.prototype.onMount = function onMount (container) {\r\n        this.el = container;\r\n        this.deferredEmit('mount', this);\r\n    };\r\n    // Internal methods\r\n    /**\r\n     * @desc React to a color update\r\n     * @param color - current color\r\n     * @param changes - shows which h,s,v,a color channels changed\r\n     */\r\n    IroColorPicker.prototype.onColorChange = function onColorChange (color, changes) {\r\n        this.setState({ color: this.color });\r\n        if (this.inputActive) {\r\n            this.inputActive = false;\r\n            this.emit('input:change', color, changes);\r\n        }\r\n        this.emit('color:change', color, changes);\r\n    };\r\n    /**\r\n     * @desc Handle input from a UI control element\r\n     * @param type - event type\r\n     */\r\n    IroColorPicker.prototype.emitInputEvent = function emitInputEvent (type, originId) {\r\n        if (type === 0 /* Start */) {\r\n            this.emit('input:start', this.color, originId);\r\n        }\r\n        else if (type === 1 /* Move */) {\r\n            this.emit('input:move', this.color, originId);\r\n        }\r\n        else if (type === 2 /* End */) {\r\n            this.emit('input:end', this.color, originId);\r\n        }\r\n    };\r\n    IroColorPicker.prototype.render = function render (props, state) {\n        var this$1 = this;\n\r\n        var layout = state.layout;\r\n        // use layout shorthands\r\n        if (!Array.isArray(layout)) {\r\n            switch (layout) {\r\n                // TODO: implement some?\r\n                default:\r\n                    layout = [\r\n                        { component: IroWheel },\r\n                        { component: IroSlider } ];\r\n            }\r\n            // add transparency slider to the layout\r\n            if (state.transparency) {\r\n                layout.push({\r\n                    component: IroSlider,\r\n                    options: {\r\n                        sliderType: 'alpha'\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return (h(\"div\", { class: \"IroColorPicker\", id: state.id, style: {\r\n                display: state.display\r\n            } }, layout.map(function (ref, componentIndex) {\n                var UiComponent = ref.component;\n                var options = ref.options;\n\n                return (h(UiComponent, Object.assign({}, state, options, { ref: undefined, onInput: this$1.emitInputEvent.bind(this$1), parent: this$1, index: componentIndex })));\n        })));\r\n    };\n\n    return IroColorPicker;\n}(m));\r\nIroColorPicker.defaultProps = Object.assign({}, iroColorPickerOptionDefaults,\r\n    {colors: [],\r\n    display: 'block',\r\n    id: null,\r\n    layout: 'default',\r\n    margin: null});\r\nvar IroColorPickerWidget = createWidget(IroColorPicker);\n\nvar iro;\r\n(function (iro) {\r\n    iro.version = \"5.5.0\"; // replaced by @rollup/plugin-replace; see rollup.config.js\r\n    iro.Color = IroColor;\r\n    iro.ColorPicker = IroColorPickerWidget;\r\n    var ui;\r\n    (function (ui) {\r\n        ui.h = h;\r\n        ui.ComponentBase = IroComponentWrapper;\r\n        ui.Handle = IroHandle;\r\n        ui.Slider = IroSlider;\r\n        ui.Wheel = IroWheel;\r\n        ui.Box = IroBox;\r\n    })(ui = iro.ui || (iro.ui = {}));\r\n})(iro || (iro = {}));\r\nvar iro$1 = iro;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (iro$1);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGphYW1lcy9pcm8vZGlzdC9pcm8uZXMuanM/YTkwMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiwwRUFBMEUsZ0JBQWdCLGdCQUFnQixXQUFXLEVBQUUsU0FBUyxjQUFjLG1CQUFtQixxQkFBcUIsa0JBQWtCLHdCQUF3QixTQUFTLHdCQUF3QixlQUFlLG1CQUFtQixLQUFLLGNBQWMsRUFBRSxFQUFFLDBEQUEwRCwwQkFBMEIseUNBQXlDLEVBQUUsRUFBRSw4RUFBOEUsb0JBQW9CLE9BQU8sZ0dBQWdHLDZCQUE2QixjQUFjLGtCQUFrQixjQUFjLGlDQUFpQyxhQUFhLEVBQUUsMkNBQTJDLDRCQUE0QixFQUFFLDZCQUE2QixtQ0FBbUMscUJBQXFCLFNBQVMsZ0JBQWdCLDZCQUE2QixnQkFBZ0IsWUFBWSxtREFBbUQsRUFBRSxVQUFVLGVBQWUsS0FBSyxxQ0FBcUMsY0FBYyxFQUFFLEVBQUUsMkNBQTJDLGNBQWMsUUFBUSxpQ0FBaUMsOEJBQThCLGVBQWUsS0FBSyxxQ0FBcUMsdUJBQXVCLE1BQU0sRUFBRSxhQUFhLGNBQWMsbUhBQW1ILGFBQWEsb0JBQW9CLHlCQUF5QiwyQkFBMkIsRUFBRSxVQUFVLEVBQUUseUZBQXlGLGtGQUFrRixHQUFHLDhCQUE4QiwyQ0FBMkMsc0VBQXNFLFlBQVksNEVBQTRFLGFBQWEsRUFBRSxNQUFNLFNBQVMsSUFBSSxLQUFLLDRDQUE0QyxZQUFZLE1BQU0sUUFBUSxFQUFFLGlHQUFpRyw2QkFBNkIsZ0JBQWdCLEVBQUUsd0NBQXdDLGdDQUFnQyxrQkFBa0IsRUFBRSxLQUFLLFlBQVksdUJBQXVCLE1BQU0sVUFBVSxTQUFTLEVBQUUsRUFBRSxxQkFBcUIsZ0NBQWdDLHFEQUFxRCxhQUFhLDhDQUE4QyxnQkFBZ0IsSUFBSSxFQUFFLHFCQUFxQixFQUFFLEVBQUUsUUFBUSxJQUFJLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxTQUFTLFdBQVcsS0FBSyx1QkFBdUIsRUFBRSxHQUFHLGtCQUFrQixpREFBaUQsb0JBQW9CLEVBQUUsMEJBQTBCLGFBQWEsV0FBVyxLQUFLLGFBQWEsRUFBRSxFQUFFLE1BQU0scUJBQXFCLEVBQUUsU0FBUyxzQkFBc0IsTUFBTSxZQUFZLDRCQUE0QixFQUFFLFlBQVkseUZBQXlGLEdBQUcsa0JBQWtCLDJGQUEyRixzQkFBc0IsY0FBYyxzRkFBc0YscUJBQXFCLGtDQUFrQyxhQUFhLEVBQUUsS0FBSyxnREFBZ0QsYUFBYSxzQkFBc0IsRUFBRSxFQUFFLE1BQU0sYUFBYSw2QkFBNkIsRUFBRSxHQUFHLEVBQUUsS0FBSyxtSkFBbUosbVpBQW1aLEdBQUcsY0FBYyw0Q0FBNEMsZ0NBQWdDLGlDQUFpQywyQkFBMkIsYUFBYSxFQUFFLGdCQUFnQixJQUFJLDJCQUEyQiwyUEFBMlAscUlBQXFJLHNEQUFzRCwySEFBMkgsRUFBRSxLQUFLLDhMQUE4TCxrR0FBa0csZUFBZSxLQUFLLDRCQUE0QixFQUFFLFFBQVEsK0RBQStELHlPQUF5TyxtSUFBbUksY0FBYyxFQUFFLGtDQUFrQyxFQUFFLDJGQUEyRixNQUFNLDhCQUE4QixFQUFFLG9CQUFvQixTQUFTLGNBQWMsYUFBYSxnQkFBZ0IsVUFBVSxVQUFVLEVBQUUsS0FBSyx1QkFBdUIsU0FBUyxnQkFBZ0IsRUFBRSxpQkFBaUIsNEJBQTRCLGdDQUFnQyx5Q0FBeUMsU0FBUyxXQUFXLEtBQUsseUVBQXlFLGNBQWMsTUFBTSxFQUFFLEVBQUUsWUFBWSxrQkFBa0IsbUNBQW1DLEVBQUUseUdBQXlHLG9nQkFBb2dCLGtCQUFrQixJQUFJLHVDQUF1QyxTQUFTLGFBQWEsa0JBQWtCLFVBQVUsb0lBQW9JLDJCQUEyQixLQUFLLDBCQUEwQixTQUFTLFlBQVksRUFBRSxtQkFBbUIsWUFBWSxTQUFTLFdBQVcsS0FBSyxtQkFBbUIsRUFBRSxFQUFFLGVBQWUsa0JBQWtCLDZCQUE2QixrQkFBa0IsVUFBVSxzTUFBc00sSUFBSSxvQ0FBb0MscURBQXFELGNBQWMsZ0hBQWdILHFDQUFxQyxtREFBbUQsOEpBQThKLFVBQVUsUUFBUSxFQUFFLHVCQUF1QixLQUFLLGdFQUFnRSx1REFBdUQsRUFBRSxLQUFLLDhCQUE4QixVQUFVLEVBQUUsd0JBQXdCLGtCQUFrQixTQUFTLEtBQUssRUFBRSxFQUFFLFFBQVE7O0FBRWxzUTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRCQUE0QjtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0RBQXNEO0FBQ3pFLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDLHdDQUF3Qzs7QUFFeEMsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0EsOElBQThJOztBQUU5STtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7O0FBRXBFO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckMsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIOztBQUVsSDtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCLEVBQUU7O0FBRW5DO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQiwrREFBK0QsOEJBQThCO0FBQzdGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7O0FBRTdFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUMsaURBQWlELDRCQUE0QixFQUFFO0FBQy9FLDRDQUE0QyxrQ0FBa0MsRUFBRTtBQUNoRiw0REFBNEQsa0NBQWtDLEVBQUU7QUFDaEcsb0RBQW9ELDRCQUE0QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWIseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qix1REFBdUQsRUFBRTs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0EsaUJBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWCx3Q0FBd0MsZ0NBQWdDO0FBQ3hFLDhCQUE4Qiw2REFBNkQ7QUFDM0YsOEJBQThCLHFFQUFxRTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVSx1QkFBdUIsMENBQTBDLGtDQUFrQyxjQUFjLGdEQUFnRCxHQUFHO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMseUJBQXlCO0FBQ3pCLGtCQUFrQix3REFBd0QsR0FBRztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRIO0FBQzVILHlDQUF5QztBQUN6QyxzQkFBc0Isa0pBQWtKLElBQUksRUFBRTtBQUM5SztBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsMkNBQTJDLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLHVCQUF1QiwwQ0FBMEMsa0NBQWtDLGNBQWMsNkNBQTZDLEdBQUc7QUFDOU47QUFDQSxpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLGtCQUFrQiw2Q0FBNkMsR0FBRztBQUNsRTtBQUNBLCtDQUErQztBQUMvQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG9FQUFvRSxHQUFHO0FBQ3ZFLHdDQUF3Qyw4QkFBOEIsRUFBRSx3QkFBd0IsdUJBQXVCLDBNQUEwTSxHQUFHLEVBQUU7QUFDdFUsc0JBQXNCLDZQQUE2UCxJQUFJLEVBQUU7QUFDelI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkNBQTZDLEVBQUU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVLHVCQUF1QiwwQ0FBMEMsa0NBQWtDLGNBQWMsK0NBQStDLEdBQUc7QUFDaE87QUFDQSxpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLGtCQUFrQixrREFBa0Q7QUFDcEUsaUJBQWlCO0FBQ2pCLHVIQUF1SCxHQUFHO0FBQzFILGtCQUFrQix5REFBeUQ7QUFDM0UsaUJBQWlCLHNFQUFzRSxHQUFHO0FBQzFGLDJDQUEyQyx3REFBd0Q7QUFDbkcsaUJBQWlCO0FBQ2pCLHlDQUF5QyxHQUFHO0FBQzVDLGtCQUFrQixxREFBcUQ7QUFDdkUseUNBQXlDO0FBQ3pDLHdDQUF3Qyw4QkFBOEIsRUFBRSx3QkFBd0IsdUJBQXVCLDBNQUEwTSxHQUFHLEVBQUU7QUFDdFUsc0JBQXNCLDZQQUE2UCxJQUFJLEVBQUU7QUFDelI7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsNkNBQTZDLEdBQUcscUJBQXFCLHFCQUFxQixHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0NBQW9DLEVBQUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGFBQWE7QUFDYjtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEIsRUFBRTtBQUNuRjtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEIsRUFBRTtBQUNuRjtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsdUJBQXVCLEVBQUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELG9DQUFvQyxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdEQUF3RDtBQUN6RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsK0JBQStCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCLEVBQUU7QUFDdEUsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0MseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBOztBQUVBLHVEQUF1RCxtQkFBbUIscUdBQXFHO0FBQy9LLFNBQVM7QUFDVDs7QUFFQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEM7QUFDOUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDLENBQUMsa0JBQWtCO0FBQ25COztBQUVBLGlFQUFlLEtBQUssRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AamFhbWVzL2lyby9kaXN0L2lyby5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaXJvLmpzIHY1LjUuMFxuICogMjAxNi0yMDIxIEphbWVzIERhbmllbFxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMFxuICogZ2l0aHViLmNvbS9qYWFtZXMvaXJvLmpzXG4gKi9cblxudmFyIG4sdSx0LGkscixvLGY9e30sZT1bXSxjPS9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfF4tLS9pO2Z1bmN0aW9uIHMobixsKXtmb3IodmFyIHUgaW4gbCl7IG5bdV09bFt1XTsgfXJldHVybiBufWZ1bmN0aW9uIGEobil7dmFyIGw9bi5wYXJlbnROb2RlO2wmJmwucmVtb3ZlQ2hpbGQobik7fWZ1bmN0aW9uIGgobixsLHUpe3ZhciB0LGkscixvLGY9YXJndW1lbnRzO2lmKGw9cyh7fSxsKSxhcmd1bWVudHMubGVuZ3RoPjMpeyBmb3IodT1bdV0sdD0zO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspeyB1LnB1c2goZlt0XSk7IH0gfWlmKG51bGwhPXUmJihsLmNoaWxkcmVuPXUpLG51bGwhPW4mJm51bGwhPW4uZGVmYXVsdFByb3BzKXsgZm9yKGkgaW4gbi5kZWZhdWx0UHJvcHMpeyB2b2lkIDA9PT1sW2ldJiYobFtpXT1uLmRlZmF1bHRQcm9wc1tpXSk7IH0gfXJldHVybiBvPWwua2V5LG51bGwhPShyPWwucmVmKSYmZGVsZXRlIGwucmVmLG51bGwhPW8mJmRlbGV0ZSBsLmtleSx2KG4sbCxvLHIpfWZ1bmN0aW9uIHYobCx1LHQsaSl7dmFyIHI9e3R5cGU6bCxwcm9wczp1LGtleTp0LHJlZjppLF9fazpudWxsLF9fcDpudWxsLF9fYjowLF9fZTpudWxsLGw6bnVsbCxfX2M6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDB9O3JldHVybiBuLnZub2RlJiZuLnZub2RlKHIpLHJ9ZnVuY3Rpb24gZChuKXtyZXR1cm4gbi5jaGlsZHJlbn1mdW5jdGlvbiB5KG4pe2lmKG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbil7IHJldHVybiBudWxsOyB9aWYoXCJzdHJpbmdcIj09dHlwZW9mIG58fFwibnVtYmVyXCI9PXR5cGVvZiBuKXsgcmV0dXJuIHYobnVsbCxuLG51bGwsbnVsbCk7IH1pZihudWxsIT1uLl9fZXx8bnVsbCE9bi5fX2Mpe3ZhciBsPXYobi50eXBlLG4ucHJvcHMsbi5rZXksbnVsbCk7cmV0dXJuIGwuX19lPW4uX19lLGx9cmV0dXJuIG59ZnVuY3Rpb24gbShuLGwpe3RoaXMucHJvcHM9bix0aGlzLmNvbnRleHQ9bDt9ZnVuY3Rpb24gdyhuLGwpe2lmKG51bGw9PWwpeyByZXR1cm4gbi5fX3A/dyhuLl9fcCxuLl9fcC5fX2suaW5kZXhPZihuKSsxKTpudWxsOyB9Zm9yKHZhciB1O2w8bi5fX2subGVuZ3RoO2wrKyl7IGlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpeyByZXR1cm4gdS5fX2U7IH0gfXJldHVybiBcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLnR5cGU/dyhuKTpudWxsfWZ1bmN0aW9uIGcobil7dmFyIGwsdTtpZihudWxsIT0obj1uLl9fcCkmJm51bGwhPW4uX19jKXtmb3Iobi5fX2U9bi5fX2MuYmFzZT1udWxsLGw9MDtsPG4uX19rLmxlbmd0aDtsKyspeyBpZihudWxsIT0odT1uLl9fa1tsXSkmJm51bGwhPXUuX19lKXtuLl9fZT1uLl9fYy5iYXNlPXUuX19lO2JyZWFrfSB9cmV0dXJuIGcobil9fWZ1bmN0aW9uIGsobCl7KCFsLl9fZCYmKGwuX19kPSEwKSYmMT09PXUucHVzaChsKXx8aSE9PW4uZGVib3VuY2VSZW5kZXJpbmcpJiYoaT1uLmRlYm91bmNlUmVuZGVyaW5nLChuLmRlYm91bmNlUmVuZGVyaW5nfHx0KShfKSk7fWZ1bmN0aW9uIF8oKXt2YXIgbixsLHQsaSxyLG8sZixlO2Zvcih1LnNvcnQoZnVuY3Rpb24obixsKXtyZXR1cm4gbC5fX3YuX19iLW4uX192Ll9fYn0pO249dS5wb3AoKTspeyBuLl9fZCYmKHQ9dm9pZCAwLGk9dm9pZCAwLG89KHI9KGw9bikuX192KS5fX2UsZj1sLl9fUCxlPWwudSxsLnU9ITEsZiYmKHQ9W10saT0kKGYscixzKHt9LHIpLGwuX19uLHZvaWQgMCE9PWYub3duZXJTVkdFbGVtZW50LG51bGwsdCxlLG51bGw9PW8/dyhyKTpvKSxqKHQsciksaSE9byYmZyhyKSkpOyB9fWZ1bmN0aW9uIGIobixsLHUsdCxpLHIsbyxjLHMpe3ZhciBoLHYscCxkLHksbSxnLGs9dSYmdS5fX2t8fGUsXz1rLmxlbmd0aDtpZihjPT1mJiYoYz1udWxsIT1yP3JbMF06Xz93KHUsMCk6bnVsbCksaD0wLGwuX19rPXgobC5fX2ssZnVuY3Rpb24odSl7aWYobnVsbCE9dSl7aWYodS5fX3A9bCx1Ll9fYj1sLl9fYisxLG51bGw9PT0ocD1rW2hdKXx8cCYmdS5rZXk9PXAua2V5JiZ1LnR5cGU9PT1wLnR5cGUpeyBrW2hdPXZvaWQgMDsgfWVsc2UgeyBmb3Iodj0wO3Y8Xzt2Kyspe2lmKChwPWtbdl0pJiZ1LmtleT09cC5rZXkmJnUudHlwZT09PXAudHlwZSl7a1t2XT12b2lkIDA7YnJlYWt9cD1udWxsO30gfWlmKGQ9JChuLHUscD1wfHxmLHQsaSxyLG8sbnVsbCxjLHMpLCh2PXUucmVmKSYmcC5yZWYhPXYmJihnfHwoZz1bXSkpLnB1c2godix1Ll9fY3x8ZCx1KSxudWxsIT1kKXtpZihudWxsPT1tJiYobT1kKSxudWxsIT11LmwpeyBkPXUubCx1Lmw9bnVsbDsgfWVsc2UgaWYocj09cHx8ZCE9Y3x8bnVsbD09ZC5wYXJlbnROb2RlKXtuOmlmKG51bGw9PWN8fGMucGFyZW50Tm9kZSE9PW4peyBuLmFwcGVuZENoaWxkKGQpOyB9ZWxzZXtmb3IoeT1jLHY9MDsoeT15Lm5leHRTaWJsaW5nKSYmdjxfO3YrPTIpeyBpZih5PT1kKXsgYnJlYWsgbjsgfSB9bi5pbnNlcnRCZWZvcmUoZCxjKTt9XCJvcHRpb25cIj09bC50eXBlJiYobi52YWx1ZT1cIlwiKTt9Yz1kLm5leHRTaWJsaW5nLFwiZnVuY3Rpb25cIj09dHlwZW9mIGwudHlwZSYmKGwubD1kKTt9fXJldHVybiBoKyssdX0pLGwuX19lPW0sbnVsbCE9ciYmXCJmdW5jdGlvblwiIT10eXBlb2YgbC50eXBlKXsgZm9yKGg9ci5sZW5ndGg7aC0tOyl7IG51bGwhPXJbaF0mJmEocltoXSk7IH0gfWZvcihoPV87aC0tOyl7IG51bGwhPWtbaF0mJkQoa1toXSxrW2hdKTsgfWlmKGcpeyBmb3IoaD0wO2g8Zy5sZW5ndGg7aCsrKXsgQShnW2hdLGdbKytoXSxnWysraF0pOyB9IH19ZnVuY3Rpb24geChuLGwsdSl7aWYobnVsbD09dSYmKHU9W10pLG51bGw9PW58fFwiYm9vbGVhblwiPT10eXBlb2Ygbil7IGwmJnUucHVzaChsKG51bGwpKTsgfWVsc2UgaWYoQXJyYXkuaXNBcnJheShuKSl7IGZvcih2YXIgdD0wO3Q8bi5sZW5ndGg7dCsrKXsgeChuW3RdLGwsdSk7IH0gfWVsc2UgeyB1LnB1c2gobD9sKHkobikpOm4pOyB9cmV0dXJuIHV9ZnVuY3Rpb24gQyhuLGwsdSx0LGkpe3ZhciByO2ZvcihyIGluIHUpeyByIGluIGx8fE4obixyLG51bGwsdVtyXSx0KTsgfWZvcihyIGluIGwpeyBpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsW3JdfHxcInZhbHVlXCI9PT1yfHxcImNoZWNrZWRcIj09PXJ8fHVbcl09PT1sW3JdfHxOKG4scixsW3JdLHVbcl0sdCk7IH19ZnVuY3Rpb24gUChuLGwsdSl7XCItXCI9PT1sWzBdP24uc2V0UHJvcGVydHkobCx1KTpuW2xdPVwibnVtYmVyXCI9PXR5cGVvZiB1JiYhMT09PWMudGVzdChsKT91K1wicHhcIjpudWxsPT11P1wiXCI6dTt9ZnVuY3Rpb24gTihuLGwsdSx0LGkpe3ZhciByLG8sZixlLGM7aWYoXCJrZXlcIj09PShsPWk/XCJjbGFzc05hbWVcIj09PWw/XCJjbGFzc1wiOmw6XCJjbGFzc1wiPT09bD9cImNsYXNzTmFtZVwiOmwpfHxcImNoaWxkcmVuXCI9PT1sKTtlbHNlIGlmKFwic3R5bGVcIj09PWwpeyBpZihyPW4uc3R5bGUsXCJzdHJpbmdcIj09dHlwZW9mIHUpeyByLmNzc1RleHQ9dTsgfWVsc2V7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJihyLmNzc1RleHQ9XCJcIix0PW51bGwpLHQpeyBmb3IobyBpbiB0KXsgdSYmbyBpbiB1fHxQKHIsbyxcIlwiKTsgfSB9aWYodSl7IGZvcihmIGluIHUpeyB0JiZ1W2ZdPT09dFtmXXx8UChyLGYsdVtmXSk7IH0gfX0gfWVsc2V7IFwib1wiPT09bFswXSYmXCJuXCI9PT1sWzFdPyhlPWwhPT0obD1sLnJlcGxhY2UoL0NhcHR1cmUkLyxcIlwiKSksYz1sLnRvTG93ZXJDYXNlKCksbD0oYyBpbiBuP2M6bCkuc2xpY2UoMiksdT8odHx8bi5hZGRFdmVudExpc3RlbmVyKGwsVCxlKSwobi50fHwobi50PXt9KSlbbF09dSk6bi5yZW1vdmVFdmVudExpc3RlbmVyKGwsVCxlKSk6XCJsaXN0XCIhPT1sJiZcInRhZ05hbWVcIiE9PWwmJlwiZm9ybVwiIT09bCYmIWkmJmwgaW4gbj9uW2xdPW51bGw9PXU/XCJcIjp1OlwiZnVuY3Rpb25cIiE9dHlwZW9mIHUmJlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWwmJihsIT09KGw9bC5yZXBsYWNlKC9eeGxpbms6Py8sXCJcIikpP251bGw9PXV8fCExPT09dT9uLnJlbW92ZUF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLGwudG9Mb3dlckNhc2UoKSk6bi5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixsLnRvTG93ZXJDYXNlKCksdSk6bnVsbD09dXx8ITE9PT11P24ucmVtb3ZlQXR0cmlidXRlKGwpOm4uc2V0QXR0cmlidXRlKGwsdSkpOyB9fWZ1bmN0aW9uIFQobCl7cmV0dXJuIHRoaXMudFtsLnR5cGVdKG4uZXZlbnQ/bi5ldmVudChsKTpsKX1mdW5jdGlvbiAkKGwsdSx0LGkscixvLGYsZSxjLGEpe3ZhciBoLHYscCx5LHcsZyxrLF8sQyxQLE49dS50eXBlO2lmKHZvaWQgMCE9PXUuY29uc3RydWN0b3IpeyByZXR1cm4gbnVsbDsgfShoPW4uX19iKSYmaCh1KTt0cnl7bjppZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBOKXtpZihfPXUucHJvcHMsQz0oaD1OLmNvbnRleHRUeXBlKSYmaVtoLl9fY10sUD1oP0M/Qy5wcm9wcy52YWx1ZTpoLl9fcDppLHQuX19jP2s9KHY9dS5fX2M9dC5fX2MpLl9fcD12Ll9fRTooXCJwcm90b3R5cGVcImluIE4mJk4ucHJvdG90eXBlLnJlbmRlcj91Ll9fYz12PW5ldyBOKF8sUCk6KHUuX19jPXY9bmV3IG0oXyxQKSx2LmNvbnN0cnVjdG9yPU4sdi5yZW5kZXI9SCksQyYmQy5zdWIodiksdi5wcm9wcz1fLHYuc3RhdGV8fCh2LnN0YXRlPXt9KSx2LmNvbnRleHQ9UCx2Ll9fbj1pLHA9di5fX2Q9ITAsdi5fX2g9W10pLG51bGw9PXYuX19zJiYodi5fX3M9di5zdGF0ZSksbnVsbCE9Ti5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJnModi5fX3M9PXYuc3RhdGU/di5fX3M9cyh7fSx2Ll9fcyk6di5fX3MsTi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoXyx2Ll9fcykpLHApeyBudWxsPT1OLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbCE9di5jb21wb25lbnRXaWxsTW91bnQmJnYuY29tcG9uZW50V2lsbE1vdW50KCksbnVsbCE9di5jb21wb25lbnREaWRNb3VudCYmZi5wdXNoKHYpOyB9ZWxzZXtpZihudWxsPT1OLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmbnVsbD09ZSYmbnVsbCE9di5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJiZ2LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXyxQKSwhZSYmbnVsbCE9di5zaG91bGRDb21wb25lbnRVcGRhdGUmJiExPT09di5zaG91bGRDb21wb25lbnRVcGRhdGUoXyx2Ll9fcyxQKSl7Zm9yKHYucHJvcHM9Xyx2LnN0YXRlPXYuX19zLHYuX19kPSExLHYuX192PXUsdS5fX2U9bnVsbCE9Yz9jIT09dC5fX2U/Yzp0Ll9fZTpudWxsLHUuX19rPXQuX19rLGg9MDtoPHUuX19rLmxlbmd0aDtoKyspeyB1Ll9fa1toXSYmKHUuX19rW2hdLl9fcD11KTsgfWJyZWFrIG59bnVsbCE9di5jb21wb25lbnRXaWxsVXBkYXRlJiZ2LmNvbXBvbmVudFdpbGxVcGRhdGUoXyx2Ll9fcyxQKTt9Zm9yKHk9di5wcm9wcyx3PXYuc3RhdGUsdi5jb250ZXh0PVAsdi5wcm9wcz1fLHYuc3RhdGU9di5fX3MsKGg9bi5fX3IpJiZoKHUpLHYuX19kPSExLHYuX192PXUsdi5fX1A9bCxoPXYucmVuZGVyKHYucHJvcHMsdi5zdGF0ZSx2LmNvbnRleHQpLHUuX19rPXgobnVsbCE9aCYmaC50eXBlPT1kJiZudWxsPT1oLmtleT9oLnByb3BzLmNoaWxkcmVuOmgpLG51bGwhPXYuZ2V0Q2hpbGRDb250ZXh0JiYoaT1zKHMoe30saSksdi5nZXRDaGlsZENvbnRleHQoKSkpLHB8fG51bGw9PXYuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGV8fChnPXYuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoeSx3KSksYihsLHUsdCxpLHIsbyxmLGMsYSksdi5iYXNlPXUuX19lO2g9di5fX2gucG9wKCk7KXsgdi5fX3MmJih2LnN0YXRlPXYuX19zKSxoLmNhbGwodik7IH1wfHxudWxsPT15fHxudWxsPT12LmNvbXBvbmVudERpZFVwZGF0ZXx8di5jb21wb25lbnREaWRVcGRhdGUoeSx3LGcpLGsmJih2Ll9fRT12Ll9fcD1udWxsKTt9ZWxzZSB7IHUuX19lPXoodC5fX2UsdSx0LGkscixvLGYsYSk7IH0oaD1uLmRpZmZlZCkmJmgodSk7fWNhdGNoKGwpe24uX19lKGwsdSx0KTt9cmV0dXJuIHUuX19lfWZ1bmN0aW9uIGoobCx1KXtmb3IodmFyIHQ7dD1sLnBvcCgpOyl7IHRyeXt0LmNvbXBvbmVudERpZE1vdW50KCk7fWNhdGNoKGwpe24uX19lKGwsdC5fX3YpO30gfW4uX19jJiZuLl9fYyh1KTt9ZnVuY3Rpb24geihuLGwsdSx0LGkscixvLGMpe3ZhciBzLGEsaCx2LHA9dS5wcm9wcyxkPWwucHJvcHM7aWYoaT1cInN2Z1wiPT09bC50eXBlfHxpLG51bGw9PW4mJm51bGwhPXIpeyBmb3Iocz0wO3M8ci5sZW5ndGg7cysrKXsgaWYobnVsbCE9KGE9cltzXSkmJihudWxsPT09bC50eXBlPzM9PT1hLm5vZGVUeXBlOmEubG9jYWxOYW1lPT09bC50eXBlKSl7bj1hLHJbc109bnVsbDticmVha30gfSB9aWYobnVsbD09bil7aWYobnVsbD09PWwudHlwZSl7IHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkKTsgfW49aT9kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLGwudHlwZSk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChsLnR5cGUpLHI9bnVsbDt9cmV0dXJuIG51bGw9PT1sLnR5cGU/cCE9PWQmJihudWxsIT1yJiYocltyLmluZGV4T2YobildPW51bGwpLG4uZGF0YT1kKTpsIT09dSYmKG51bGwhPXImJihyPWUuc2xpY2UuY2FsbChuLmNoaWxkTm9kZXMpKSxoPShwPXUucHJvcHN8fGYpLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLHY9ZC5kYW5nZXJvdXNseVNldElubmVySFRNTCxjfHwodnx8aCkmJih2JiZoJiZ2Ll9faHRtbD09aC5fX2h0bWx8fChuLmlubmVySFRNTD12JiZ2Ll9faHRtbHx8XCJcIikpLEMobixkLHAsaSxjKSxsLl9faz1sLnByb3BzLmNoaWxkcmVuLHZ8fGIobixsLHUsdCxcImZvcmVpZ25PYmplY3RcIiE9PWwudHlwZSYmaSxyLG8sZixjKSxjfHwoXCJ2YWx1ZVwiaW4gZCYmdm9pZCAwIT09ZC52YWx1ZSYmZC52YWx1ZSE9PW4udmFsdWUmJihuLnZhbHVlPW51bGw9PWQudmFsdWU/XCJcIjpkLnZhbHVlKSxcImNoZWNrZWRcImluIGQmJnZvaWQgMCE9PWQuY2hlY2tlZCYmZC5jaGVja2VkIT09bi5jaGVja2VkJiYobi5jaGVja2VkPWQuY2hlY2tlZCkpKSxufWZ1bmN0aW9uIEEobCx1LHQpe3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2wodSk6bC5jdXJyZW50PXU7fWNhdGNoKGwpe24uX19lKGwsdCk7fX1mdW5jdGlvbiBEKGwsdSx0KXt2YXIgaSxyLG87aWYobi51bm1vdW50JiZuLnVubW91bnQobCksKGk9bC5yZWYpJiZBKGksbnVsbCx1KSx0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBsLnR5cGV8fCh0PW51bGwhPShyPWwuX19lKSksbC5fX2U9bC5sPW51bGwsbnVsbCE9KGk9bC5fX2MpKXtpZihpLmNvbXBvbmVudFdpbGxVbm1vdW50KXsgdHJ5e2kuY29tcG9uZW50V2lsbFVubW91bnQoKTt9Y2F0Y2gobCl7bi5fX2UobCx1KTt9IH1pLmJhc2U9aS5fX1A9bnVsbDt9aWYoaT1sLl9fayl7IGZvcihvPTA7bzxpLmxlbmd0aDtvKyspeyBpW29dJiZEKGlbb10sdSx0KTsgfSB9bnVsbCE9ciYmYShyKTt9ZnVuY3Rpb24gSChuLGwsdSl7cmV0dXJuIHRoaXMuY29uc3RydWN0b3Iobix1KX1mdW5jdGlvbiBJKGwsdSx0KXt2YXIgaSxvLGM7bi5fX3AmJm4uX19wKGwsdSksbz0oaT10PT09cik/bnVsbDp0JiZ0Ll9fa3x8dS5fX2ssbD1oKGQsbnVsbCxbbF0pLGM9W10sJCh1LGk/dS5fX2s9bDoodHx8dSkuX19rPWwsb3x8ZixmLHZvaWQgMCE9PXUub3duZXJTVkdFbGVtZW50LHQmJiFpP1t0XTpvP251bGw6ZS5zbGljZS5jYWxsKHUuY2hpbGROb2RlcyksYywhMSx0fHxmLGkpLGooYyxsKTt9bj17fSxtLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihuLGwpe3ZhciB1PXRoaXMuX19zIT09dGhpcy5zdGF0ZSYmdGhpcy5fX3N8fCh0aGlzLl9fcz1zKHt9LHRoaXMuc3RhdGUpKTsoXCJmdW5jdGlvblwiIT10eXBlb2Ygbnx8KG49bih1LHRoaXMucHJvcHMpKSkmJnModSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKHRoaXMudT0hMSxsJiZ0aGlzLl9faC5wdXNoKGwpLGsodGhpcykpO30sbS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24obil7dGhpcy5fX3YmJihuJiZ0aGlzLl9faC5wdXNoKG4pLHRoaXMudT0hMCxrKHRoaXMpKTt9LG0ucHJvdG90eXBlLnJlbmRlcj1kLHU9W10sdD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBQcm9taXNlP1Byb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSk6c2V0VGltZW91dCxpPW4uZGVib3VuY2VSZW5kZXJpbmcsbi5fX2U9ZnVuY3Rpb24obixsLHUpe2Zvcih2YXIgdDtsPWwuX19wOyl7IGlmKCh0PWwuX19jKSYmIXQuX19wKXsgdHJ5e2lmKHQuY29uc3RydWN0b3ImJm51bGwhPXQuY29uc3RydWN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKXsgdC5zZXRTdGF0ZSh0LmNvbnN0cnVjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihuKSk7IH1lbHNle2lmKG51bGw9PXQuY29tcG9uZW50RGlkQ2F0Y2gpeyBjb250aW51ZTsgfXQuY29tcG9uZW50RGlkQ2F0Y2gobik7fXJldHVybiBrKHQuX19FPXQpfWNhdGNoKGwpe249bDt9IH0gfXRocm93IG59LHI9ZixvPTA7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIHsgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgeyBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyB9XG4gIGlmIChzdGF0aWNQcm9wcykgeyBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyB9XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHMkMVtpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyBTb21lIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHJnYigpIGFuZCBoc2woKSBDb2xvcnMgYXJlIGJvcnJvd2VkIGZyb20gdGlueUNvbG9yXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmdyaW5zL1RpbnlDb2xvclxuLy8gS2VsdmluIHRlbXBlcmF0dXJlIG1hdGggYm9ycm93ZWQgZnJvbSBOZWlsIEJhcmxldHQncyBpbXBsZW1lbnRhdGlvblxuLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbmVpbGJhcnRsZXR0L2NvbG9yLXRlbXBlcmF0dXJlXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzMy12YWx1ZXMvI2ludGVnZXJzXG52YXIgQ1NTX0lOVEVHRVIgPSAnWy1cXFxcK10/XFxcXGQrJT8nOyAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXZhbHVlcy8jbnVtYmVyLXZhbHVlXG5cbnZhciBDU1NfTlVNQkVSID0gJ1stXFxcXCtdP1xcXFxkKlxcXFwuXFxcXGQrJT8nOyAvLyBBbGxvdyBwb3NpdGl2ZS9uZWdhdGl2ZSBpbnRlZ2VyL251bWJlci4gRG9uJ3QgY2FwdHVyZSB0aGUgZWl0aGVyL29yLCBqdXN0IHRoZSBlbnRpcmUgb3V0Y29tZVxuXG52YXIgQ1NTX1VOSVQgPSAnKD86JyArIENTU19OVU1CRVIgKyAnKXwoPzonICsgQ1NTX0lOVEVHRVIgKyAnKSc7IC8vIFBhcnNlIGZ1bmN0aW9uIHBhcmFtc1xuLy8gUGFyZW5zIGFuZCBjb21tYXMgYXJlIG9wdGlvbmFsLCBhbmQgdGhpcyBhbHNvIGFsbG93cyBmb3Igd2hpdGVzcGFjZSBiZXR3ZWVuIG51bWJlcnNcblxudmFyIFBFUk1JU1NJVkVfTUFUQ0hfMyA9ICdbXFxcXHN8XFxcXChdKygnICsgQ1NTX1VOSVQgKyAnKVssfFxcXFxzXSsoJyArIENTU19VTklUICsgJylbLHxcXFxcc10rKCcgKyBDU1NfVU5JVCArICcpXFxcXHMqXFxcXCk/JztcbnZhciBQRVJNSVNTSVZFX01BVENIXzQgPSAnW1xcXFxzfFxcXFwoXSsoJyArIENTU19VTklUICsgJylbLHxcXFxcc10rKCcgKyBDU1NfVU5JVCArICcpWyx8XFxcXHNdKygnICsgQ1NTX1VOSVQgKyAnKVssfFxcXFxzXSsoJyArIENTU19VTklUICsgJylcXFxccypcXFxcKT8nOyAvLyBSZWdleCBwYXR0ZXJucyBmb3IgZnVuY3Rpb25hbCBjb2xvciBzdHJpbmdzXG5cbnZhciBSRUdFWF9GVU5DVElPTkFMX1JHQiA9IG5ldyBSZWdFeHAoJ3JnYicgKyBQRVJNSVNTSVZFX01BVENIXzMpO1xudmFyIFJFR0VYX0ZVTkNUSU9OQUxfUkdCQSA9IG5ldyBSZWdFeHAoJ3JnYmEnICsgUEVSTUlTU0lWRV9NQVRDSF80KTtcbnZhciBSRUdFWF9GVU5DVElPTkFMX0hTTCA9IG5ldyBSZWdFeHAoJ2hzbCcgKyBQRVJNSVNTSVZFX01BVENIXzMpO1xudmFyIFJFR0VYX0ZVTkNUSU9OQUxfSFNMQSA9IG5ldyBSZWdFeHAoJ2hzbGEnICsgUEVSTUlTU0lWRV9NQVRDSF80KTsgLy8gQ29sb3Igc3RyaW5nIHBhcnNpbmcgcmVnZXhcblxudmFyIEhFWF9TVEFSVCA9ICdeKD86Iz98MHg/KSc7XG52YXIgSEVYX0lOVF9TSU5HTEUgPSAnKFswLTlhLWZBLUZdezF9KSc7XG52YXIgSEVYX0lOVF9ET1VCTEUgPSAnKFswLTlhLWZBLUZdezJ9KSc7XG52YXIgUkVHRVhfSEVYXzMgPSBuZXcgUmVnRXhwKEhFWF9TVEFSVCArIEhFWF9JTlRfU0lOR0xFICsgSEVYX0lOVF9TSU5HTEUgKyBIRVhfSU5UX1NJTkdMRSArICckJyk7XG52YXIgUkVHRVhfSEVYXzQgPSBuZXcgUmVnRXhwKEhFWF9TVEFSVCArIEhFWF9JTlRfU0lOR0xFICsgSEVYX0lOVF9TSU5HTEUgKyBIRVhfSU5UX1NJTkdMRSArIEhFWF9JTlRfU0lOR0xFICsgJyQnKTtcbnZhciBSRUdFWF9IRVhfNiA9IG5ldyBSZWdFeHAoSEVYX1NUQVJUICsgSEVYX0lOVF9ET1VCTEUgKyBIRVhfSU5UX0RPVUJMRSArIEhFWF9JTlRfRE9VQkxFICsgJyQnKTtcbnZhciBSRUdFWF9IRVhfOCA9IG5ldyBSZWdFeHAoSEVYX1NUQVJUICsgSEVYX0lOVF9ET1VCTEUgKyBIRVhfSU5UX0RPVUJMRSArIEhFWF9JTlRfRE9VQkxFICsgSEVYX0lOVF9ET1VCTEUgKyAnJCcpOyAvLyBLZWx2aW4gdGVtcGVyYXR1cmUgYm91bmRzXG5cbnZhciBLRUxWSU5fTUlOID0gMjAwMDtcbnZhciBLRUxWSU5fTUFYID0gNDAwMDA7IC8vIE1hdGggc2hvcnRoYW5kc1xuXG52YXIgbG9nID0gTWF0aC5sb2csXG4gICAgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgIGZsb29yID0gTWF0aC5mbG9vcjtcbi8qKlxyXG4gKiBAZGVzYyBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIGEgbWluIGFuZCBtYXggdmFsdWVcclxuICogQHBhcmFtIG51bSAtIGlucHV0IHZhbHVlXHJcbiAqIEBwYXJhbSBtaW4gLSBtaW4gYWxsb3dlZCB2YWx1ZVxyXG4gKiBAcGFyYW0gbWF4IC0gbWF4IGFsbG93ZWQgdmFsdWVcclxuICovXG5cbmZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcbn1cbi8qKlxyXG4gKiBAZGVzYyBQYXJzZSBhIGNzcyB1bml0IHN0cmluZyAtIGVpdGhlciByZWd1bGFyIGludCBvciBhIHBlcmNlbnRhZ2UgbnVtYmVyXHJcbiAqIEBwYXJhbSBzdHIgLSBjc3MgdW5pdCBzdHJpbmdcclxuICogQHBhcmFtIG1heCAtIG1heCB1bml0IHZhbHVlLCB1c2VkIGZvciBjYWxjdWxhdGluZyBwZXJjZW50YWdlc1xyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVVuaXQoc3RyLCBtYXgpIHtcbiAgdmFyIGlzUGVyY2VudGFnZSA9IHN0ci5pbmRleE9mKCclJykgPiAtMTtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoc3RyKTtcbiAgcmV0dXJuIGlzUGVyY2VudGFnZSA/IG1heCAvIDEwMCAqIG51bSA6IG51bTtcbn1cbi8qKlxyXG4gKiBAZGVzYyBQYXJzZSBoZXggc3RyIHRvIGFuIGludFxyXG4gKiBAcGFyYW0gc3RyIC0gaGV4IHN0cmluZyB0byBwYXJzZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZUhleEludChzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTYpO1xufVxuLyoqXHJcbiAqIEBkZXNjIENvbnZlcnQgbnVuYmVyIGludG8gdG8gMi1kaWdpdCBoZXhcclxuICogQHBhcmFtIGludCAtIG51bWJlciB0byBjb252ZXJ0XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGludFRvSGV4KF9pbnQpIHtcbiAgcmV0dXJuIF9pbnQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG59XG5cbnZhciBJcm9Db2xvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAgKiBAY29uc3RydWN0b3IgQ29sb3Igb2JqZWN0XHJcbiAgICAqIEBwYXJhbSB2YWx1ZSAtIGluaXRpYWwgY29sb3IgdmFsdWVcclxuICAqL1xuICBmdW5jdGlvbiBJcm9Db2xvcih2YWx1ZSwgb25DaGFuZ2UpIHtcbiAgICAvLyBUaGUgZGVmYXVsdCBDb2xvciB2YWx1ZVxuICAgIHRoaXMuJCA9IHtcbiAgICAgIGg6IDAsXG4gICAgICBzOiAwLFxuICAgICAgdjogMCxcbiAgICAgIGE6IDFcbiAgICB9O1xuICAgIGlmICh2YWx1ZSkgeyB0aGlzLnNldCh2YWx1ZSk7IH0gLy8gVGhlIHdhdGNoIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGlzIENvbG9yIHdpbGwgYmUgc3RvcmVkIGhlcmVcblxuICAgIHRoaXMub25DaGFuZ2UgPSBvbkNoYW5nZTtcbiAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IF9leHRlbmRzKHt9LCB0aGlzLiQpOyAvLyBjb3B5IGluaXRpYWwgdmFsdWVcbiAgfVxuICAvKipcclxuICAgICogQGRlc2MgU2V0IHRoZSBDb2xvciBmcm9tIGFueSB2YWxpZCB2YWx1ZVxyXG4gICAgKiBAcGFyYW0gdmFsdWUgLSBuZXcgY29sb3IgdmFsdWVcclxuICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IElyb0NvbG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICgvXig/OiM/fDB4PylbMC05YS1mQS1GXXszLDh9JC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oZXhTdHJpbmcgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoL15yZ2JhPy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5yZ2JTdHJpbmcgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoL15oc2xhPy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5oc2xTdHJpbmcgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElyb0NvbG9yKSB7XG4gICAgICAgIHRoaXMuaHN2ID0gdmFsdWUuaHN2O1xuICAgICAgfSBlbHNlIGlmICgncicgaW4gdmFsdWUgJiYgJ2cnIGluIHZhbHVlICYmICdiJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJnYiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICgnaCcgaW4gdmFsdWUgJiYgJ3MnIGluIHZhbHVlICYmICd2JyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhzdiA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICgnaCcgaW4gdmFsdWUgJiYgJ3MnIGluIHZhbHVlICYmICdsJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLmhzbCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICgna2VsdmluJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLmtlbHZpbiA9IHZhbHVlLmtlbHZpbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbG9yIHZhbHVlJyk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAgKiBAZGVzYyBTaG9ydGN1dCB0byBzZXQgYSBzcGVjaWZpYyBjaGFubmVsIHZhbHVlXHJcbiAgICAqIEBwYXJhbSBmb3JtYXQgLSBoc3YgfCBoc2wgfCByZ2JcclxuICAgICogQHBhcmFtIGNoYW5uZWwgLSBpbmRpdmlkdWFsIGNoYW5uZWwgdG8gc2V0LCBmb3IgZXhhbXBsZSBpZiBtb2RlbCA9IGhzbCwgY2hhbmVsID0gaCB8IHMgfCBsXHJcbiAgICAqIEBwYXJhbSB2YWx1ZSAtIG5ldyB2YWx1ZSBmb3IgdGhlIGNoYW5uZWxcclxuICAqL1xuICA7XG5cbiAgX3Byb3RvLnNldENoYW5uZWwgPSBmdW5jdGlvbiBzZXRDaGFubmVsKGZvcm1hdCwgY2hhbm5lbCwgdmFsdWUpIHtcbiAgICB2YXIgX2V4dGVuZHMyO1xuXG4gICAgdGhpc1tmb3JtYXRdID0gX2V4dGVuZHMoe30sIHRoaXNbZm9ybWF0XSwgKF9leHRlbmRzMiA9IHt9LCBfZXh0ZW5kczJbY2hhbm5lbF0gPSB2YWx1ZSwgX2V4dGVuZHMyKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGRlc2MgUmVzZXQgY29sb3IgYmFjayB0byBpdHMgaW5pdGlhbCB2YWx1ZVxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgdGhpcy5oc3ZhID0gdGhpcy5pbml0aWFsVmFsdWU7XG4gIH1cbiAgLyoqXHJcbiAgICAqIEBkZXNjIG1ha2UgbmV3IENvbG9yIGluc3RhbmNlIHdpdGggdGhlIHNhbWUgdmFsdWUgYXMgdGhpcyBvbmVcclxuICAqL1xuICA7XG5cbiAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBJcm9Db2xvcih0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBAZGVzYyByZW1vdmUgY29sb3Igb25DaGFuZ2VcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51bmJpbmQgPSBmdW5jdGlvbiB1bmJpbmQoKSB7XG4gICAgdGhpcy5vbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcclxuICAgICogQGRlc2MgQ29udmVydCBoc3Ygb2JqZWN0IHRvIHJnYlxyXG4gICAgKiBAcGFyYW0gaHN2IC0gaHN2IGNvbG9yIG9iamVjdFxyXG4gICovXG4gIDtcblxuICBJcm9Db2xvci5oc3ZUb1JnYiA9IGZ1bmN0aW9uIGhzdlRvUmdiKGhzdikge1xuICAgIHZhciBoID0gaHN2LmggLyA2MDtcbiAgICB2YXIgcyA9IGhzdi5zIC8gMTAwO1xuICAgIHZhciB2ID0gaHN2LnYgLyAxMDA7XG4gICAgdmFyIGkgPSBmbG9vcihoKTtcbiAgICB2YXIgZiA9IGggLSBpO1xuICAgIHZhciBwID0gdiAqICgxIC0gcyk7XG4gICAgdmFyIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG4gICAgdmFyIG1vZCA9IGkgJSA2O1xuICAgIHZhciByID0gW3YsIHEsIHAsIHAsIHQsIHZdW21vZF07XG4gICAgdmFyIGcgPSBbdCwgdiwgdiwgcSwgcCwgcF1bbW9kXTtcbiAgICB2YXIgYiA9IFtwLCBwLCB0LCB2LCB2LCBxXVttb2RdO1xuICAgIHJldHVybiB7XG4gICAgICByOiBjbGFtcChyICogMjU1LCAwLCAyNTUpLFxuICAgICAgZzogY2xhbXAoZyAqIDI1NSwgMCwgMjU1KSxcbiAgICAgIGI6IGNsYW1wKGIgKiAyNTUsIDAsIDI1NSlcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAgKiBAZGVzYyBDb252ZXJ0IHJnYiBvYmplY3QgdG8gaHN2XHJcbiAgICAqIEBwYXJhbSByZ2IgLSByZ2Igb2JqZWN0XHJcbiAgKi9cbiAgO1xuXG4gIElyb0NvbG9yLnJnYlRvSHN2ID0gZnVuY3Rpb24gcmdiVG9Ic3YocmdiKSB7XG4gICAgdmFyIHIgPSByZ2IuciAvIDI1NTtcbiAgICB2YXIgZyA9IHJnYi5nIC8gMjU1O1xuICAgIHZhciBiID0gcmdiLmIgLyAyNTU7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgdmFyIGh1ZSA9IDA7XG4gICAgdmFyIHZhbHVlID0gbWF4O1xuICAgIHZhciBzYXR1cmF0aW9uID0gbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4O1xuXG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgbWluOlxuICAgICAgICBodWUgPSAwOyAvLyBhY2hyb21hdGljXG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgcjpcbiAgICAgICAgaHVlID0gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBnOlxuICAgICAgICBodWUgPSAoYiAtIHIpIC8gZGVsdGEgKyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBiOlxuICAgICAgICBodWUgPSAociAtIGcpIC8gZGVsdGEgKyA0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaDogaHVlICogNjAgJSAzNjAsXG4gICAgICBzOiBjbGFtcChzYXR1cmF0aW9uICogMTAwLCAwLCAxMDApLFxuICAgICAgdjogY2xhbXAodmFsdWUgKiAxMDAsIDAsIDEwMClcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAgKiBAZGVzYyBDb252ZXJ0IGhzdiBvYmplY3QgdG8gaHNsXHJcbiAgICAqIEBwYXJhbSBoc3YgLSBoc3Ygb2JqZWN0XHJcbiAgKi9cbiAgO1xuXG4gIElyb0NvbG9yLmhzdlRvSHNsID0gZnVuY3Rpb24gaHN2VG9Ic2woaHN2KSB7XG4gICAgdmFyIHMgPSBoc3YucyAvIDEwMDtcbiAgICB2YXIgdiA9IGhzdi52IC8gMTAwO1xuICAgIHZhciBsID0gKDIgLSBzKSAqIHY7XG4gICAgdmFyIGRpdmlzb3IgPSBsIDw9IDEgPyBsIDogMiAtIGw7IC8vIEF2b2lkIGRpdmlzaW9uIGJ5IHplcm8gd2hlbiBsaWdodG5lc3MgaXMgY2xvc2UgdG8gemVyb1xuXG4gICAgdmFyIHNhdHVyYXRpb24gPSBkaXZpc29yIDwgMWUtOSA/IDAgOiBzICogdiAvIGRpdmlzb3I7XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IGhzdi5oLFxuICAgICAgczogY2xhbXAoc2F0dXJhdGlvbiAqIDEwMCwgMCwgMTAwKSxcbiAgICAgIGw6IGNsYW1wKGwgKiA1MCwgMCwgMTAwKVxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICAqIEBkZXNjIENvbnZlcnQgaHNsIG9iamVjdCB0byBoc3ZcclxuICAgICogQHBhcmFtIGhzbCAtIGhzbCBvYmplY3RcclxuICAqL1xuICA7XG5cbiAgSXJvQ29sb3IuaHNsVG9Ic3YgPSBmdW5jdGlvbiBoc2xUb0hzdihoc2wpIHtcbiAgICB2YXIgbCA9IGhzbC5sICogMjtcbiAgICB2YXIgcyA9IGhzbC5zICogKGwgPD0gMTAwID8gbCA6IDIwMCAtIGwpIC8gMTAwOyAvLyBBdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gbCArIHMgaXMgbmVhciAwXG5cbiAgICB2YXIgc2F0dXJhdGlvbiA9IGwgKyBzIDwgMWUtOSA/IDAgOiAyICogcyAvIChsICsgcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGg6IGhzbC5oLFxuICAgICAgczogY2xhbXAoc2F0dXJhdGlvbiAqIDEwMCwgMCwgMTAwKSxcbiAgICAgIHY6IGNsYW1wKChsICsgcykgLyAyLCAwLCAxMDApXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgICogQGRlc2MgQ29udmVydCBhIGtlbHZpbiB0ZW1wZXJhdHVyZSB0byBhbiBhcHByb3gsIFJHQiB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ga2VsdmluIC0ga2VsdmluIHRlbXBlcmF0dXJlXHJcbiAgKi9cbiAgO1xuXG4gIElyb0NvbG9yLmtlbHZpblRvUmdiID0gZnVuY3Rpb24ga2VsdmluVG9SZ2Ioa2VsdmluKSB7XG4gICAgdmFyIHRlbXAgPSBrZWx2aW4gLyAxMDA7XG4gICAgdmFyIHIsIGcsIGI7XG5cbiAgICBpZiAodGVtcCA8IDY2KSB7XG4gICAgICByID0gMjU1O1xuICAgICAgZyA9IC0xNTUuMjU0ODU1NjI3MDkxNzkgLSAwLjQ0NTk2OTUwNDY5NTc5MTMzICogKGcgPSB0ZW1wIC0gMikgKyAxMDQuNDkyMTYxOTkzOTM4ODggKiBsb2coZyk7XG4gICAgICBiID0gdGVtcCA8IDIwID8gMCA6IC0yNTQuNzY5MzUxODQxMjA5MDIgKyAwLjgyNzQwOTYwNjQwMDczOTUgKiAoYiA9IHRlbXAgLSAxMCkgKyAxMTUuNjc5OTQ0MDEwNjYxNDcgKiBsb2coYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSAzNTEuOTc2OTA1NjY4MDU2OTMgKyAwLjExNDIwNjQ1Mzc4NDE2NSAqIChyID0gdGVtcCAtIDU1KSAtIDQwLjI1MzY2MzA5MzMyMTI3ICogbG9nKHIpO1xuICAgICAgZyA9IDMyNS40NDk0MTI1NzExOTc0ICsgMC4wNzk0MzQ1NjUzNjY2MjM0MiAqIChnID0gdGVtcCAtIDUwKSAtIDI4LjA4NTI5NjM1MDc5NTcgKiBsb2coZyk7XG4gICAgICBiID0gMjU1O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByOiBjbGFtcChmbG9vcihyKSwgMCwgMjU1KSxcbiAgICAgIGc6IGNsYW1wKGZsb29yKGcpLCAwLCAyNTUpLFxuICAgICAgYjogY2xhbXAoZmxvb3IoYiksIDAsIDI1NSlcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIEBkZXNjIENvbnZlcnQgYW4gUkdCIGNvbG9yIHRvIGFuIGFwcHJveGltYXRlIGtlbHZpbiB0ZW1wZXJhdHVyZVxyXG4gICAqIEBwYXJhbSBrZWx2aW4gLSBrZWx2aW4gdGVtcGVyYXR1cmVcclxuICAqL1xuICA7XG5cbiAgSXJvQ29sb3IucmdiVG9LZWx2aW4gPSBmdW5jdGlvbiByZ2JUb0tlbHZpbihyZ2IpIHtcbiAgICB2YXIgciA9IHJnYi5yLFxuICAgICAgICBiID0gcmdiLmI7XG4gICAgdmFyIGVwcyA9IDAuNDtcbiAgICB2YXIgbWluVGVtcCA9IEtFTFZJTl9NSU47XG4gICAgdmFyIG1heFRlbXAgPSBLRUxWSU5fTUFYO1xuICAgIHZhciB0ZW1wO1xuXG4gICAgd2hpbGUgKG1heFRlbXAgLSBtaW5UZW1wID4gZXBzKSB7XG4gICAgICB0ZW1wID0gKG1heFRlbXAgKyBtaW5UZW1wKSAqIDAuNTtcblxuICAgICAgdmFyIF9yZ2IgPSBJcm9Db2xvci5rZWx2aW5Ub1JnYih0ZW1wKTtcblxuICAgICAgaWYgKF9yZ2IuYiAvIF9yZ2IuciA+PSBiIC8gcikge1xuICAgICAgICBtYXhUZW1wID0gdGVtcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblRlbXAgPSB0ZW1wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0ZW1wO1xuICB9O1xuXG4gIF9jcmVhdGVDbGFzcyhJcm9Db2xvciwgW3tcbiAgICBrZXk6IFwiaHN2XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAvLyB2YWx1ZSBpcyBjbG9uZWQgdG8gYWxsb3cgY2hhbmdlcyB0byBiZSBtYWRlIHRvIHRoZSB2YWx1ZXMgYmVmb3JlIHBhc3NpbmcgdGhlbSBiYWNrXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLiQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoOiB2YWx1ZS5oLFxuICAgICAgICBzOiB2YWx1ZS5zLFxuICAgICAgICB2OiB2YWx1ZS52XG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUpIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMuJDtcbiAgICAgIG5ld1ZhbHVlID0gX2V4dGVuZHMoe30sIG9sZFZhbHVlLCBuZXdWYWx1ZSk7IC8vIElmIHRoaXMgQ29sb3IgaXMgYmVpbmcgd2F0Y2hlZCBmb3IgY2hhbmdlcyB3ZSBuZWVkIHRvIGNvbXBhcmUgdGhlIG5ldyBhbmQgb2xkIHZhbHVlcyB0byBjaGVjayB0aGUgZGlmZmVyZW5jZVxuICAgICAgLy8gT3RoZXJ3aXNlIHdlIGNhbiBqdXN0IGJlIGxhenlcblxuICAgICAgaWYgKHRoaXMub25DaGFuZ2UpIHtcbiAgICAgICAgLy8gQ29tcHV0ZSBjaGFuZ2VkIHZhbHVlc1xuICAgICAgICB2YXIgY2hhbmdlcyA9IHtcbiAgICAgICAgICBoOiBmYWxzZSxcbiAgICAgICAgICB2OiBmYWxzZSxcbiAgICAgICAgICBzOiBmYWxzZSxcbiAgICAgICAgICBhOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgIGNoYW5nZXNba2V5XSA9IG5ld1ZhbHVlW2tleV0gIT0gb2xkVmFsdWVba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuJCA9IG5ld1ZhbHVlOyAvLyBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGNhbGwgaG9vayBjYWxsYmFja1xuXG4gICAgICAgIGlmIChjaGFuZ2VzLmggfHwgY2hhbmdlcy5zIHx8IGNoYW5nZXMudiB8fCBjaGFuZ2VzLmEpIHsgdGhpcy5vbkNoYW5nZSh0aGlzLCBjaGFuZ2VzKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhzdmFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdGhpcy4kKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmhzdiA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJodWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiQuaDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmhzdiA9IHtcbiAgICAgICAgaDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdHVyYXRpb25cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiQucztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmhzdiA9IHtcbiAgICAgICAgczogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kLnY7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5oc3YgPSB7XG4gICAgICAgIHY6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbHBoYVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJC5hO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaHN2ID0gX2V4dGVuZHMoe30sIHRoaXMuaHN2LCB7XG4gICAgICAgIGE6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2VsdmluXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSXJvQ29sb3IucmdiVG9LZWx2aW4odGhpcy5yZ2IpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmdiID0gSXJvQ29sb3Iua2VsdmluVG9SZ2IodmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByZ2IgPSB0aGlzLnJnYjtcbiAgICAgIHJldHVybiByZ2IucjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnJnYiA9IF9leHRlbmRzKHt9LCB0aGlzLnJnYiwge1xuICAgICAgICByOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyZWVuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy5yZ2I7XG4gICAgICByZXR1cm4gcmdiLmc7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5yZ2IgPSBfZXh0ZW5kcyh7fSwgdGhpcy5yZ2IsIHtcbiAgICAgICAgZzogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibHVlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmdiID0gdGhpcy5yZ2I7XG4gICAgICByZXR1cm4gcmdiLmI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5yZ2IgPSBfZXh0ZW5kcyh7fSwgdGhpcy5yZ2IsIHtcbiAgICAgICAgYjogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZ2JcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBfSXJvQ29sb3IkaHN2VG9SZ2IgPSBJcm9Db2xvci5oc3ZUb1JnYih0aGlzLiQpLFxuICAgICAgICAgIHIgPSBfSXJvQ29sb3IkaHN2VG9SZ2IucixcbiAgICAgICAgICBnID0gX0lyb0NvbG9yJGhzdlRvUmdiLmcsXG4gICAgICAgICAgYiA9IF9Jcm9Db2xvciRoc3ZUb1JnYi5iO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiByb3VuZChyKSxcbiAgICAgICAgZzogcm91bmQoZyksXG4gICAgICAgIGI6IHJvdW5kKGIpXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaHN2ID0gX2V4dGVuZHMoe30sIElyb0NvbG9yLnJnYlRvSHN2KHZhbHVlKSwge1xuICAgICAgICBhOiB2YWx1ZS5hID09PSB1bmRlZmluZWQgPyAxIDogdmFsdWUuYVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJnYmFcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgdGhpcy5yZ2IsIHtcbiAgICAgICAgYTogdGhpcy5hbHBoYVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdGhpcy5yZ2IgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaHNsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX0lyb0NvbG9yJGhzdlRvSHNsID0gSXJvQ29sb3IuaHN2VG9Ic2wodGhpcy4kKSxcbiAgICAgICAgICBoID0gX0lyb0NvbG9yJGhzdlRvSHNsLmgsXG4gICAgICAgICAgcyA9IF9Jcm9Db2xvciRoc3ZUb0hzbC5zLFxuICAgICAgICAgIGwgPSBfSXJvQ29sb3IkaHN2VG9Ic2wubDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaDogcm91bmQoaCksXG4gICAgICAgIHM6IHJvdW5kKHMpLFxuICAgICAgICBsOiByb3VuZChsKVxuICAgICAgfTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLmhzdiA9IF9leHRlbmRzKHt9LCBJcm9Db2xvci5oc2xUb0hzdih2YWx1ZSksIHtcbiAgICAgICAgYTogdmFsdWUuYSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlLmFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoc2xhXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHRoaXMuaHNsLCB7XG4gICAgICAgIGE6IHRoaXMuYWxwaGFcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaHNsID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJnYlN0cmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJnYiA9IHRoaXMucmdiO1xuICAgICAgcmV0dXJuIFwicmdiKFwiICsgcmdiLnIgKyBcIiwgXCIgKyByZ2IuZyArIFwiLCBcIiArIHJnYi5iICsgXCIpXCI7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIG1hdGNoO1xuICAgICAgdmFyIHIsXG4gICAgICAgICAgZyxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGEgPSAxO1xuXG4gICAgICBpZiAobWF0Y2ggPSBSRUdFWF9GVU5DVElPTkFMX1JHQi5leGVjKHZhbHVlKSkge1xuICAgICAgICByID0gcGFyc2VVbml0KG1hdGNoWzFdLCAyNTUpO1xuICAgICAgICBnID0gcGFyc2VVbml0KG1hdGNoWzJdLCAyNTUpO1xuICAgICAgICBiID0gcGFyc2VVbml0KG1hdGNoWzNdLCAyNTUpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IFJFR0VYX0ZVTkNUSU9OQUxfUkdCQS5leGVjKHZhbHVlKSkge1xuICAgICAgICByID0gcGFyc2VVbml0KG1hdGNoWzFdLCAyNTUpO1xuICAgICAgICBnID0gcGFyc2VVbml0KG1hdGNoWzJdLCAyNTUpO1xuICAgICAgICBiID0gcGFyc2VVbml0KG1hdGNoWzNdLCAyNTUpO1xuICAgICAgICBhID0gcGFyc2VVbml0KG1hdGNoWzRdLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRoaXMucmdiID0ge1xuICAgICAgICAgIHI6IHIsXG4gICAgICAgICAgZzogZyxcbiAgICAgICAgICBiOiBiLFxuICAgICAgICAgIGE6IGFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZ2Igc3RyaW5nJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJnYmFTdHJpbmdcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciByZ2JhID0gdGhpcy5yZ2JhO1xuICAgICAgcmV0dXJuIFwicmdiYShcIiArIHJnYmEuciArIFwiLCBcIiArIHJnYmEuZyArIFwiLCBcIiArIHJnYmEuYiArIFwiLCBcIiArIHJnYmEuYSArIFwiKVwiO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucmdiU3RyaW5nID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhleFN0cmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHJnYiA9IHRoaXMucmdiO1xuICAgICAgcmV0dXJuIFwiI1wiICsgaW50VG9IZXgocmdiLnIpICsgaW50VG9IZXgocmdiLmcpICsgaW50VG9IZXgocmdiLmIpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciByLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgYixcbiAgICAgICAgICBhID0gMjU1O1xuXG4gICAgICBpZiAobWF0Y2ggPSBSRUdFWF9IRVhfMy5leGVjKHZhbHVlKSkge1xuICAgICAgICByID0gcGFyc2VIZXhJbnQobWF0Y2hbMV0pICogMTc7XG4gICAgICAgIGcgPSBwYXJzZUhleEludChtYXRjaFsyXSkgKiAxNztcbiAgICAgICAgYiA9IHBhcnNlSGV4SW50KG1hdGNoWzNdKSAqIDE3O1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IFJFR0VYX0hFWF80LmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHIgPSBwYXJzZUhleEludChtYXRjaFsxXSkgKiAxNztcbiAgICAgICAgZyA9IHBhcnNlSGV4SW50KG1hdGNoWzJdKSAqIDE3O1xuICAgICAgICBiID0gcGFyc2VIZXhJbnQobWF0Y2hbM10pICogMTc7XG4gICAgICAgIGEgPSBwYXJzZUhleEludChtYXRjaFs0XSkgKiAxNztcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBSRUdFWF9IRVhfNi5leGVjKHZhbHVlKSkge1xuICAgICAgICByID0gcGFyc2VIZXhJbnQobWF0Y2hbMV0pO1xuICAgICAgICBnID0gcGFyc2VIZXhJbnQobWF0Y2hbMl0pO1xuICAgICAgICBiID0gcGFyc2VIZXhJbnQobWF0Y2hbM10pO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IFJFR0VYX0hFWF84LmV4ZWModmFsdWUpKSB7XG4gICAgICAgIHIgPSBwYXJzZUhleEludChtYXRjaFsxXSk7XG4gICAgICAgIGcgPSBwYXJzZUhleEludChtYXRjaFsyXSk7XG4gICAgICAgIGIgPSBwYXJzZUhleEludChtYXRjaFszXSk7XG4gICAgICAgIGEgPSBwYXJzZUhleEludChtYXRjaFs0XSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLnJnYiA9IHtcbiAgICAgICAgICByOiByLFxuICAgICAgICAgIGc6IGcsXG4gICAgICAgICAgYjogYixcbiAgICAgICAgICBhOiBhIC8gMjU1XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZXg4U3RyaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcmdiYSA9IHRoaXMucmdiYTtcbiAgICAgIHJldHVybiBcIiNcIiArIGludFRvSGV4KHJnYmEucikgKyBpbnRUb0hleChyZ2JhLmcpICsgaW50VG9IZXgocmdiYS5iKSArIGludFRvSGV4KGZsb29yKHJnYmEuYSAqIDI1NSkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaGV4U3RyaW5nID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhzbFN0cmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGhzbCA9IHRoaXMuaHNsO1xuICAgICAgcmV0dXJuIFwiaHNsKFwiICsgaHNsLmggKyBcIiwgXCIgKyBoc2wucyArIFwiJSwgXCIgKyBoc2wubCArIFwiJSlcIjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB2YXIgaCxcbiAgICAgICAgICBzLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYSA9IDE7XG5cbiAgICAgIGlmIChtYXRjaCA9IFJFR0VYX0ZVTkNUSU9OQUxfSFNMLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIGggPSBwYXJzZVVuaXQobWF0Y2hbMV0sIDM2MCk7XG4gICAgICAgIHMgPSBwYXJzZVVuaXQobWF0Y2hbMl0sIDEwMCk7XG4gICAgICAgIGwgPSBwYXJzZVVuaXQobWF0Y2hbM10sIDEwMCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoID0gUkVHRVhfRlVOQ1RJT05BTF9IU0xBLmV4ZWModmFsdWUpKSB7XG4gICAgICAgIGggPSBwYXJzZVVuaXQobWF0Y2hbMV0sIDM2MCk7XG4gICAgICAgIHMgPSBwYXJzZVVuaXQobWF0Y2hbMl0sIDEwMCk7XG4gICAgICAgIGwgPSBwYXJzZVVuaXQobWF0Y2hbM10sIDEwMCk7XG4gICAgICAgIGEgPSBwYXJzZVVuaXQobWF0Y2hbNF0sIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdGhpcy5oc2wgPSB7XG4gICAgICAgICAgaDogaCxcbiAgICAgICAgICBzOiBzLFxuICAgICAgICAgIGw6IGwsXG4gICAgICAgICAgYTogYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhzbCBzdHJpbmcnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaHNsYVN0cmluZ1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGhzbGEgPSB0aGlzLmhzbGE7XG4gICAgICByZXR1cm4gXCJoc2woXCIgKyBoc2xhLmggKyBcIiwgXCIgKyBoc2xhLnMgKyBcIiUsIFwiICsgaHNsYS5sICsgXCIlLCBcIiArIGhzbGEuYSArIFwiKVwiO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMuaHNsU3RyaW5nID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIElyb0NvbG9yO1xufSgpO1xuXG52YXIgc2xpZGVyRGVmYXVsdE9wdGlvbnMgPSB7XG4gIHNsaWRlclNoYXBlOiAnYmFyJyxcbiAgc2xpZGVyVHlwZTogJ3ZhbHVlJyxcbiAgbWluVGVtcGVyYXR1cmU6IDIyMDAsXG4gIG1heFRlbXBlcmF0dXJlOiAxMTAwMFxufTtcbi8qKlxyXG4gKiBAZGVzYyBHZXQgdGhlIGJvdW5kaW5nIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlclxyXG4gKiBAcGFyYW0gcHJvcHMgLSBzbGlkZXIgcHJvcHNcclxuICovXG5cbmZ1bmN0aW9uIGdldFNsaWRlckRpbWVuc2lvbnMocHJvcHMpIHtcbiAgdmFyIF9zbGlkZXJTaXplO1xuXG4gIHZhciB3aWR0aCA9IHByb3BzLndpZHRoLFxuICAgICAgc2xpZGVyU2l6ZSA9IHByb3BzLnNsaWRlclNpemUsXG4gICAgICBib3JkZXJXaWR0aCA9IHByb3BzLmJvcmRlcldpZHRoLFxuICAgICAgaGFuZGxlUmFkaXVzID0gcHJvcHMuaGFuZGxlUmFkaXVzLFxuICAgICAgcGFkZGluZyA9IHByb3BzLnBhZGRpbmcsXG4gICAgICBzbGlkZXJTaGFwZSA9IHByb3BzLnNsaWRlclNoYXBlO1xuICB2YXIgaXNob3Jpem9udGFsID0gcHJvcHMubGF5b3V0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7IC8vIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlIHNsaWRlclNpemUgaWYgaXRzIG5vdCBkZWZpbmVkXG5cbiAgc2xpZGVyU2l6ZSA9IChfc2xpZGVyU2l6ZSA9IHNsaWRlclNpemUpICE9IG51bGwgPyBfc2xpZGVyU2l6ZSA6IHBhZGRpbmcgKiAyICsgaGFuZGxlUmFkaXVzICogMjtcblxuICBpZiAoc2xpZGVyU2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZVN0YXJ0OiBwcm9wcy5wYWRkaW5nICsgcHJvcHMuaGFuZGxlUmFkaXVzLFxuICAgICAgaGFuZGxlUmFuZ2U6IHdpZHRoIC0gcGFkZGluZyAqIDIgLSBoYW5kbGVSYWRpdXMgKiAyLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiB3aWR0aCxcbiAgICAgIGN4OiB3aWR0aCAvIDIsXG4gICAgICBjeTogd2lkdGggLyAyLFxuICAgICAgcmFkaXVzOiB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGVTdGFydDogc2xpZGVyU2l6ZSAvIDIsXG4gICAgICBoYW5kbGVSYW5nZTogd2lkdGggLSBzbGlkZXJTaXplLFxuICAgICAgcmFkaXVzOiBzbGlkZXJTaXplIC8gMixcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGlzaG9yaXpvbnRhbCA/IHNsaWRlclNpemUgOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaXNob3Jpem9udGFsID8gd2lkdGggOiBzbGlkZXJTaXplXG4gICAgfTtcbiAgfVxufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgY3VycmVudCBzbGlkZXIgdmFsdWUgZm9yIGEgZ2l2ZW4gY29sb3IsIGFzIGEgcGVyY2VudGFnZVxyXG4gKiBAcGFyYW0gcHJvcHMgLSBzbGlkZXIgcHJvcHNcclxuICogQHBhcmFtIGNvbG9yXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2xpZGVyVmFsdWUocHJvcHMsIGNvbG9yKSB7XG4gIHZhciBoc3ZhID0gY29sb3IuaHN2YTtcbiAgdmFyIHJnYiA9IGNvbG9yLnJnYjtcblxuICBzd2l0Y2ggKHByb3BzLnNsaWRlclR5cGUpIHtcbiAgICBjYXNlICdyZWQnOlxuICAgICAgcmV0dXJuIHJnYi5yIC8gMi41NTtcblxuICAgIGNhc2UgJ2dyZWVuJzpcbiAgICAgIHJldHVybiByZ2IuZyAvIDIuNTU7XG5cbiAgICBjYXNlICdibHVlJzpcbiAgICAgIHJldHVybiByZ2IuYiAvIDIuNTU7XG5cbiAgICBjYXNlICdhbHBoYSc6XG4gICAgICByZXR1cm4gaHN2YS5hICogMTAwO1xuXG4gICAgY2FzZSAna2VsdmluJzpcbiAgICAgIHZhciBtaW5UZW1wZXJhdHVyZSA9IHByb3BzLm1pblRlbXBlcmF0dXJlLFxuICAgICAgICAgIG1heFRlbXBlcmF0dXJlID0gcHJvcHMubWF4VGVtcGVyYXR1cmU7XG4gICAgICB2YXIgdGVtcGVyYXR1cmVSYW5nZSA9IG1heFRlbXBlcmF0dXJlIC0gbWluVGVtcGVyYXR1cmU7XG4gICAgICB2YXIgcGVyY2VudCA9IChjb2xvci5rZWx2aW4gLSBtaW5UZW1wZXJhdHVyZSkgLyB0ZW1wZXJhdHVyZVJhbmdlICogMTAwOyAvLyBjbG1hcCBwZXJjZW50YWdlXG5cbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihwZXJjZW50LCAxMDApKTtcblxuICAgIGNhc2UgJ2h1ZSc6XG4gICAgICByZXR1cm4gaHN2YS5oIC89IDMuNjtcblxuICAgIGNhc2UgJ3NhdHVyYXRpb24nOlxuICAgICAgcmV0dXJuIGhzdmEucztcblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGhzdmEudjtcbiAgfVxufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgY3VycmVudCBzbGlkZXIgdmFsdWUgZnJvbSB1c2VyIGlucHV0XHJcbiAqIEBwYXJhbSBwcm9wcyAtIHNsaWRlciBwcm9wc1xyXG4gKiBAcGFyYW0geCAtIGdsb2JhbCBpbnB1dCB4IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB5IC0gZ2xvYmFsIGlucHV0IHkgcG9zaXRpb25cclxuICovXG5cbmZ1bmN0aW9uIGdldFNsaWRlclZhbHVlRnJvbUlucHV0KHByb3BzLCB4LCB5KSB7XG4gIHZhciBfZ2V0U2xpZGVyRGltZW5zaW9ucyA9IGdldFNsaWRlckRpbWVuc2lvbnMocHJvcHMpLFxuICAgICAgaGFuZGxlUmFuZ2UgPSBfZ2V0U2xpZGVyRGltZW5zaW9ucy5oYW5kbGVSYW5nZSxcbiAgICAgIGhhbmRsZVN0YXJ0ID0gX2dldFNsaWRlckRpbWVuc2lvbnMuaGFuZGxlU3RhcnQ7XG5cbiAgdmFyIGhhbmRsZVBvcztcblxuICBpZiAocHJvcHMubGF5b3V0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICBoYW5kbGVQb3MgPSAtMSAqIHkgKyBoYW5kbGVSYW5nZSArIGhhbmRsZVN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZVBvcyA9IHggLSBoYW5kbGVTdGFydDtcbiAgfSAvLyBjbGFtcCBoYW5kbGUgcG9zaXRpb25cblxuXG4gIGhhbmRsZVBvcyA9IE1hdGgubWF4KE1hdGgubWluKGhhbmRsZVBvcywgaGFuZGxlUmFuZ2UpLCAwKTtcbiAgdmFyIHBlcmNlbnQgPSBNYXRoLnJvdW5kKDEwMCAvIGhhbmRsZVJhbmdlICogaGFuZGxlUG9zKTtcblxuICBzd2l0Y2ggKHByb3BzLnNsaWRlclR5cGUpIHtcbiAgICBjYXNlICdrZWx2aW4nOlxuICAgICAgdmFyIG1pblRlbXBlcmF0dXJlID0gcHJvcHMubWluVGVtcGVyYXR1cmUsXG4gICAgICAgICAgbWF4VGVtcGVyYXR1cmUgPSBwcm9wcy5tYXhUZW1wZXJhdHVyZTtcbiAgICAgIHZhciB0ZW1wZXJhdHVyZVJhbmdlID0gbWF4VGVtcGVyYXR1cmUgLSBtaW5UZW1wZXJhdHVyZTtcbiAgICAgIHJldHVybiBtaW5UZW1wZXJhdHVyZSArIHRlbXBlcmF0dXJlUmFuZ2UgKiAocGVyY2VudCAvIDEwMCk7XG5cbiAgICBjYXNlICdhbHBoYSc6XG4gICAgICByZXR1cm4gcGVyY2VudCAvIDEwMDtcblxuICAgIGNhc2UgJ2h1ZSc6XG4gICAgICByZXR1cm4gcGVyY2VudCAqIDMuNjtcblxuICAgIGNhc2UgJ3JlZCc6XG4gICAgY2FzZSAnYmx1ZSc6XG4gICAgY2FzZSAnZ3JlZW4nOlxuICAgICAgcmV0dXJuIHBlcmNlbnQgKiAyLjU1O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwZXJjZW50O1xuICB9XG59XG4vKipcclxuICogQGRlc2MgR2V0IHRoZSBjdXJyZW50IGhhbmRsZSBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjb2xvclxyXG4gKiBAcGFyYW0gcHJvcHMgLSBzbGlkZXIgcHJvcHNcclxuICogQHBhcmFtIGNvbG9yXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRTbGlkZXJIYW5kbGVQb3NpdGlvbihwcm9wcywgY29sb3IpIHtcbiAgdmFyIF9nZXRTbGlkZXJEaW1lbnNpb25zMiA9IGdldFNsaWRlckRpbWVuc2lvbnMocHJvcHMpLFxuICAgICAgd2lkdGggPSBfZ2V0U2xpZGVyRGltZW5zaW9uczIud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfZ2V0U2xpZGVyRGltZW5zaW9uczIuaGVpZ2h0LFxuICAgICAgaGFuZGxlUmFuZ2UgPSBfZ2V0U2xpZGVyRGltZW5zaW9uczIuaGFuZGxlUmFuZ2UsXG4gICAgICBoYW5kbGVTdGFydCA9IF9nZXRTbGlkZXJEaW1lbnNpb25zMi5oYW5kbGVTdGFydDtcblxuICB2YXIgaXNob3Jpem9udGFsID0gcHJvcHMubGF5b3V0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XG4gIHZhciBzbGlkZXJWYWx1ZSA9IGdldEN1cnJlbnRTbGlkZXJWYWx1ZShwcm9wcywgY29sb3IpO1xuICB2YXIgbWlkUG9pbnQgPSBpc2hvcml6b250YWwgPyB3aWR0aCAvIDIgOiBoZWlnaHQgLyAyO1xuICB2YXIgaGFuZGxlUG9zID0gaGFuZGxlU3RhcnQgKyBzbGlkZXJWYWx1ZSAvIDEwMCAqIGhhbmRsZVJhbmdlO1xuXG4gIGlmIChpc2hvcml6b250YWwpIHtcbiAgICBoYW5kbGVQb3MgPSAtMSAqIGhhbmRsZVBvcyArIGhhbmRsZVJhbmdlICsgaGFuZGxlU3RhcnQgKiAyO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBpc2hvcml6b250YWwgPyBtaWRQb2ludCA6IGhhbmRsZVBvcyxcbiAgICB5OiBpc2hvcml6b250YWwgPyBoYW5kbGVQb3MgOiBtaWRQb2ludFxuICB9O1xufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgZ3JhZGllbnQgc3RvcHMgZm9yIGEgc2xpZGVyXHJcbiAqIEBwYXJhbSBwcm9wcyAtIHNsaWRlciBwcm9wc1xyXG4gKiBAcGFyYW0gY29sb3JcclxuICovXG5cbmZ1bmN0aW9uIGdldFNsaWRlckdyYWRpZW50KHByb3BzLCBjb2xvcikge1xuICB2YXIgaHN2ID0gY29sb3IuaHN2O1xuICB2YXIgcmdiID0gY29sb3IucmdiO1xuXG4gIHN3aXRjaCAocHJvcHMuc2xpZGVyVHlwZSkge1xuICAgIGNhc2UgJ3JlZCc6XG4gICAgICByZXR1cm4gW1swLCBcInJnYihcIiArIDAgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiXSwgWzEwMCwgXCJyZ2IoXCIgKyAyNTUgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiXV07XG5cbiAgICBjYXNlICdncmVlbic6XG4gICAgICByZXR1cm4gW1swLCBcInJnYihcIiArIHJnYi5yICsgXCIsXCIgKyAwICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiXSwgWzEwMCwgXCJyZ2IoXCIgKyByZ2IuciArIFwiLFwiICsgMjU1ICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiXV07XG5cbiAgICBjYXNlICdibHVlJzpcbiAgICAgIHJldHVybiBbWzAsIFwicmdiKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyAwICsgXCIpXCJdLCBbMTAwLCBcInJnYihcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgMjU1ICsgXCIpXCJdXTtcblxuICAgIGNhc2UgJ2FscGhhJzpcbiAgICAgIHJldHVybiBbWzAsIFwicmdiYShcIiArIHJnYi5yICsgXCIsXCIgKyByZ2IuZyArIFwiLFwiICsgcmdiLmIgKyBcIiwwKVwiXSwgWzEwMCwgXCJyZ2IoXCIgKyByZ2IuciArIFwiLFwiICsgcmdiLmcgKyBcIixcIiArIHJnYi5iICsgXCIpXCJdXTtcblxuICAgIGNhc2UgJ2tlbHZpbic6XG4gICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgIHZhciBtaW4gPSBwcm9wcy5taW5UZW1wZXJhdHVyZTtcbiAgICAgIHZhciBtYXggPSBwcm9wcy5tYXhUZW1wZXJhdHVyZTtcbiAgICAgIHZhciBudW1TdG9wcyA9IDg7XG4gICAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG5cbiAgICAgIGZvciAodmFyIGtlbHZpbiA9IG1pbiwgc3RvcCA9IDA7IGtlbHZpbiA8IG1heDsga2VsdmluICs9IHJhbmdlIC8gbnVtU3RvcHMsIHN0b3AgKz0gMSkge1xuICAgICAgICB2YXIgX0lyb0NvbG9yJGtlbHZpblRvUmdiID0gSXJvQ29sb3Iua2VsdmluVG9SZ2Ioa2VsdmluKSxcbiAgICAgICAgICAgIHIgPSBfSXJvQ29sb3Ika2VsdmluVG9SZ2IucixcbiAgICAgICAgICAgIGcgPSBfSXJvQ29sb3Ika2VsdmluVG9SZ2IuZyxcbiAgICAgICAgICAgIGIgPSBfSXJvQ29sb3Ika2VsdmluVG9SZ2IuYjtcblxuICAgICAgICBzdG9wcy5wdXNoKFsxMDAgLyBudW1TdG9wcyAqIHN0b3AsIFwicmdiKFwiICsgciArIFwiLFwiICsgZyArIFwiLFwiICsgYiArIFwiKVwiXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdG9wcztcblxuICAgIGNhc2UgJ2h1ZSc6XG4gICAgICByZXR1cm4gW1swLCAnI2YwMCddLCBbMTYuNjY2LCAnI2ZmMCddLCBbMzMuMzMzLCAnIzBmMCddLCBbNTAsICcjMGZmJ10sIFs2Ni42NjYsICcjMDBmJ10sIFs4My4zMzMsICcjZjBmJ10sIFsxMDAsICcjZjAwJ11dO1xuXG4gICAgY2FzZSAnc2F0dXJhdGlvbic6XG4gICAgICB2YXIgbm9TYXQgPSBJcm9Db2xvci5oc3ZUb0hzbCh7XG4gICAgICAgIGg6IGhzdi5oLFxuICAgICAgICBzOiAwLFxuICAgICAgICB2OiBoc3YudlxuICAgICAgfSk7XG4gICAgICB2YXIgZnVsbFNhdCA9IElyb0NvbG9yLmhzdlRvSHNsKHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IDEwMCxcbiAgICAgICAgdjogaHN2LnZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtbMCwgXCJoc2woXCIgKyBub1NhdC5oICsgXCIsXCIgKyBub1NhdC5zICsgXCIlLFwiICsgbm9TYXQubCArIFwiJSlcIl0sIFsxMDAsIFwiaHNsKFwiICsgZnVsbFNhdC5oICsgXCIsXCIgKyBmdWxsU2F0LnMgKyBcIiUsXCIgKyBmdWxsU2F0LmwgKyBcIiUpXCJdXTtcblxuICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGhzbCA9IElyb0NvbG9yLmhzdlRvSHNsKHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IGhzdi5zLFxuICAgICAgICB2OiAxMDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFtbMCwgJyMwMDAnXSwgWzEwMCwgXCJoc2woXCIgKyBoc2wuaCArIFwiLFwiICsgaHNsLnMgKyBcIiUsXCIgKyBoc2wubCArIFwiJSlcIl1dO1xuICB9XG59XG5cbnZhciBUQVUgPSBNYXRoLlBJICogMjsgLy8gamF2YXNjcmlwdCdzIG1vZHVsbyBvcGVyYXRvciBkb2Vzbid0IHByb2R1Y2UgcG9zaXRpdmUgbnVtYmVycyB3aXRoIG5lZ2F0aXZlIGlucHV0XG4vLyBodHRwczovL2Rldi50by9tYXVyb2JyaW5nb2xmL2EtbmVhdC10cmljay10by1jb21wdXRlLW1vZHVsby1vZi1uZWdhdGl2ZS1udW1iZXJzLTExMWVcblxudmFyIG1vZCA9IGZ1bmN0aW9uIG1vZChhLCBuKSB7XG4gIHJldHVybiAoYSAlIG4gKyBuKSAlIG47XG59OyAvLyBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyAoeCwgeSkgYW5kICgwLCAwKVxuXG5cbnZhciBkaXN0ID0gZnVuY3Rpb24gZGlzdCh4LCB5KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG59O1xuLyoqXHJcbiAqIEBwYXJhbSBwcm9wcyAtIHdoZWVsIHByb3BzXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIYW5kbGVSYW5nZShwcm9wcykge1xuICByZXR1cm4gcHJvcHMud2lkdGggLyAyIC0gcHJvcHMucGFkZGluZyAtIHByb3BzLmhhbmRsZVJhZGl1cyAtIHByb3BzLmJvcmRlcldpZHRoO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBwb2ludCAoeCwgeSkgbGFuZHMgaW5zaWRlIHRoZSB3aGVlbFxyXG4gKiBAcGFyYW0gcHJvcHMgLSB3aGVlbCBwcm9wc1xyXG4gKiBAcGFyYW0geFxyXG4gKiBAcGFyYW0geVxyXG4gKi9cblxuXG5mdW5jdGlvbiBpc0lucHV0SW5zaWRlV2hlZWwocHJvcHMsIHgsIHkpIHtcbiAgdmFyIF9nZXRXaGVlbERpbWVuc2lvbnMgPSBnZXRXaGVlbERpbWVuc2lvbnMocHJvcHMpLFxuICAgICAgY3ggPSBfZ2V0V2hlZWxEaW1lbnNpb25zLmN4LFxuICAgICAgY3kgPSBfZ2V0V2hlZWxEaW1lbnNpb25zLmN5O1xuXG4gIHZhciByID0gcHJvcHMud2lkdGggLyAyO1xuICByZXR1cm4gZGlzdChjeCAtIHgsIGN5IC0geSkgPCByO1xufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgcG9pbnQgYXMgdGhlIGNlbnRlciBvZiB0aGUgd2hlZWxcclxuICogQHBhcmFtIHByb3BzIC0gd2hlZWwgcHJvcHNcclxuICovXG5cbmZ1bmN0aW9uIGdldFdoZWVsRGltZW5zaW9ucyhwcm9wcykge1xuICB2YXIgciA9IHByb3BzLndpZHRoIC8gMjtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgcmFkaXVzOiByIC0gcHJvcHMuYm9yZGVyV2lkdGgsXG4gICAgY3g6IHIsXG4gICAgY3k6IHJcbiAgfTtcbn1cbi8qKlxyXG4gKiBAZGVzYyBUcmFuc2xhdGUgYW4gYW5nbGUgYWNjb3JkaW5nIHRvIHdoZWVsQW5nbGUgYW5kIHdoZWVsRGlyZWN0aW9uXHJcbiAqIEBwYXJhbSBwcm9wcyAtIHdoZWVsIHByb3BzXHJcbiAqIEBwYXJhbSBhbmdsZSAtIGlucHV0IGFuZ2xlXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVXaGVlbEFuZ2xlKHByb3BzLCBhbmdsZSwgaW52ZXJ0KSB7XG4gIHZhciB3aGVlbEFuZ2xlID0gcHJvcHMud2hlZWxBbmdsZTtcbiAgdmFyIHdoZWVsRGlyZWN0aW9uID0gcHJvcHMud2hlZWxEaXJlY3Rpb247IC8vIGludmVydGVkIGFuZCBjbG9ja3dpc2VlXG5cbiAgaWYgKGludmVydCAmJiB3aGVlbERpcmVjdGlvbiA9PT0gJ2Nsb2Nrd2lzZScpIHsgYW5nbGUgPSB3aGVlbEFuZ2xlICsgYW5nbGU7IH0gLy8gY2xvY2t3aXNlIChpbnB1dCBoYW5kbGluZylcbiAgZWxzZSBpZiAod2hlZWxEaXJlY3Rpb24gPT09ICdjbG9ja3dpc2UnKSB7IGFuZ2xlID0gMzYwIC0gd2hlZWxBbmdsZSArIGFuZ2xlOyB9IC8vIGludmVydGVkIGFuZCBhbnRpY2xvY2t3aXNlXG4gICAgZWxzZSBpZiAoaW52ZXJ0ICYmIHdoZWVsRGlyZWN0aW9uID09PSAnYW50aWNsb2Nrd2lzZScpIHsgYW5nbGUgPSB3aGVlbEFuZ2xlICsgMTgwIC0gYW5nbGU7IH0gLy8gYW50aWNsb2Nrd2lzZSAoaW5wdXQgaGFuZGxpbmcpXG4gICAgICBlbHNlIGlmICh3aGVlbERpcmVjdGlvbiA9PT0gJ2FudGljbG9ja3dpc2UnKSB7IGFuZ2xlID0gd2hlZWxBbmdsZSAtIGFuZ2xlOyB9XG4gIHJldHVybiBtb2QoYW5nbGUsIDM2MCk7XG59XG4vKipcclxuICogQGRlc2MgR2V0IHRoZSBjdXJyZW50IGhhbmRsZSBwb3NpdGlvbiBmb3IgYSBnaXZlbiBjb2xvclxyXG4gKiBAcGFyYW0gcHJvcHMgLSB3aGVlbCBwcm9wc1xyXG4gKiBAcGFyYW0gY29sb3JcclxuICovXG5cbmZ1bmN0aW9uIGdldFdoZWVsSGFuZGxlUG9zaXRpb24ocHJvcHMsIGNvbG9yKSB7XG4gIHZhciBoc3YgPSBjb2xvci5oc3Y7XG5cbiAgdmFyIF9nZXRXaGVlbERpbWVuc2lvbnMyID0gZ2V0V2hlZWxEaW1lbnNpb25zKHByb3BzKSxcbiAgICAgIGN4ID0gX2dldFdoZWVsRGltZW5zaW9uczIuY3gsXG4gICAgICBjeSA9IF9nZXRXaGVlbERpbWVuc2lvbnMyLmN5O1xuXG4gIHZhciBoYW5kbGVSYW5nZSA9IGdldEhhbmRsZVJhbmdlKHByb3BzKTtcbiAgdmFyIGhhbmRsZUFuZ2xlID0gKDE4MCArIHRyYW5zbGF0ZVdoZWVsQW5nbGUocHJvcHMsIGhzdi5oLCB0cnVlKSkgKiAoVEFVIC8gMzYwKTtcbiAgdmFyIGhhbmRsZURpc3QgPSBoc3YucyAvIDEwMCAqIGhhbmRsZVJhbmdlO1xuICB2YXIgZGlyZWN0aW9uID0gcHJvcHMud2hlZWxEaXJlY3Rpb24gPT09ICdjbG9ja3dpc2UnID8gLTEgOiAxO1xuICByZXR1cm4ge1xuICAgIHg6IGN4ICsgaGFuZGxlRGlzdCAqIE1hdGguY29zKGhhbmRsZUFuZ2xlKSAqIGRpcmVjdGlvbixcbiAgICB5OiBjeSArIGhhbmRsZURpc3QgKiBNYXRoLnNpbihoYW5kbGVBbmdsZSkgKiBkaXJlY3Rpb25cbiAgfTtcbn1cbi8qKlxyXG4gKiBAZGVzYyBHZXQgdGhlIGN1cnJlbnQgd2hlZWwgdmFsdWUgZnJvbSB1c2VyIGlucHV0XHJcbiAqIEBwYXJhbSBwcm9wcyAtIHdoZWVsIHByb3BzXHJcbiAqIEBwYXJhbSB4IC0gZ2xvYmFsIGlucHV0IHggcG9zaXRpb25cclxuICogQHBhcmFtIHkgLSBnbG9iYWwgaW5wdXQgeSBwb3NpdGlvblxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0V2hlZWxWYWx1ZUZyb21JbnB1dChwcm9wcywgeCwgeSkge1xuICB2YXIgX2dldFdoZWVsRGltZW5zaW9uczMgPSBnZXRXaGVlbERpbWVuc2lvbnMocHJvcHMpLFxuICAgICAgY3ggPSBfZ2V0V2hlZWxEaW1lbnNpb25zMy5jeCxcbiAgICAgIGN5ID0gX2dldFdoZWVsRGltZW5zaW9uczMuY3k7XG5cbiAgdmFyIGhhbmRsZVJhbmdlID0gZ2V0SGFuZGxlUmFuZ2UocHJvcHMpO1xuICB4ID0gY3ggLSB4O1xuICB5ID0gY3kgLSB5OyAvLyBDYWxjdWxhdGUgdGhlIGh1ZSBieSBjb252ZXJ0aW5nIHRoZSBhbmdsZSB0byByYWRpYW5zXG5cbiAgdmFyIGh1ZSA9IHRyYW5zbGF0ZVdoZWVsQW5nbGUocHJvcHMsIE1hdGguYXRhbjIoLXksIC14KSAqICgzNjAgLyBUQVUpKTsgLy8gRmluZCB0aGUgcG9pbnQncyBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHdoZWVsXG4gIC8vIFRoaXMgaXMgdXNlZCB0byBzaG93IHRoZSBzYXR1cmF0aW9uIGxldmVsXG5cbiAgdmFyIGhhbmRsZURpc3QgPSBNYXRoLm1pbihkaXN0KHgsIHkpLCBoYW5kbGVSYW5nZSk7XG4gIHJldHVybiB7XG4gICAgaDogTWF0aC5yb3VuZChodWUpLFxuICAgIHM6IE1hdGgucm91bmQoMTAwIC8gaGFuZGxlUmFuZ2UgKiBoYW5kbGVEaXN0KVxuICB9O1xufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgYm91bmRpbmcgZGltZW5zaW9ucyBvZiB0aGUgYm94XHJcbiAqIEBwYXJhbSBwcm9wcyAtIGJveCBwcm9wc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm94RGltZW5zaW9ucyhwcm9wcykge1xuICB2YXIgd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIGJveEhlaWdodCA9IHByb3BzLmJveEhlaWdodCxcbiAgICAgIHBhZGRpbmcgPSBwcm9wcy5wYWRkaW5nLFxuICAgICAgaGFuZGxlUmFkaXVzID0gcHJvcHMuaGFuZGxlUmFkaXVzO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGJveEhlaWdodCAhPSBudWxsID8gYm94SGVpZ2h0IDogd2lkdGgsXG4gICAgcmFkaXVzOiBwYWRkaW5nICsgaGFuZGxlUmFkaXVzXG4gIH07XG59XG4vKipcclxuICogQGRlc2MgR2V0IHRoZSBjdXJyZW50IGJveCB2YWx1ZSBmcm9tIHVzZXIgaW5wdXRcclxuICogQHBhcmFtIHByb3BzIC0gYm94IHByb3BzXHJcbiAqIEBwYXJhbSB4IC0gZ2xvYmFsIGlucHV0IHggcG9zaXRpb25cclxuICogQHBhcmFtIHkgLSBnbG9iYWwgaW5wdXQgeSBwb3NpdGlvblxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm94VmFsdWVGcm9tSW5wdXQocHJvcHMsIHgsIHkpIHtcbiAgdmFyIF9nZXRCb3hEaW1lbnNpb25zID0gZ2V0Qm94RGltZW5zaW9ucyhwcm9wcyksXG4gICAgICB3aWR0aCA9IF9nZXRCb3hEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2dldEJveERpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgcmFkaXVzID0gX2dldEJveERpbWVuc2lvbnMucmFkaXVzO1xuXG4gIHZhciBoYW5kbGVTdGFydCA9IHJhZGl1cztcbiAgdmFyIGhhbmRsZVJhbmdlWCA9IHdpZHRoIC0gcmFkaXVzICogMjtcbiAgdmFyIGhhbmRsZVJhbmdlWSA9IGhlaWdodCAtIHJhZGl1cyAqIDI7XG4gIHZhciBwZXJjZW50WCA9ICh4IC0gaGFuZGxlU3RhcnQpIC8gaGFuZGxlUmFuZ2VYICogMTAwO1xuICB2YXIgcGVyY2VudFkgPSAoeSAtIGhhbmRsZVN0YXJ0KSAvIGhhbmRsZVJhbmdlWSAqIDEwMDtcbiAgcmV0dXJuIHtcbiAgICBzOiBNYXRoLm1heCgwLCBNYXRoLm1pbihwZXJjZW50WCwgMTAwKSksXG4gICAgdjogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwIC0gcGVyY2VudFksIDEwMCkpXG4gIH07XG59XG4vKipcclxuICogQGRlc2MgR2V0IHRoZSBjdXJyZW50IGJveCBoYW5kbGUgcG9zaXRpb24gZm9yIGEgZ2l2ZW4gY29sb3JcclxuICogQHBhcmFtIHByb3BzIC0gYm94IHByb3BzXHJcbiAqIEBwYXJhbSBjb2xvclxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm94SGFuZGxlUG9zaXRpb24ocHJvcHMsIGNvbG9yKSB7XG4gIHZhciBfZ2V0Qm94RGltZW5zaW9uczIgPSBnZXRCb3hEaW1lbnNpb25zKHByb3BzKSxcbiAgICAgIHdpZHRoID0gX2dldEJveERpbWVuc2lvbnMyLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX2dldEJveERpbWVuc2lvbnMyLmhlaWdodCxcbiAgICAgIHJhZGl1cyA9IF9nZXRCb3hEaW1lbnNpb25zMi5yYWRpdXM7XG5cbiAgdmFyIGhzdiA9IGNvbG9yLmhzdjtcbiAgdmFyIGhhbmRsZVN0YXJ0ID0gcmFkaXVzO1xuICB2YXIgaGFuZGxlUmFuZ2VYID0gd2lkdGggLSByYWRpdXMgKiAyO1xuICB2YXIgaGFuZGxlUmFuZ2VZID0gaGVpZ2h0IC0gcmFkaXVzICogMjtcbiAgcmV0dXJuIHtcbiAgICB4OiBoYW5kbGVTdGFydCArIGhzdi5zIC8gMTAwICogaGFuZGxlUmFuZ2VYLFxuICAgIHk6IGhhbmRsZVN0YXJ0ICsgKGhhbmRsZVJhbmdlWSAtIGhzdi52IC8gMTAwICogaGFuZGxlUmFuZ2VZKVxuICB9O1xufVxuLyoqXHJcbiAqIEBkZXNjIEdldCB0aGUgZ3JhZGllbnQgc3RvcHMgZm9yIGEgYm94XHJcbiAqIEBwYXJhbSBwcm9wcyAtIGJveCBwcm9wc1xyXG4gKiBAcGFyYW0gY29sb3JcclxuICovXG5cbmZ1bmN0aW9uIGdldEJveEdyYWRpZW50cyhwcm9wcywgY29sb3IpIHtcbiAgdmFyIGh1ZSA9IGNvbG9yLmh1ZTtcbiAgcmV0dXJuIFsvLyBzYXR1cmF0aW9uIGdyYWRpZW50XG4gIFtbMCwgJyNmZmYnXSwgWzEwMCwgXCJoc2woXCIgKyBodWUgKyBcIiwxMDAlLDUwJSlcIl1dLCAvLyBsaWdodG5lc3MgZ3JhZGllbnRcbiAgW1swLCAncmdiYSgwLDAsMCwwKSddLCBbMTAwLCAnIzAwMCddXV07XG59XG5cbi8vIEtlZXAgdHJhY2sgb2YgaHRtbCA8YmFzZT4gZWxlbWVudHMgZm9yIHJlc29sdmVTdmdVcmxcbi8vIGdldEVsZW1lbnRzQnlUYWdOYW1lIHJldHVybnMgYSBsaXZlIEhUTUxDb2xsZWN0aW9uLCB3aGljaCBzdGF5cyBpbiBzeW5jIHdpdGggdGhlIERPTSB0cmVlXG4vLyBTbyBpdCBvbmx5IG5lZWRzIHRvIGJlIGNhbGxlZCBvbmNlXG52YXIgQkFTRV9FTEVNRU5UUztcbi8qKlxyXG4gKiBAZGVzYyBSZXNvbHZlIGFuIFNWRyByZWZlcmVuY2UgVVJMXHJcbiAqIFRoaXMgaXMgcmVxdWlyZWQgdG8gd29yayBhcm91bmQgaG93IFNhZmFyaSBhbmQgaU9TIHdlYnZpZXdzIGhhbmRsZSBncmFkaWVudCBVUkxTIHVuZGVyIGNlcnRhaW4gY29uZGl0aW9uc1xyXG4gKiBJZiBhIHBhZ2UgaXMgdXNpbmcgYSBjbGllbnQtc2lkZSByb3V0aW5nIGxpYnJhcnkgd2hpY2ggbWFrZXMgdXNlIG9mIHRoZSBIVE1MIDxiYXNlPiB0YWcsXHJcbiAqIFNhZmFyaSB3b24ndCBiZSBhYmxlIHRvIHJlbmRlciBTVkcgZ3JhZGllbnRzIHByb3Blcmx5IChhcyB0aGV5IGFyZSByZWZlcmVuY2VkIGJ5IFVSTHMpXHJcbiAqIE1vcmUgaW5mbyBvbiB0aGUgcHJvYmxlbTpcclxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk3NDI4MDUvYW5ndWxhci1hbmQtc3ZnLWZpbHRlcnMvMTk3NTM0MjcjMTk3NTM0MjdcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2phYW1lcy9pcm8uanMvaXNzdWVzLzE4XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qYWFtZXMvaXJvLmpzL2lzc3Vlcy80NVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFhbWVzL2lyby5qcy9wdWxsLzg5XHJcbiAqIEBwcm9wcyB1cmwgLSBTVkcgcmVmZXJlbmNlIFVSTFxyXG4gKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVN2Z1VybCh1cmwpIHtcbiAgaWYgKCFCQVNFX0VMRU1FTlRTKSB7IEJBU0VfRUxFTUVOVFMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpOyB9IC8vIFNuaWZmIHVzZXJhZ2VudCBzdHJpbmcgdG8gY2hlY2sgaWYgdGhlIHVzZXIgaXMgcnVubmluZyBTYWZhcmlcblxuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdCh1YSk7XG4gIHZhciBpc0lvcyA9IC9pUGhvbmV8aVBvZHxpUGFkL2kudGVzdCh1YSk7XG4gIHZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgcmV0dXJuIChpc1NhZmFyaSB8fCBpc0lvcykgJiYgQkFTRV9FTEVNRU5UUy5sZW5ndGggPiAwID8gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0ICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyB1cmwgOiB1cmw7XG59XG4vKipcclxuICogQGRlc2MgR2l2ZW4gYSBzcGVjaWZjICh4LCB5KSBwb3NpdGlvbiwgdGVzdCBpZiB0aGVyZSdzIGEgaGFuZGxlIHRoZXJlIGFuZCByZXR1cm4gaXRzIGluZGV4LCBlbHNlIHJldHVybiBudWxsLlxyXG4gKiAgICAgICBUaGlzIGlzIHVzZWQgZm9yIGNvbXBvbmVudHMgbGlrZSB0aGUgYm94IGFuZCB3aGVlbCB3aGljaCBzdXBwb3J0IG11bHRpcGxlIGhhbmRsZXMgd2hlbiBtdWx0aWNvbG9yIGlzIGFjdGl2ZVxyXG4gKiBAcHJvcHMgeCAtIHBvaW50IHggcG9zaXRpb25cclxuICogQHByb3BzIHkgLSBwb2ludCB5IHBvc2l0aW9uXHJcbiAqIEBwcm9wcyBoYW5kbGVQb3NpdGlvbnMgLSBhcnJheSBvZiB7eCwgeX0gY29vcmRzIGZvciBlYWNoIGhhbmRsZVxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0SGFuZGxlQXRQb2ludChwcm9wcywgeCwgeSwgaGFuZGxlUG9zaXRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlUG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRYID0gaGFuZGxlUG9zaXRpb25zW2ldLnggLSB4O1xuICAgIHZhciBkWSA9IGhhbmRsZVBvc2l0aW9uc1tpXS55IC0geTtcbiAgICB2YXIgZGlzdCA9IE1hdGguc3FydChkWCAqIGRYICsgZFkgKiBkWSk7XG5cbiAgICBpZiAoZGlzdCA8IHByb3BzLmhhbmRsZVJhZGl1cykge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNzc0JvcmRlclN0eWxlcyhwcm9wcykge1xuICByZXR1cm4ge1xuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGJvcmRlcjogcHJvcHMuYm9yZGVyV2lkdGggKyBcInB4IHNvbGlkIFwiICsgcHJvcHMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cbmZ1bmN0aW9uIGNzc0dyYWRpZW50KHR5cGUsIGRpcmVjdGlvbiwgc3RvcHMpIHtcbiAgcmV0dXJuIHR5cGUgKyBcIi1ncmFkaWVudChcIiArIGRpcmVjdGlvbiArIFwiLCBcIiArIHN0b3BzLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBvID0gX3JlZlswXSxcbiAgICAgICAgY29sID0gX3JlZlsxXTtcbiAgICByZXR1cm4gY29sICsgXCIgXCIgKyBvICsgXCIlXCI7XG4gIH0pLmpvaW4oJywnKSArIFwiKVwiO1xufVxuZnVuY3Rpb24gY3NzVmFsdWUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIHZhbHVlOyB9XG4gIHJldHVybiB2YWx1ZSArIFwicHhcIjtcbn1cblxudmFyIGlyb0NvbG9yUGlja2VyT3B0aW9uRGVmYXVsdHMgPSB7XG4gIHdpZHRoOiAzMDAsXG4gIGhlaWdodDogMzAwLFxuICBjb2xvcjogJyNmZmYnLFxuICBjb2xvcnM6IFtdLFxuICBwYWRkaW5nOiA2LFxuICBsYXlvdXREaXJlY3Rpb246ICd2ZXJ0aWNhbCcsXG4gIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBoYW5kbGVSYWRpdXM6IDgsXG4gIGFjdGl2ZUhhbmRsZVJhZGl1czogbnVsbCxcbiAgaGFuZGxlU3ZnOiBudWxsLFxuICBoYW5kbGVQcm9wczoge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9LFxuICB3aGVlbExpZ2h0bmVzczogdHJ1ZSxcbiAgd2hlZWxBbmdsZTogMCxcbiAgd2hlZWxEaXJlY3Rpb246ICdhbnRpY2xvY2t3aXNlJyxcbiAgc2xpZGVyU2l6ZTogbnVsbCxcbiAgc2xpZGVyTWFyZ2luOiAxMixcbiAgYm94SGVpZ2h0OiBudWxsXG59O1xuXG52YXIgU0VDT05EQVJZX0VWRU5UUyA9IFtcIm1vdXNlbW92ZVwiIC8qIE1vdXNlTW92ZSAqLywgXCJ0b3VjaG1vdmVcIiAvKiBUb3VjaE1vdmUgKi8sIFwibW91c2V1cFwiIC8qIE1vdXNlVXAgKi8sIFwidG91Y2hlbmRcIiAvKiBUb3VjaEVuZCAqL107XHJcbi8vIEJhc2UgY29tcG9uZW50IGNsYXNzIGZvciBpcm8gVUkgY29tcG9uZW50c1xyXG4vLyBUaGlzIGV4dGVuZHMgdGhlIFByZWFjdCBjb21wb25lbnQgY2xhc3MgdG8gYWxsb3cgdGhlbSB0byByZWFjdCB0byBtb3VzZS90b3VjaCBpbnB1dCBldmVudHMgYnkgdGhlbXNlbHZlc1xyXG52YXIgSXJvQ29tcG9uZW50V3JhcHBlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIGZ1bmN0aW9uIElyb0NvbXBvbmVudFdyYXBwZXIocHJvcHMpIHtcclxuICAgICAgICBDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcyk7XHJcbiAgICAgICAgLy8gR2VuZXJhdGUgdW5pcXVlIElEIGZvciB0aGUgY29tcG9uZW50XHJcbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzIGZvciBncmFkaWVudHMsIGV0Y1xyXG4gICAgICAgIHRoaXMudWlkID0gKE1hdGgucmFuZG9tKCkgKyAxKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDUpO1xyXG4gICAgfVxuXG4gICAgaWYgKCBDb21wb25lbnQgKSBJcm9Db21wb25lbnRXcmFwcGVyLl9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgICBJcm9Db21wb25lbnRXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlICk7XG4gICAgSXJvQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJcm9Db21wb25lbnRXcmFwcGVyO1xyXG4gICAgSXJvQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyIChwcm9wcykge1xyXG4gICAgICAgIHZhciBldmVudEhhbmRsZXIgPSB0aGlzLmhhbmRsZUV2ZW50LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdmFyIHJvb3RQcm9wcyA9IHtcclxuICAgICAgICAgICAgb25Nb3VzZURvd246IGV2ZW50SGFuZGxlcixcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phYW1lcy9pcm8uanMvaXNzdWVzLzEyNlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8yMTEzI2lzc3VlY29tbWVudC01NTM0MDg3NjdcclxuICAgICAgICAgICAgb250b3VjaHN0YXJ0OiBldmVudEhhbmRsZXIsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gcHJvcHMubGF5b3V0RGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgdmFyIG1hcmdpbiA9IHByb3BzLm1hcmdpbiA9PT0gbnVsbCA/IHByb3BzLnNsaWRlck1hcmdpbiA6IHByb3BzLm1hcmdpbjtcclxuICAgICAgICB2YXIgcm9vdFN0eWxlcyA9IHtcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJyxcclxuICAgICAgICAgICAgZGlzcGxheTogaXNIb3Jpem9udGFsID8gJ2lubGluZS1ibG9jaycgOiAnYmxvY2snXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBmaXJzdCBjb21wb25lbnQgc2hvdWxkbid0IGhhdmUgYW55IG1hcmdpblxyXG4gICAgICAgIGlmIChwcm9wcy5pbmRleCA+IDApIHtcclxuICAgICAgICAgICAgcm9vdFN0eWxlc1tpc0hvcml6b250YWwgPyAnbWFyZ2luTGVmdCcgOiAnbWFyZ2luVG9wJ10gPSBtYXJnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoaChkLCBudWxsLCBwcm9wcy5jaGlsZHJlbih0aGlzLnVpZCwgcm9vdFByb3BzLCByb290U3R5bGVzKSkpO1xyXG4gICAgfTtcclxuICAgIC8vIE1vcmUgaW5mbyBvbiBoYW5kbGVFdmVudDpcclxuICAgIC8vIGh0dHBzOi8vbWVkaXVtLmNvbS9AV2ViUmVmbGVjdGlvbi9kb20taGFuZGxlZXZlbnQtYS1jcm9zcy1wbGF0Zm9ybS1zdGFuZGFyZC1zaW5jZS15ZWFyLTIwMDAtNWJmMTcyODdmZDM4XHJcbiAgICAvLyBUTDtEUiB0aGlzIGxldHMgdXMgaGF2ZSBhIHNpbmdsZSBwb2ludCBvZiBlbnRyeSBmb3IgbXVsdGlwbGUgZXZlbnRzLCBhbmQgd2UgY2FuIGF2b2lkIGNhbGxiYWNrL2JpbmRpbmcgaGVsbFxyXG4gICAgSXJvQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVFdmVudCAoZSkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxyXG4gICAgICAgIHZhciBpbnB1dEhhbmRsZXIgPSB0aGlzLnByb3BzLm9uSW5wdXQ7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBzY3JlZW4gcG9zaXRpb24gb2YgdGhlIGNvbXBvbmVudFxyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmJhc2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgLy8gUHJlZmVjdCBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIC8vIERldGVjdCBpZiB0aGUgZXZlbnQgaXMgYSB0b3VjaCBldmVudCBieSBjaGVja2luZyBpZiBpdCBoYXMgdGhlIGB0b3VjaGVzYCBwcm9wZXJ0eVxyXG4gICAgICAgIC8vIElmIGl0IGlzIGEgdG91Y2ggZXZlbnQsIHVzZSB0aGUgZmlyc3QgdG91Y2ggaW5wdXRcclxuICAgICAgICB2YXIgcG9pbnQgPSBlLnRvdWNoZXMgPyBlLmNoYW5nZWRUb3VjaGVzWzBdIDogZTtcclxuICAgICAgICB2YXIgeCA9IHBvaW50LmNsaWVudFggLSBib3VuZHMubGVmdDtcclxuICAgICAgICB2YXIgeSA9IHBvaW50LmNsaWVudFkgLSBib3VuZHMudG9wO1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIiAvKiBNb3VzZURvd24gKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCIgLyogVG91Y2hTdGFydCAqLzpcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpbnB1dEhhbmRsZXIoeCwgeSwgMCAvKiBTdGFydCAqLyk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFNFQ09OREFSWV9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcyQxLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIiAvKiBNb3VzZU1vdmUgKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIiAvKiBUb3VjaE1vdmUgKi86XHJcbiAgICAgICAgICAgICAgICBpbnB1dEhhbmRsZXIoeCwgeSwgMSAvKiBNb3ZlICovKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW91c2V1cFwiIC8qIE1vdXNlVXAgKi86XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiIC8qIFRvdWNoRW5kICovOlxyXG4gICAgICAgICAgICAgICAgaW5wdXRIYW5kbGVyKHgsIHksIDIgLyogRW5kICovKTtcclxuICAgICAgICAgICAgICAgIFNFQ09OREFSWV9FVkVOVFMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzJDEsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XG5cbiAgICByZXR1cm4gSXJvQ29tcG9uZW50V3JhcHBlcjtcbn0obSkpO1xuXG5mdW5jdGlvbiBJcm9IYW5kbGUocHJvcHMpIHtcclxuICAgIHZhciByYWRpdXMgPSBwcm9wcy5yO1xyXG4gICAgdmFyIHVybCA9IHByb3BzLnVybDtcclxuICAgIHJldHVybiAoaChcInN2Z1wiLCB7IGNsYXNzTmFtZTogKFwiSXJvSGFuZGxlIElyb0hhbmRsZS0tXCIgKyAocHJvcHMuaW5kZXgpICsgXCIgXCIgKyAocHJvcHMuaXNBY3RpdmUgPyAnSXJvSGFuZGxlLS1pc0FjdGl2ZScgOiAnJykpLCBzdHlsZToge1xyXG4gICAgICAgICAgICB0b3A6IGNzc1ZhbHVlKHByb3BzLnkpLFxyXG4gICAgICAgICAgICBsZWZ0OiBjc3NWYWx1ZShwcm9wcy54KSxcclxuICAgICAgICAgICAgd2lkdGg6ICcxcHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcxcHgnLFxyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xyXG4gICAgICAgIH0gfSxcclxuICAgICAgICB1cmwgJiYgKGgoXCJ1c2VcIiwgT2JqZWN0LmFzc2lnbih7IHhsaW5rSHJlZjogcmVzb2x2ZVN2Z1VybCh1cmwpIH0sIHByb3BzLnByb3BzKSkpLFxyXG4gICAgICAgICF1cmwgJiYgKGgoXCJjaXJjbGVcIiwgeyByOiByYWRpdXMsIGZpbGw6IFwibm9uZVwiLCBcInN0cm9rZS13aWR0aFwiOiAyLCBzdHJva2U6IFwiIzAwMFwiIH0pKSxcclxuICAgICAgICAhdXJsICYmIChoKFwiY2lyY2xlXCIsIHsgcjogcmFkaXVzIC0gMiwgZmlsbDogcHJvcHMuZmlsbCwgXCJzdHJva2Utd2lkdGhcIjogMiwgc3Ryb2tlOiBcIiNmZmZcIiB9KSkpKTtcclxufVxyXG5Jcm9IYW5kbGUuZGVmYXVsdFByb3BzID0ge1xyXG4gICAgZmlsbDogJ25vbmUnLFxyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICByOiA4LFxyXG4gICAgdXJsOiBudWxsLFxyXG4gICAgcHJvcHM6IHsgeDogMCwgeTogMCB9XHJcbn07XG5cbmZ1bmN0aW9uIElyb1NsaWRlcihwcm9wcykge1xyXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gcHJvcHMuYWN0aXZlSW5kZXg7XHJcbiAgICB2YXIgYWN0aXZlQ29sb3IgPSAoYWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCAmJiBhY3RpdmVJbmRleCA8IHByb3BzLmNvbG9ycy5sZW5ndGgpID8gcHJvcHMuY29sb3JzW2FjdGl2ZUluZGV4XSA6IHByb3BzLmNvbG9yO1xyXG4gICAgdmFyIHJlZiA9IGdldFNsaWRlckRpbWVuc2lvbnMocHJvcHMpO1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICB2YXIgcmFkaXVzID0gcmVmLnJhZGl1cztcclxuICAgIHZhciBoYW5kbGVQb3MgPSBnZXRTbGlkZXJIYW5kbGVQb3NpdGlvbihwcm9wcywgYWN0aXZlQ29sb3IpO1xyXG4gICAgdmFyIGdyYWRpZW50ID0gZ2V0U2xpZGVyR3JhZGllbnQocHJvcHMsIGFjdGl2ZUNvbG9yKTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZUlucHV0KHgsIHksIHR5cGUpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBnZXRTbGlkZXJWYWx1ZUZyb21JbnB1dChwcm9wcywgeCwgeSk7XHJcbiAgICAgICAgcHJvcHMucGFyZW50LmlucHV0QWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBhY3RpdmVDb2xvcltwcm9wcy5zbGlkZXJUeXBlXSA9IHZhbHVlO1xyXG4gICAgICAgIHByb3BzLm9uSW5wdXQodHlwZSwgcHJvcHMuaWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChoKElyb0NvbXBvbmVudFdyYXBwZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IG9uSW5wdXQ6IGhhbmRsZUlucHV0IH0pLCBmdW5jdGlvbiAodWlkLCByb290UHJvcHMsIHJvb3RTdHlsZXMpIHsgcmV0dXJuIChoKFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIHJvb3RQcm9wcywgeyBjbGFzc05hbWU6IFwiSXJvU2xpZGVyXCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCB7cG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIHdpZHRoOiBjc3NWYWx1ZSh3aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogY3NzVmFsdWUoaGVpZ2h0KSxcclxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBjc3NWYWx1ZShyYWRpdXMpLFxyXG4gICAgICAgICAgICAvLyBjaGVja2VyZWQgYmcgdG8gcmVwcmVzZW50IGFscGhhXHJcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiY29uaWMtZ3JhZGllbnQoI2NjYyAyNSUsICNmZmYgMCA1MCUsICNjY2MgMCA3NSUsICNmZmYgMClcIixcclxuICAgICAgICAgICAgYmFja2dyb3VuZFNpemU6ICc4cHggOHB4J30sXHJcbiAgICAgICAgICAgIHJvb3RTdHlsZXMpIH0pLFxyXG4gICAgICAgIGgoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiSXJvU2xpZGVyR3JhZGllbnRcIiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHtwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogXCIxMDAlXCIsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBjc3NWYWx1ZShyYWRpdXMpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogY3NzR3JhZGllbnQoJ2xpbmVhcicsIHByb3BzLmxheW91dERpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ3RvIHRvcCcgOiAndG8gcmlnaHQnLCBncmFkaWVudCl9LFxyXG4gICAgICAgICAgICAgICAgY3NzQm9yZGVyU3R5bGVzKHByb3BzKSkgfSksXHJcbiAgICAgICAgaChJcm9IYW5kbGUsIHsgaXNBY3RpdmU6IHRydWUsIGluZGV4OiBhY3RpdmVDb2xvci5pbmRleCwgcjogcHJvcHMuaGFuZGxlUmFkaXVzLCB1cmw6IHByb3BzLmhhbmRsZVN2ZywgcHJvcHM6IHByb3BzLmhhbmRsZVByb3BzLCB4OiBoYW5kbGVQb3MueCwgeTogaGFuZGxlUG9zLnkgfSkpKTsgfSkpO1xyXG59XHJcbklyb1NsaWRlci5kZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzbGlkZXJEZWZhdWx0T3B0aW9ucyk7XG5cbmZ1bmN0aW9uIElyb0JveChwcm9wcykge1xyXG4gICAgdmFyIHJlZiA9IGdldEJveERpbWVuc2lvbnMocHJvcHMpO1xuICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICB2YXIgcmFkaXVzID0gcmVmLnJhZGl1cztcclxuICAgIHZhciBjb2xvcnMgPSBwcm9wcy5jb2xvcnM7XHJcbiAgICB2YXIgY29sb3JQaWNrZXIgPSBwcm9wcy5wYXJlbnQ7XHJcbiAgICB2YXIgYWN0aXZlSW5kZXggPSBwcm9wcy5hY3RpdmVJbmRleDtcclxuICAgIHZhciBhY3RpdmVDb2xvciA9IChhY3RpdmVJbmRleCAhPT0gdW5kZWZpbmVkICYmIGFjdGl2ZUluZGV4IDwgcHJvcHMuY29sb3JzLmxlbmd0aCkgPyBwcm9wcy5jb2xvcnNbYWN0aXZlSW5kZXhdIDogcHJvcHMuY29sb3I7XHJcbiAgICB2YXIgZ3JhZGllbnRzID0gZ2V0Qm94R3JhZGllbnRzKHByb3BzLCBhY3RpdmVDb2xvcik7XHJcbiAgICB2YXIgaGFuZGxlUG9zaXRpb25zID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHsgcmV0dXJuIGdldEJveEhhbmRsZVBvc2l0aW9uKHByb3BzLCBjb2xvcik7IH0pO1xyXG4gICAgZnVuY3Rpb24gaGFuZGxlSW5wdXQoeCwgeSwgaW5wdXRUeXBlKSB7XHJcbiAgICAgICAgaWYgKGlucHV0VHlwZSA9PT0gMCAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICAvLyBnZXRIYW5kbGVBdFBvaW50KCkgcmV0dXJucyB0aGUgaW5kZXggZm9yIHRoZSBoYW5kbGUgaWYgdGhlIHBvaW50ICdoaXRzJyBpdCwgb3IgbnVsbCBvdGhlcndpc2VcclxuICAgICAgICAgICAgdmFyIGFjdGl2ZUhhbmRsZSA9IGdldEhhbmRsZUF0UG9pbnQocHJvcHMsIHgsIHksIGhhbmRsZVBvc2l0aW9ucyk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBoaXQgYSBoYW5kbGUsIHNldCBpdCBhcyB0aGUgYWN0aXZlIGhhbmRsZSwgYnV0IGRvbid0IHVwZGF0ZSB0aGUgY29sb3JcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZUhhbmRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JQaWNrZXIuc2V0QWN0aXZlQ29sb3IoYWN0aXZlSGFuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgaW5wdXQgZGlkbid0IGhpdCBhIGhhbmRsZSwgc2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGhhbmRsZSB0byB0aGF0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3JQaWNrZXIuaW5wdXRBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlQ29sb3IuaHN2ID0gZ2V0Qm94VmFsdWVGcm9tSW5wdXQocHJvcHMsIHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgcHJvcHMub25JbnB1dChpbnB1dFR5cGUsIHByb3BzLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb3ZlIGlzIGZpcmVkIHdoZW4gdGhlIHVzZXIgaGFzIHN0YXJ0ZWQgZHJhZ2dpbmdcclxuICAgICAgICBlbHNlIGlmIChpbnB1dFR5cGUgPT09IDEgLyogTW92ZSAqLykge1xyXG4gICAgICAgICAgICBjb2xvclBpY2tlci5pbnB1dEFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGFjdGl2ZUNvbG9yLmhzdiA9IGdldEJveFZhbHVlRnJvbUlucHV0KHByb3BzLCB4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbGV0IHRoZSBjb2xvciBwaWNrZXIgZmlyZSBpbnB1dDpzdGFydCwgaW5wdXQ6bW92ZSBvciBpbnB1dDplbmQgZXZlbnRzXHJcbiAgICAgICAgcHJvcHMub25JbnB1dChpbnB1dFR5cGUsIHByb3BzLmlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoaChJcm9Db21wb25lbnRXcmFwcGVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBvbklucHV0OiBoYW5kbGVJbnB1dCB9KSwgZnVuY3Rpb24gKHVpZCwgcm9vdFByb3BzLCByb290U3R5bGVzKSB7IHJldHVybiAoaChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCByb290UHJvcHMsIHsgY2xhc3NOYW1lOiBcIklyb0JveFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwge3dpZHRoOiBjc3NWYWx1ZSh3aWR0aCksXHJcbiAgICAgICAgICAgIGhlaWdodDogY3NzVmFsdWUoaGVpZ2h0KSxcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSd9LFxyXG4gICAgICAgICAgICByb290U3R5bGVzKSB9KSxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIklyb0JveFwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwge3dpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogY3NzVmFsdWUocmFkaXVzKX0sXHJcbiAgICAgICAgICAgICAgICBjc3NCb3JkZXJTdHlsZXMocHJvcHMpLFxyXG4gICAgICAgICAgICAgICAge2JhY2tncm91bmQ6IGNzc0dyYWRpZW50KCdsaW5lYXInLCAndG8gYm90dG9tJywgZ3JhZGllbnRzWzFdKVxyXG4gICAgICAgICAgICAgICAgICAgICsgJywnICtcclxuICAgICAgICAgICAgICAgICAgICBjc3NHcmFkaWVudCgnbGluZWFyJywgJ3RvIHJpZ2h0JywgZ3JhZGllbnRzWzBdKX0pIH0pLFxyXG4gICAgICAgIGNvbG9ycy5maWx0ZXIoZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiBjb2xvciAhPT0gYWN0aXZlQ29sb3I7IH0pLm1hcChmdW5jdGlvbiAoY29sb3IpIHsgcmV0dXJuIChoKElyb0hhbmRsZSwgeyBpc0FjdGl2ZTogZmFsc2UsIGluZGV4OiBjb2xvci5pbmRleCwgZmlsbDogY29sb3IuaHNsU3RyaW5nLCByOiBwcm9wcy5oYW5kbGVSYWRpdXMsIHVybDogcHJvcHMuaGFuZGxlU3ZnLCBwcm9wczogcHJvcHMuaGFuZGxlUHJvcHMsIHg6IGhhbmRsZVBvc2l0aW9uc1tjb2xvci5pbmRleF0ueCwgeTogaGFuZGxlUG9zaXRpb25zW2NvbG9yLmluZGV4XS55IH0pKTsgfSksXHJcbiAgICAgICAgaChJcm9IYW5kbGUsIHsgaXNBY3RpdmU6IHRydWUsIGluZGV4OiBhY3RpdmVDb2xvci5pbmRleCwgZmlsbDogYWN0aXZlQ29sb3IuaHNsU3RyaW5nLCByOiBwcm9wcy5hY3RpdmVIYW5kbGVSYWRpdXMgfHwgcHJvcHMuaGFuZGxlUmFkaXVzLCB1cmw6IHByb3BzLmhhbmRsZVN2ZywgcHJvcHM6IHByb3BzLmhhbmRsZVByb3BzLCB4OiBoYW5kbGVQb3NpdGlvbnNbYWN0aXZlQ29sb3IuaW5kZXhdLngsIHk6IGhhbmRsZVBvc2l0aW9uc1thY3RpdmVDb2xvci5pbmRleF0ueSB9KSkpOyB9KSk7XHJcbn1cblxudmFyIEhVRV9HUkFESUVOVF9DTE9DS1dJU0UgPSAnY29uaWMtZ3JhZGllbnQocmVkLCB5ZWxsb3csIGxpbWUsIGFxdWEsIGJsdWUsIG1hZ2VudGEsIHJlZCknO1xyXG52YXIgSFVFX0dSQURJRU5UX0FOVElDTE9DS1dJU0UgPSAnY29uaWMtZ3JhZGllbnQocmVkLCBtYWdlbnRhLCBibHVlLCBhcXVhLCBsaW1lLCB5ZWxsb3csIHJlZCknO1xyXG5mdW5jdGlvbiBJcm9XaGVlbChwcm9wcykge1xyXG4gICAgdmFyIHJlZiA9IGdldFdoZWVsRGltZW5zaW9ucyhwcm9wcyk7XG4gICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgIHZhciBjb2xvcnMgPSBwcm9wcy5jb2xvcnM7XG4gICAgdmFyIGJvcmRlcldpZHRoID0gcHJvcHMuYm9yZGVyV2lkdGg7XHJcbiAgICB2YXIgY29sb3JQaWNrZXIgPSBwcm9wcy5wYXJlbnQ7XHJcbiAgICB2YXIgYWN0aXZlQ29sb3IgPSBwcm9wcy5jb2xvcjtcclxuICAgIHZhciBoc3YgPSBhY3RpdmVDb2xvci5oc3Y7XHJcbiAgICB2YXIgaGFuZGxlUG9zaXRpb25zID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHsgcmV0dXJuIGdldFdoZWVsSGFuZGxlUG9zaXRpb24ocHJvcHMsIGNvbG9yKTsgfSk7XHJcbiAgICB2YXIgY2lyY2xlU3R5bGVzID0ge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcclxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIGhhbmRsZUlucHV0KHgsIHksIGlucHV0VHlwZSkge1xyXG4gICAgICAgIGlmIChpbnB1dFR5cGUgPT09IDAgLyogU3RhcnQgKi8pIHtcclxuICAgICAgICAgICAgLy8gaW5wdXQgaGl0Ym94IGlzIGEgc3F1YXJlLCBcclxuICAgICAgICAgICAgLy8gc28gd2Ugd2FudCB0byBpZ25vcmUgYW55IGluaXRpYWwgY2xpY2tzIG91dHNpZGUgdGhlIGNpcmN1bGFyIHNoYXBlIG9mIHRoZSB3aGVlbFxyXG4gICAgICAgICAgICBpZiAoIWlzSW5wdXRJbnNpZGVXaGVlbChwcm9wcywgeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSB3aWxsIGNlYXNlIGFsbCBldmVudCBoYW5kbGluZyBmb3IgdGhpcyBpbnRlcmFjdGlvblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldEhhbmRsZUF0UG9pbnQoKSByZXR1cm5zIHRoZSBpbmRleCBmb3IgdGhlIGhhbmRsZSBpZiB0aGUgcG9pbnQgJ2hpdHMnIGl0LCBvciBudWxsIG90aGVyd2lzZVxyXG4gICAgICAgICAgICB2YXIgYWN0aXZlSGFuZGxlID0gZ2V0SGFuZGxlQXRQb2ludChwcm9wcywgeCwgeSwgaGFuZGxlUG9zaXRpb25zKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGlucHV0IGhpdCBhIGhhbmRsZSwgc2V0IGl0IGFzIHRoZSBhY3RpdmUgaGFuZGxlLCBidXQgZG9uJ3QgdXBkYXRlIHRoZSBjb2xvclxyXG4gICAgICAgICAgICBpZiAoYWN0aXZlSGFuZGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvclBpY2tlci5zZXRBY3RpdmVDb2xvcihhY3RpdmVIYW5kbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBkaWRuJ3QgaGl0IGEgaGFuZGxlLCBzZXQgdGhlIGN1cnJlbnRseSBhY3RpdmUgaGFuZGxlIHRvIHRoYXQgcG9zaXRpb25cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvclBpY2tlci5pbnB1dEFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhY3RpdmVDb2xvci5oc3YgPSBnZXRXaGVlbFZhbHVlRnJvbUlucHV0KHByb3BzLCB4LCB5KTtcclxuICAgICAgICAgICAgICAgIHByb3BzLm9uSW5wdXQoaW5wdXRUeXBlLCBwcm9wcy5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbW92ZSBpcyBmaXJlZCB3aGVuIHRoZSB1c2VyIGhhcyBzdGFydGVkIGRyYWdnaW5nXHJcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRUeXBlID09PSAxIC8qIE1vdmUgKi8pIHtcclxuICAgICAgICAgICAgY29sb3JQaWNrZXIuaW5wdXRBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBhY3RpdmVDb2xvci5oc3YgPSBnZXRXaGVlbFZhbHVlRnJvbUlucHV0KHByb3BzLCB4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbGV0IHRoZSBjb2xvciBwaWNrZXIgZmlyZSBpbnB1dDpzdGFydCwgaW5wdXQ6bW92ZSBvciBpbnB1dDplbmQgZXZlbnRzXHJcbiAgICAgICAgcHJvcHMub25JbnB1dChpbnB1dFR5cGUsIHByb3BzLmlkKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoaChJcm9Db21wb25lbnRXcmFwcGVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBvbklucHV0OiBoYW5kbGVJbnB1dCB9KSwgZnVuY3Rpb24gKHVpZCwgcm9vdFByb3BzLCByb290U3R5bGVzKSB7IHJldHVybiAoaChcImRpdlwiLCBPYmplY3QuYXNzaWduKHt9LCByb290UHJvcHMsIHsgY2xhc3NOYW1lOiBcIklyb1doZWVsXCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCB7d2lkdGg6IGNzc1ZhbHVlKHdpZHRoKSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBjc3NWYWx1ZSh3aWR0aCksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnfSxcclxuICAgICAgICAgICAgcm9vdFN0eWxlcykgfSksXHJcbiAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJJcm9XaGVlbEh1ZVwiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgY2lyY2xlU3R5bGVzLFxyXG4gICAgICAgICAgICAgICAge3RyYW5zZm9ybTogKFwicm90YXRlWihcIiArIChwcm9wcy53aGVlbEFuZ2xlICsgOTApICsgXCJkZWcpXCIpLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogcHJvcHMud2hlZWxEaXJlY3Rpb24gPT09ICdjbG9ja3dpc2UnID8gSFVFX0dSQURJRU5UX0NMT0NLV0lTRSA6IEhVRV9HUkFESUVOVF9BTlRJQ0xPQ0tXSVNFfSkgfSksXHJcbiAgICAgICAgaChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJJcm9XaGVlbFNhdHVyYXRpb25cIiwgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIGNpcmNsZVN0eWxlcyxcclxuICAgICAgICAgICAgICAgIHtiYWNrZ3JvdW5kOiAncmFkaWFsLWdyYWRpZW50KGNpcmNsZSBjbG9zZXN0LXNpZGUsICNmZmYsIHRyYW5zcGFyZW50KSd9KSB9KSxcclxuICAgICAgICBwcm9wcy53aGVlbExpZ2h0bmVzcyAmJiAoaChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJJcm9XaGVlbExpZ2h0bmVzc1wiLCBzdHlsZTogT2JqZWN0LmFzc2lnbih7fSwgY2lyY2xlU3R5bGVzLFxyXG4gICAgICAgICAgICAgICAge2JhY2tncm91bmQ6ICcjMDAwJyxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEgLSBoc3YudiAvIDEwMH0pIH0pKSxcclxuICAgICAgICBoKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIklyb1doZWVsQm9yZGVyXCIsIHN0eWxlOiBPYmplY3QuYXNzaWduKHt9LCBjaXJjbGVTdHlsZXMsXHJcbiAgICAgICAgICAgICAgICBjc3NCb3JkZXJTdHlsZXMocHJvcHMpKSB9KSxcclxuICAgICAgICBjb2xvcnMuZmlsdGVyKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gY29sb3IgIT09IGFjdGl2ZUNvbG9yOyB9KS5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiAoaChJcm9IYW5kbGUsIHsgaXNBY3RpdmU6IGZhbHNlLCBpbmRleDogY29sb3IuaW5kZXgsIGZpbGw6IGNvbG9yLmhzbFN0cmluZywgcjogcHJvcHMuaGFuZGxlUmFkaXVzLCB1cmw6IHByb3BzLmhhbmRsZVN2ZywgcHJvcHM6IHByb3BzLmhhbmRsZVByb3BzLCB4OiBoYW5kbGVQb3NpdGlvbnNbY29sb3IuaW5kZXhdLngsIHk6IGhhbmRsZVBvc2l0aW9uc1tjb2xvci5pbmRleF0ueSB9KSk7IH0pLFxyXG4gICAgICAgIGgoSXJvSGFuZGxlLCB7IGlzQWN0aXZlOiB0cnVlLCBpbmRleDogYWN0aXZlQ29sb3IuaW5kZXgsIGZpbGw6IGFjdGl2ZUNvbG9yLmhzbFN0cmluZywgcjogcHJvcHMuYWN0aXZlSGFuZGxlUmFkaXVzIHx8IHByb3BzLmhhbmRsZVJhZGl1cywgdXJsOiBwcm9wcy5oYW5kbGVTdmcsIHByb3BzOiBwcm9wcy5oYW5kbGVQcm9wcywgeDogaGFuZGxlUG9zaXRpb25zW2FjdGl2ZUNvbG9yLmluZGV4XS54LCB5OiBoYW5kbGVQb3NpdGlvbnNbYWN0aXZlQ29sb3IuaW5kZXhdLnkgfSkpKTsgfSkpO1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdpZGdldChXaWRnZXRDb21wb25lbnQpIHtcclxuICAgIHZhciB3aWRnZXRGYWN0b3J5ID0gZnVuY3Rpb24gKHBhcmVudCwgcHJvcHMpIHtcclxuICAgICAgICB2YXIgd2lkZ2V0OyAvLyB3aWxsIGJlY29tZSBhbiBpbnN0YW5jZSBvZiB0aGUgd2lkZ2V0IGNvbXBvbmVudCBjbGFzc1xyXG4gICAgICAgIHZhciB3aWRnZXRSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgLy8gUmVuZGVyIHdpZGdldCBpbnRvIGEgdGVtcCBET00gbm9kZVxyXG4gICAgICAgIEkoaChXaWRnZXRDb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIHtyZWY6IGZ1bmN0aW9uIChyZWYpIHsgcmV0dXJuIHdpZGdldCA9IHJlZjsgfX0sXHJcbiAgICAgICAgICAgIHByb3BzKSksIHdpZGdldFJvb3QpO1xyXG4gICAgICAgIGZ1bmN0aW9uIG1vdW50V2lkZ2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gcGFyZW50IGluc3RhbmNlb2YgRWxlbWVudCA/IHBhcmVudCA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyZW50KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHdpZGdldC5iYXNlKTtcclxuICAgICAgICAgICAgd2lkZ2V0Lm9uTW91bnQoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTW91bnQgaXQgaW50byB0aGUgRE9NIHdoZW4gdGhlIHBhZ2UgZG9jdW1lbnQgaXMgcmVhZHlcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgICAgICAgIG1vdW50V2lkZ2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbW91bnRXaWRnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2lkZ2V0O1xyXG4gICAgfTtcclxuICAgIC8vIEFsbG93IHRoZSB3aWRnZXQgZmFjdG9yeSB0byBpbmhlcml0IGNvbXBvbmVudCBwcm90b3R5cGUgKyBzdGF0aWMgY2xhc3MgbWV0aG9kc1xyXG4gICAgLy8gVGhpcyBtYWtlcyBpdCBlYXNpZXIgZm9yIHBsdWdpbiBhdXRob3JzIHRvIGV4dGVuZCB0aGUgYmFzZSB3aWRnZXQgY29tcG9uZW50XHJcbiAgICB3aWRnZXRGYWN0b3J5LnByb3RvdHlwZSA9IFdpZGdldENvbXBvbmVudC5wcm90b3R5cGU7XHJcbiAgICBPYmplY3QuYXNzaWduKHdpZGdldEZhY3RvcnksIFdpZGdldENvbXBvbmVudCk7XHJcbiAgICAvLyBBZGQgcmVmZXJlbmNlIHRvIGJhc2UgY29tcG9uZW50IHRvb1xyXG4gICAgd2lkZ2V0RmFjdG9yeS5fX2NvbXBvbmVudCA9IFdpZGdldENvbXBvbmVudDtcclxuICAgIHJldHVybiB3aWRnZXRGYWN0b3J5O1xyXG59XG5cbnZhciBJcm9Db2xvclBpY2tlciA9IC8qQF9fUFVSRV9fKi8oZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICAgIGZ1bmN0aW9uIElyb0NvbG9yUGlja2VyKHByb3BzKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAgICAgQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpO1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5pbnB1dEFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XHJcbiAgICAgICAgdGhpcy5hY3RpdmVFdmVudHMgPSB7fTtcclxuICAgICAgICB0aGlzLmRlZmVycmVkRXZlbnRzID0ge307XHJcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIHZhciBjb2xvcnMgPSBwcm9wcy5jb2xvcnMubGVuZ3RoID4gMCA/IHByb3BzLmNvbG9ycyA6IFtwcm9wcy5jb2xvcl07XHJcbiAgICAgICAgY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yVmFsdWUpIHsgcmV0dXJuIHRoaXMkMS5hZGRDb2xvcihjb2xvclZhbHVlKTsgfSk7XHJcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVDb2xvcigwKTtcclxuICAgICAgICAvLyBQYXNzIGFsbCB0aGUgcHJvcHMgaW50byB0aGUgY29tcG9uZW50J3Mgc3RhdGUsXHJcbiAgICAgICAgLy8gRXhjZXB0IHdlIHdhbnQgdG8gYWRkIHRoZSBjb2xvciBvYmplY3QgYW5kIG1ha2Ugc3VyZSB0aGF0IHJlZnMgYXJlbid0IHBhc3NlZCBkb3duIHRvIGNoaWxkcmVuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLFxyXG4gICAgICAgICAgICB7Y29sb3I6IHRoaXMuY29sb3IsXHJcbiAgICAgICAgICAgIGNvbG9yczogdGhpcy5jb2xvcnMsXHJcbiAgICAgICAgICAgIGxheW91dDogcHJvcHMubGF5b3V0fSk7XHJcbiAgICB9XG5cbiAgICBpZiAoIENvbXBvbmVudCApIElyb0NvbG9yUGlja2VyLl9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb21wb25lbnQgJiYgQ29tcG9uZW50LnByb3RvdHlwZSApO1xuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElyb0NvbG9yUGlja2VyO1xyXG4gICAgLy8gUGx1YmljIG11bHRpY29sb3IgQVBJXHJcbiAgICAvKipcclxuICAgICogQGRlc2MgQWRkIGEgY29sb3IgdG8gdGhlIGNvbG9yIHBpY2tlclxyXG4gICAgKiBAcGFyYW0gY29sb3IgbmV3IGNvbG9yIHRvIGFkZFxyXG4gICAgKiBAcGFyYW0gaW5kZXggb3B0aW9uYWwgY29sb3IgaW5kZXhcclxuICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUuYWRkQ29sb3IgPSBmdW5jdGlvbiBhZGRDb2xvciAoY29sb3IsIGluZGV4KSB7XG4gICAgICAgIGlmICggaW5kZXggPT09IHZvaWQgMCApIGluZGV4ID0gdGhpcy5jb2xvcnMubGVuZ3RoO1xuXHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGlyby5Db2xvclxyXG4gICAgICAgIC8vIEFsc28gYmluZCBpdCB0byBvbkNvbG9yQ2hhbmdlLCBzbyB3aGVuZXZlciB0aGUgY29sb3IgY2hhbmdlcyBpdCB1cGRhdGVzIHRoZSBjb2xvciBwaWNrZXJcclxuICAgICAgICB2YXIgbmV3Q29sb3IgPSBuZXcgSXJvQ29sb3IoY29sb3IsIHRoaXMub25Db2xvckNoYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICAvLyBJbnNlcnQgY29sb3IgQCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgICAgICB0aGlzLmNvbG9ycy5zcGxpY2UoaW5kZXgsIDAsIG5ld0NvbG9yKTtcclxuICAgICAgICAvLyBSZWluZGV4IGNvbG9yc1xyXG4gICAgICAgIHRoaXMuY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yLCBpbmRleCkgeyByZXR1cm4gY29sb3IuaW5kZXggPSBpbmRleDsgfSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHBpY2tlciBzdGF0ZSBpZiBuZWNlc3NhcnlcclxuICAgICAgICBpZiAodGhpcy5zdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgY29sb3JzOiB0aGlzLmNvbG9ycyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlyZSBjb2xvciBpbml0IGV2ZW50XHJcbiAgICAgICAgdGhpcy5kZWZlcnJlZEVtaXQoJ2NvbG9yOmluaXQnLCBuZXdDb2xvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBSZW1vdmUgYSBjb2xvciBmcm9tIHRoZSBjb2xvciBwaWNrZXJcclxuICAgICAqIEBwYXJhbSBpbmRleCBjb2xvciBpbmRleFxyXG4gICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUucmVtb3ZlQ29sb3IgPSBmdW5jdGlvbiByZW1vdmVDb2xvciAoaW5kZXgpIHtcclxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9ycy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xyXG4gICAgICAgIC8vIERlc3Ryb3kgdGhlIGNvbG9yIG9iamVjdCAtLSB0aGlzIHVuYmluZHMgaXQgZnJvbSB0aGUgY29sb3IgcGlja2VyXHJcbiAgICAgICAgY29sb3IudW5iaW5kKCk7XHJcbiAgICAgICAgLy8gUmVpbmRleCBjb2xvcnNcclxuICAgICAgICB0aGlzLmNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvciwgaW5kZXgpIHsgcmV0dXJuIGNvbG9yLmluZGV4ID0gaW5kZXg7IH0pO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBwaWNrZXIgc3RhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yczogdGhpcy5jb2xvcnMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZSBhY3RpdmUgY29sb3Igd2FzIHJlbW92ZWQsIGRlZmF1bHQgYWN0aXZlIGNvbG9yIHRvIDBcclxuICAgICAgICBpZiAoY29sb3IuaW5kZXggPT09IHRoaXMuY29sb3IuaW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVDb2xvcigwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlyZSBjb2xvciByZW1vdmUgZXZlbnRcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbG9yOnJlbW92ZScsIGNvbG9yKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFNldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBjb2xvclxyXG4gICAgICogQHBhcmFtIGluZGV4IGNvbG9yIGluZGV4XHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5zZXRBY3RpdmVDb2xvciA9IGZ1bmN0aW9uIHNldEFjdGl2ZUNvbG9yIChpbmRleCkge1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSB0aGlzLmNvbG9yc1tpbmRleF07XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yOiB0aGlzLmNvbG9yIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaXJlIGNvbG9yIHN3aXRjaCBldmVudFxyXG4gICAgICAgIHRoaXMuZW1pdCgnY29sb3I6c2V0QWN0aXZlJywgdGhpcy5jb2xvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBSZXBsYWNlIGFsbCBvZiB0aGUgY3VycmVudCBjb2xvclBpY2tlciBjb2xvcnNcclxuICAgICAqIEBwYXJhbSBuZXdDb2xvclZhbHVlcyBsaXN0IG9mIG5ldyBjb2xvcnMgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiBzZXRDb2xvcnMgKG5ld0NvbG9yVmFsdWVzLCBhY3RpdmVDb2xvckluZGV4KSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAoIGFjdGl2ZUNvbG9ySW5kZXggPT09IHZvaWQgMCApIGFjdGl2ZUNvbG9ySW5kZXggPSAwO1xuXHJcbiAgICAgICAgLy8gVW5iaW5kIGNvbG9yIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuY29sb3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yKSB7IHJldHVybiBjb2xvci51bmJpbmQoKTsgfSk7XHJcbiAgICAgICAgLy8gRGVzdHJveSBvbGQgY29sb3JzXHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBbXTtcclxuICAgICAgICAvLyBBZGQgbmV3IGNvbG9yc1xyXG4gICAgICAgIG5ld0NvbG9yVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGNvbG9yVmFsdWUpIHsgcmV0dXJuIHRoaXMkMS5hZGRDb2xvcihjb2xvclZhbHVlKTsgfSk7XHJcbiAgICAgICAgLy8gUmVzZXQgYWN0aXZlIGNvbG9yXHJcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVDb2xvcihhY3RpdmVDb2xvckluZGV4KTtcclxuICAgICAgICB0aGlzLmVtaXQoJ2NvbG9yOnNldEFsbCcsIHRoaXMuY29sb3JzKTtcclxuICAgIH07XHJcbiAgICAvLyBQdWJsaWMgQ29sb3JQaWNrZXIgZXZlbnRzIEFQSVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBTZXQgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgYW4gZXZlbnRcclxuICAgICAqIEBwYXJhbSBldmVudExpc3QgZXZlbnQocykgdG8gbGlzdGVuIHRvXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWRcclxuICAgICAqL1xyXG4gICAgSXJvQ29sb3JQaWNrZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50TGlzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHM7XHJcbiAgICAgICAgLy8gZXZlbnRMaXN0IGNhbiBiZSBhbiBldmVudFR5cGUgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGV2ZW50VHlwZSBzdHJpbmdzXHJcbiAgICAgICAgKCFBcnJheS5pc0FycmF5KGV2ZW50TGlzdCkgPyBbZXZlbnRMaXN0XSA6IGV2ZW50TGlzdCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgIC8vIEFkZCBldmVudCBjYWxsYmFja1xyXG4gICAgICAgICAgICAoZXZlbnRzW2V2ZW50VHlwZV0gfHwgKGV2ZW50c1tldmVudFR5cGVdID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgLy8gQ2FsbCBkZWZlcnJlZCBldmVudHNcclxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIGV2ZW50cyB0aGF0IGNhbiBiZSBzdG9yZWQgdW50aWwgYSBsaXN0ZW5lciBmb3IgdGhlbSBpcyBhZGRlZFxyXG4gICAgICAgICAgICBpZiAodGhpcyQxLmRlZmVycmVkRXZlbnRzW2V2ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmZlcmVkIGV2ZW50cyBzdG9yZSBhbiBhcnJheSBvZiBhcmd1bWVudHMgZnJvbSB3aGVuIHRoZSBldmVudCB3YXMgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuZGVmZXJyZWRFdmVudHNbZXZlbnRUeXBlXS5mb3JFYWNoKGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIGRlZmVycmVkIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLmRlZmVycmVkRXZlbnRzW2V2ZW50VHlwZV0gPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlc2MgUmVtb3ZlIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGFuIGV2ZW50IGFkZGVkIHdpdGggb24oKVxyXG4gICAgICogQHBhcmFtIGV2ZW50TGlzdCAtIGV2ZW50KHMpIHRvIGxpc3RlbiB0b1xyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gb3JpZ2luYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYgKGV2ZW50TGlzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cclxuICAgICAgICAoIUFycmF5LmlzQXJyYXkoZXZlbnRMaXN0KSA/IFtldmVudExpc3RdIDogZXZlbnRMaXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrTGlzdCA9IHRoaXMkMS5ldmVudHNbZXZlbnRUeXBlXTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0SG9vaygnZXZlbnQ6b2ZmJywgZXZlbnRUeXBlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFja0xpc3QpXHJcbiAgICAgICAgICAgICAgICB7IGNhbGxiYWNrTGlzdC5zcGxpY2UoY2FsbGJhY2tMaXN0LmluZGV4T2YoY2FsbGJhY2spLCAxKTsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlc2MgRW1pdCBhbiBldmVudFxyXG4gICAgICogQHBhcmFtIGV2ZW50VHlwZSBldmVudCB0byBlbWl0XHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xuXHJcbiAgICAgICAgdmFyIGFjdGl2ZUV2ZW50cyA9IHRoaXMuYWN0aXZlRXZlbnRzO1xyXG4gICAgICAgIHZhciBpc0V2ZW50QWN0aXZlID0gYWN0aXZlRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50VHlwZSkgPyBhY3RpdmVFdmVudHNbZXZlbnRUeXBlXSA6IGZhbHNlO1xyXG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQgY2FsbGJhY2tzIGZyb20gZmlyaW5nIGlmIHRoZSBldmVudCBpcyBhbHJlYWR5IGFjdGl2ZVxyXG4gICAgICAgIC8vIFRoaXMgc3RvcHMgaW5maW5pdGUgbG9vcHMgaWYgc29tZXRoaW5nIGluIGFuIGV2ZW50IGNhbGxiYWNrIGNhdXNlcyB0aGUgc2FtZSBldmVudCB0byBiZSBmaXJlZCBhZ2FpblxyXG4gICAgICAgIC8vIChlLmcuIHNldHRpbmcgdGhlIGNvbG9yIGluc2lkZSBhIGNvbG9yOmNoYW5nZSBjYWxsYmFjaylcclxuICAgICAgICBpZiAoIWlzRXZlbnRBY3RpdmUpIHtcclxuICAgICAgICAgICAgYWN0aXZlRXZlbnRzW2V2ZW50VHlwZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy5ldmVudHNbZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICAgICAgY2FsbGJhY2tMaXN0LmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5hcHBseSh0aGlzJDEsIGFyZ3MpOyB9KTtcclxuICAgICAgICAgICAgYWN0aXZlRXZlbnRzW2V2ZW50VHlwZV0gPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBFbWl0IGFuIGV2ZW50IG5vdywgb3Igc2F2ZSBpdCBmb3Igd2hlbiB0aGUgcmVsZXZlbnQgZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWRcclxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxyXG4gICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUuZGVmZXJyZWRFbWl0ID0gZnVuY3Rpb24gZGVmZXJyZWRFbWl0IChldmVudFR5cGUpIHtcbiAgICAgICAgdmFyIHJlZjtcblxuICAgICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuICsgMSBdO1xyXG4gICAgICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IHRoaXMuZGVmZXJyZWRFdmVudHM7XHJcbiAgICAgICAgKHJlZiA9IHRoaXMpLmVtaXQuYXBwbHkocmVmLCBbIGV2ZW50VHlwZSBdLmNvbmNhdCggYXJncyApKTtcclxuICAgICAgICAoZGVmZXJyZWRFdmVudHNbZXZlbnRUeXBlXSB8fCAoZGVmZXJyZWRFdmVudHNbZXZlbnRUeXBlXSA9IFtdKSkucHVzaChhcmdzKTtcclxuICAgIH07XHJcbiAgICAvLyBQdWJsaWMgdXRpbGl0eSBtZXRob2RzXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMgKG5ld09wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKG5ld09wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlc2MgUmVzaXplIHRoZSBjb2xvciBwaWNrZXJcclxuICAgICAqIEBwYXJhbSB3aWR0aCAtIG5ldyB3aWR0aFxyXG4gICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gcmVzaXplICh3aWR0aCkge1xyXG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHdpZHRoOiB3aWR0aCB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFJlc2V0IHRoZSBjb2xvciBwaWNrZXIgdG8gdGhlIGluaXRpYWwgY29sb3IgcHJvdmlkZWQgaW4gdGhlIGNvbG9yIHBpY2tlciBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0ICgpIHtcclxuICAgICAgICB0aGlzLmNvbG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xvcikgeyByZXR1cm4gY29sb3IucmVzZXQoKTsgfSk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yczogdGhpcy5jb2xvcnMgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVzYyBDYWxsZWQgYnkgdGhlIGNyZWF0ZVdpZGdldCB3cmFwcGVyIHdoZW4gdGhlIGVsZW1lbnQgaXMgbW91bnRlZCBpbnRvIHRoZSBwYWdlXHJcbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIC0gdGhlIGNvbnRhaW5lciBlbGVtZW50IGZvciB0aGlzIENvbG9yUGlja2VyIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIElyb0NvbG9yUGlja2VyLnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudCAoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5lbCA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmRlZmVycmVkRW1pdCgnbW91bnQnLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBJbnRlcm5hbCBtZXRob2RzXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjIFJlYWN0IHRvIGEgY29sb3IgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgLSBjdXJyZW50IGNvbG9yXHJcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyAtIHNob3dzIHdoaWNoIGgscyx2LGEgY29sb3IgY2hhbm5lbHMgY2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUub25Db2xvckNoYW5nZSA9IGZ1bmN0aW9uIG9uQ29sb3JDaGFuZ2UgKGNvbG9yLCBjaGFuZ2VzKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGNvbG9yOiB0aGlzLmNvbG9yIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLmlucHV0QWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnB1dDpjaGFuZ2UnLCBjb2xvciwgY2hhbmdlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdCgnY29sb3I6Y2hhbmdlJywgY29sb3IsIGNoYW5nZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQGRlc2MgSGFuZGxlIGlucHV0IGZyb20gYSBVSSBjb250cm9sIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB0eXBlIC0gZXZlbnQgdHlwZVxyXG4gICAgICovXHJcbiAgICBJcm9Db2xvclBpY2tlci5wcm90b3R5cGUuZW1pdElucHV0RXZlbnQgPSBmdW5jdGlvbiBlbWl0SW5wdXRFdmVudCAodHlwZSwgb3JpZ2luSWQpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gMCAvKiBTdGFydCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lucHV0OnN0YXJ0JywgdGhpcy5jb2xvciwgb3JpZ2luSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAxIC8qIE1vdmUgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnB1dDptb3ZlJywgdGhpcy5jb2xvciwgb3JpZ2luSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAyIC8qIEVuZCAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lucHV0OmVuZCcsIHRoaXMuY29sb3IsIG9yaWdpbklkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSXJvQ29sb3JQaWNrZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAocHJvcHMsIHN0YXRlKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXHJcbiAgICAgICAgdmFyIGxheW91dCA9IHN0YXRlLmxheW91dDtcclxuICAgICAgICAvLyB1c2UgbGF5b3V0IHNob3J0aGFuZHNcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobGF5b3V0KSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGxheW91dCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHNvbWU/XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGxheW91dCA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb21wb25lbnQ6IElyb1doZWVsIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgY29tcG9uZW50OiBJcm9TbGlkZXIgfSBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFkZCB0cmFuc3BhcmVuY3kgc2xpZGVyIHRvIHRoZSBsYXlvdXRcclxuICAgICAgICAgICAgaWYgKHN0YXRlLnRyYW5zcGFyZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgbGF5b3V0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogSXJvU2xpZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyVHlwZTogJ2FscGhhJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoaChcImRpdlwiLCB7IGNsYXNzOiBcIklyb0NvbG9yUGlja2VyXCIsIGlkOiBzdGF0ZS5pZCwgc3R5bGU6IHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IHN0YXRlLmRpc3BsYXlcclxuICAgICAgICAgICAgfSB9LCBsYXlvdXQubWFwKGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIFVpQ29tcG9uZW50ID0gcmVmLmNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChoKFVpQ29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSwgb3B0aW9ucywgeyByZWY6IHVuZGVmaW5lZCwgb25JbnB1dDogdGhpcyQxLmVtaXRJbnB1dEV2ZW50LmJpbmQodGhpcyQxKSwgcGFyZW50OiB0aGlzJDEsIGluZGV4OiBjb21wb25lbnRJbmRleCB9KSkpO1xuICAgICAgICB9KSkpO1xyXG4gICAgfTtcblxuICAgIHJldHVybiBJcm9Db2xvclBpY2tlcjtcbn0obSkpO1xyXG5Jcm9Db2xvclBpY2tlci5kZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBpcm9Db2xvclBpY2tlck9wdGlvbkRlZmF1bHRzLFxyXG4gICAge2NvbG9yczogW10sXHJcbiAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgaWQ6IG51bGwsXHJcbiAgICBsYXlvdXQ6ICdkZWZhdWx0JyxcclxuICAgIG1hcmdpbjogbnVsbH0pO1xyXG52YXIgSXJvQ29sb3JQaWNrZXJXaWRnZXQgPSBjcmVhdGVXaWRnZXQoSXJvQ29sb3JQaWNrZXIpO1xuXG52YXIgaXJvO1xyXG4oZnVuY3Rpb24gKGlybykge1xyXG4gICAgaXJvLnZlcnNpb24gPSBcIjUuNS4wXCI7IC8vIHJlcGxhY2VkIGJ5IEByb2xsdXAvcGx1Z2luLXJlcGxhY2U7IHNlZSByb2xsdXAuY29uZmlnLmpzXHJcbiAgICBpcm8uQ29sb3IgPSBJcm9Db2xvcjtcclxuICAgIGlyby5Db2xvclBpY2tlciA9IElyb0NvbG9yUGlja2VyV2lkZ2V0O1xyXG4gICAgdmFyIHVpO1xyXG4gICAgKGZ1bmN0aW9uICh1aSkge1xyXG4gICAgICAgIHVpLmggPSBoO1xyXG4gICAgICAgIHVpLkNvbXBvbmVudEJhc2UgPSBJcm9Db21wb25lbnRXcmFwcGVyO1xyXG4gICAgICAgIHVpLkhhbmRsZSA9IElyb0hhbmRsZTtcclxuICAgICAgICB1aS5TbGlkZXIgPSBJcm9TbGlkZXI7XHJcbiAgICAgICAgdWkuV2hlZWwgPSBJcm9XaGVlbDtcclxuICAgICAgICB1aS5Cb3ggPSBJcm9Cb3g7XHJcbiAgICB9KSh1aSA9IGlyby51aSB8fCAoaXJvLnVpID0ge30pKTtcclxufSkoaXJvIHx8IChpcm8gPSB7fSkpO1xyXG52YXIgaXJvJDEgPSBpcm87XG5cbmV4cG9ydCBkZWZhdWx0IGlybyQxO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@jaames/iro/dist/iro.es.js\n");

/***/ }),

/***/ "./node_modules/alpinejs/dist/alpine.js":
/*!**********************************************!*\
  !*** ./node_modules/alpinejs/dist/alpine.js ***!
  \**********************************************/
/***/ (function(module) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread2(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(Object(source), true).forEach(function (key) {\n          _defineProperty(target, key, source[key]);\n        });\n      } else if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n      } else {\n        ownKeys(Object(source)).forEach(function (key) {\n          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  // Thanks @stimulus:\n  // https://github.com/stimulusjs/stimulus/blob/master/packages/%40stimulus/core/src/application.ts\n  function domReady() {\n    return new Promise(resolve => {\n      if (document.readyState == \"loading\") {\n        document.addEventListener(\"DOMContentLoaded\", resolve);\n      } else {\n        resolve();\n      }\n    });\n  }\n  function arrayUnique(array) {\n    return Array.from(new Set(array));\n  }\n  function isTesting() {\n    return navigator.userAgent.includes(\"Node.js\") || navigator.userAgent.includes(\"jsdom\");\n  }\n  function checkedAttrLooseCompare(valueA, valueB) {\n    return valueA == valueB;\n  }\n  function warnIfMalformedTemplate(el, directive) {\n    if (el.tagName.toLowerCase() !== 'template') {\n      console.warn(`Alpine: [${directive}] directive should only be added to <template> tags. See https://github.com/alpinejs/alpine#${directive}`);\n    } else if (el.content.childElementCount !== 1) {\n      console.warn(`Alpine: <template> tag with [${directive}] encountered with an unexpected number of root elements. Make sure <template> has a single root element. `);\n    }\n  }\n  function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n  }\n  function camelCase(subject) {\n    return subject.toLowerCase().replace(/-(\\w)/g, (match, char) => char.toUpperCase());\n  }\n  function walk(el, callback) {\n    if (callback(el) === false) return;\n    let node = el.firstElementChild;\n\n    while (node) {\n      walk(node, callback);\n      node = node.nextElementSibling;\n    }\n  }\n  function debounce(func, wait) {\n    var timeout;\n    return function () {\n      var context = this,\n          args = arguments;\n\n      var later = function later() {\n        timeout = null;\n        func.apply(context, args);\n      };\n\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  const handleError = (el, expression, error) => {\n    console.warn(`Alpine Error: \"${error}\"\\n\\nExpression: \"${expression}\"\\nElement:`, el);\n\n    if (!isTesting()) {\n      Object.assign(error, {\n        el,\n        expression\n      });\n      throw error;\n    }\n  };\n\n  function tryCatch(cb, {\n    el,\n    expression\n  }) {\n    try {\n      const value = cb();\n      return value instanceof Promise ? value.catch(e => handleError(el, expression, e)) : value;\n    } catch (e) {\n      handleError(el, expression, e);\n    }\n  }\n\n  function saferEval(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return expression.call(dataContext);\n      }\n\n      return new Function(['$data', ...Object.keys(additionalHelperVariables)], `var __alpine_result; with($data) { __alpine_result = ${expression} }; return __alpine_result`)(dataContext, ...Object.values(additionalHelperVariables));\n    }, {\n      el,\n      expression\n    });\n  }\n  function saferEvalNoReturn(el, expression, dataContext, additionalHelperVariables = {}) {\n    return tryCatch(() => {\n      if (typeof expression === 'function') {\n        return Promise.resolve(expression.call(dataContext, additionalHelperVariables['$event']));\n      }\n\n      let AsyncFunction = Function;\n      /* MODERN-ONLY:START */\n\n      AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;\n      /* MODERN-ONLY:END */\n      // For the cases when users pass only a function reference to the caller: `x-on:click=\"foo\"`\n      // Where \"foo\" is a function. Also, we'll pass the function the event instance when we call it.\n\n      if (Object.keys(dataContext).includes(expression)) {\n        let methodReference = new Function(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { return ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables));\n\n        if (typeof methodReference === 'function') {\n          return Promise.resolve(methodReference.call(dataContext, additionalHelperVariables['$event']));\n        } else {\n          return Promise.resolve();\n        }\n      }\n\n      return Promise.resolve(new AsyncFunction(['dataContext', ...Object.keys(additionalHelperVariables)], `with(dataContext) { ${expression} }`)(dataContext, ...Object.values(additionalHelperVariables)));\n    }, {\n      el,\n      expression\n    });\n  }\n  const xAttrRE = /^x-(on|bind|data|text|html|model|if|for|show|cloak|transition|ref|spread)\\b/;\n  function isXAttr(attr) {\n    const name = replaceAtAndColonWithStandardSyntax(attr.name);\n    return xAttrRE.test(name);\n  }\n  function getXAttrs(el, component, type) {\n    let directives = Array.from(el.attributes).filter(isXAttr).map(parseHtmlAttribute); // Get an object of directives from x-spread.\n\n    let spreadDirective = directives.filter(directive => directive.type === 'spread')[0];\n\n    if (spreadDirective) {\n      let spreadObject = saferEval(el, spreadDirective.expression, component.$data); // Add x-spread directives to the pile of existing directives.\n\n      directives = directives.concat(Object.entries(spreadObject).map(([name, value]) => parseHtmlAttribute({\n        name,\n        value\n      })));\n    }\n\n    if (type) return directives.filter(i => i.type === type);\n    return sortDirectives(directives);\n  }\n\n  function sortDirectives(directives) {\n    let directiveOrder = ['bind', 'model', 'show', 'catch-all'];\n    return directives.sort((a, b) => {\n      let typeA = directiveOrder.indexOf(a.type) === -1 ? 'catch-all' : a.type;\n      let typeB = directiveOrder.indexOf(b.type) === -1 ? 'catch-all' : b.type;\n      return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);\n    });\n  }\n\n  function parseHtmlAttribute({\n    name,\n    value\n  }) {\n    const normalizedName = replaceAtAndColonWithStandardSyntax(name);\n    const typeMatch = normalizedName.match(xAttrRE);\n    const valueMatch = normalizedName.match(/:([a-zA-Z0-9\\-:]+)/);\n    const modifiers = normalizedName.match(/\\.[^.\\]]+(?=[^\\]]*$)/g) || [];\n    return {\n      type: typeMatch ? typeMatch[1] : null,\n      value: valueMatch ? valueMatch[1] : null,\n      modifiers: modifiers.map(i => i.replace('.', '')),\n      expression: value\n    };\n  }\n  function isBooleanAttr(attrName) {\n    // As per HTML spec table https://html.spec.whatwg.org/multipage/indices.html#attributes-3:boolean-attribute\n    // Array roughly ordered by estimated usage\n    const booleanAttributes = ['disabled', 'checked', 'required', 'readonly', 'hidden', 'open', 'selected', 'autofocus', 'itemscope', 'multiple', 'novalidate', 'allowfullscreen', 'allowpaymentrequest', 'formnovalidate', 'autoplay', 'controls', 'loop', 'muted', 'playsinline', 'default', 'ismap', 'reversed', 'async', 'defer', 'nomodule'];\n    return booleanAttributes.includes(attrName);\n  }\n  function replaceAtAndColonWithStandardSyntax(name) {\n    if (name.startsWith('@')) {\n      return name.replace('@', 'x-on:');\n    } else if (name.startsWith(':')) {\n      return name.replace(':', 'x-bind:');\n    }\n\n    return name;\n  }\n  function convertClassStringToArray(classList, filterFn = Boolean) {\n    return classList.split(' ').filter(filterFn);\n  }\n  const TRANSITION_TYPE_IN = 'in';\n  const TRANSITION_TYPE_OUT = 'out';\n  const TRANSITION_CANCELLED = 'cancelled';\n  function transitionIn(el, show, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return show();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_IN) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0]; // If this is triggered by a x-show.transition.\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers; // If x-show.transition.out, we'll skip the \"in\" transition.\n\n      if (modifiers.includes('out') && !modifiers.includes('in')) return show();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out'); // If x-show.transition.in...out... only use \"in\" related modifiers for this transition.\n\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index < modifiers.indexOf('out')) : modifiers;\n      transitionHelperIn(el, modifiers, show, reject); // Otherwise, we can assume x-transition:enter.\n    } else if (attrs.some(attr => ['enter', 'enter-start', 'enter-end'].includes(attr.value))) {\n      transitionClassesIn(el, component, attrs, show, reject);\n    } else {\n      // If neither, just show that damn thing.\n      show();\n    }\n  }\n  function transitionOut(el, hide, reject, component, forceSkip = false) {\n    // We don't want to transition on the initial page load.\n    if (forceSkip) return hide();\n\n    if (el.__x_transition && el.__x_transition.type === TRANSITION_TYPE_OUT) {\n      // there is already a similar transition going on, this was probably triggered by\n      // a change in a different property, let's just leave the previous one doing its job\n      return;\n    }\n\n    const attrs = getXAttrs(el, component, 'transition');\n    const showAttr = getXAttrs(el, component, 'show')[0];\n\n    if (showAttr && showAttr.modifiers.includes('transition')) {\n      let modifiers = showAttr.modifiers;\n      if (modifiers.includes('in') && !modifiers.includes('out')) return hide();\n      const settingBothSidesOfTransition = modifiers.includes('in') && modifiers.includes('out');\n      modifiers = settingBothSidesOfTransition ? modifiers.filter((i, index) => index > modifiers.indexOf('out')) : modifiers;\n      transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hide, reject);\n    } else if (attrs.some(attr => ['leave', 'leave-start', 'leave-end'].includes(attr.value))) {\n      transitionClassesOut(el, component, attrs, hide, reject);\n    } else {\n      hide();\n    }\n  }\n  function transitionHelperIn(el, modifiers, showCallback, reject) {\n    // Default values inspired by: https://material.io/design/motion/speed.html#duration\n    const styleValues = {\n      duration: modifierValue(modifiers, 'duration', 150),\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      },\n      second: {\n        opacity: 1,\n        scale: 100\n      }\n    };\n    transitionHelper(el, modifiers, showCallback, () => {}, reject, styleValues, TRANSITION_TYPE_IN);\n  }\n  function transitionHelperOut(el, modifiers, settingBothSidesOfTransition, hideCallback, reject) {\n    // Make the \"out\" transition .5x slower than the \"in\". (Visually better)\n    // HOWEVER, if they explicitly set a duration for the \"out\" transition,\n    // use that.\n    const duration = settingBothSidesOfTransition ? modifierValue(modifiers, 'duration', 150) : modifierValue(modifiers, 'duration', 150) / 2;\n    const styleValues = {\n      duration: duration,\n      origin: modifierValue(modifiers, 'origin', 'center'),\n      first: {\n        opacity: 1,\n        scale: 100\n      },\n      second: {\n        opacity: 0,\n        scale: modifierValue(modifiers, 'scale', 95)\n      }\n    };\n    transitionHelper(el, modifiers, () => {}, hideCallback, reject, styleValues, TRANSITION_TYPE_OUT);\n  }\n\n  function modifierValue(modifiers, key, fallback) {\n    // If the modifier isn't present, use the default.\n    if (modifiers.indexOf(key) === -1) return fallback; // If it IS present, grab the value after it: x-show.transition.duration.500ms\n\n    const rawValue = modifiers[modifiers.indexOf(key) + 1];\n    if (!rawValue) return fallback;\n\n    if (key === 'scale') {\n      // Check if the very next value is NOT a number and return the fallback.\n      // If x-show.transition.scale, we'll use the default scale value.\n      // That is how a user opts out of the opacity transition.\n      if (!isNumeric(rawValue)) return fallback;\n    }\n\n    if (key === 'duration') {\n      // Support x-show.transition.duration.500ms && duration.500\n      let match = rawValue.match(/([0-9]+)ms/);\n      if (match) return match[1];\n    }\n\n    if (key === 'origin') {\n      // Support chaining origin directions: x-show.transition.top.right\n      if (['top', 'right', 'left', 'center', 'bottom'].includes(modifiers[modifiers.indexOf(key) + 2])) {\n        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(' ');\n      }\n    }\n\n    return rawValue;\n  }\n\n  function transitionHelper(el, modifiers, hook1, hook2, reject, styleValues, type) {\n    // clear the previous transition if exists to avoid caching the wrong styles\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    } // If the user set these style values, we'll put them back when we're done with them.\n\n\n    const opacityCache = el.style.opacity;\n    const transformCache = el.style.transform;\n    const transformOriginCache = el.style.transformOrigin; // If no modifiers are present: x-show.transition, we'll default to both opacity and scale.\n\n    const noModifiers = !modifiers.includes('opacity') && !modifiers.includes('scale');\n    const transitionOpacity = noModifiers || modifiers.includes('opacity');\n    const transitionScale = noModifiers || modifiers.includes('scale'); // These are the explicit stages of a transition (same stages for in and for out).\n    // This way you can get a birds eye view of the hooks, and the differences\n    // between them.\n\n    const stages = {\n      start() {\n        if (transitionOpacity) el.style.opacity = styleValues.first.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.first.scale / 100})`;\n      },\n\n      during() {\n        if (transitionScale) el.style.transformOrigin = styleValues.origin;\n        el.style.transitionProperty = [transitionOpacity ? `opacity` : ``, transitionScale ? `transform` : ``].join(' ').trim();\n        el.style.transitionDuration = `${styleValues.duration / 1000}s`;\n        el.style.transitionTimingFunction = `cubic-bezier(0.4, 0.0, 0.2, 1)`;\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        if (transitionOpacity) el.style.opacity = styleValues.second.opacity;\n        if (transitionScale) el.style.transform = `scale(${styleValues.second.scale / 100})`;\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        if (transitionOpacity) el.style.opacity = opacityCache;\n        if (transitionScale) el.style.transform = transformCache;\n        if (transitionScale) el.style.transformOrigin = transformOriginCache;\n        el.style.transitionProperty = null;\n        el.style.transitionDuration = null;\n        el.style.transitionTimingFunction = null;\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n\n  const ensureStringExpression = (expression, el, component) => {\n    return typeof expression === 'function' ? component.evaluateReturnExpression(el, expression) : expression;\n  };\n\n  function transitionClassesIn(el, component, directives, showCallback, reject) {\n    const enter = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter') || {\n      expression: ''\n    }).expression, el, component));\n    const enterStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-start') || {\n      expression: ''\n    }).expression, el, component));\n    const enterEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'enter-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, enter, enterStart, enterEnd, showCallback, () => {}, TRANSITION_TYPE_IN, reject);\n  }\n  function transitionClassesOut(el, component, directives, hideCallback, reject) {\n    const leave = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveStart = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-start') || {\n      expression: ''\n    }).expression, el, component));\n    const leaveEnd = convertClassStringToArray(ensureStringExpression((directives.find(i => i.value === 'leave-end') || {\n      expression: ''\n    }).expression, el, component));\n    transitionClasses(el, leave, leaveStart, leaveEnd, () => {}, hideCallback, TRANSITION_TYPE_OUT, reject);\n  }\n  function transitionClasses(el, classesDuring, classesStart, classesEnd, hook1, hook2, type, reject) {\n    // clear the previous transition if exists to avoid caching the wrong classes\n    if (el.__x_transition) {\n      el.__x_transition.cancel && el.__x_transition.cancel();\n    }\n\n    const originalClasses = el.__x_original_classes || [];\n    const stages = {\n      start() {\n        el.classList.add(...classesStart);\n      },\n\n      during() {\n        el.classList.add(...classesDuring);\n      },\n\n      show() {\n        hook1();\n      },\n\n      end() {\n        // Don't remove classes that were in the original class attribute.\n        el.classList.remove(...classesStart.filter(i => !originalClasses.includes(i)));\n        el.classList.add(...classesEnd);\n      },\n\n      hide() {\n        hook2();\n      },\n\n      cleanup() {\n        el.classList.remove(...classesDuring.filter(i => !originalClasses.includes(i)));\n        el.classList.remove(...classesEnd.filter(i => !originalClasses.includes(i)));\n      }\n\n    };\n    transition(el, stages, type, reject);\n  }\n  function transition(el, stages, type, reject) {\n    const finish = once(() => {\n      stages.hide(); // Adding an \"isConnected\" check, in case the callback\n      // removed the element from the DOM.\n\n      if (el.isConnected) {\n        stages.cleanup();\n      }\n\n      delete el.__x_transition;\n    });\n    el.__x_transition = {\n      // Set transition type so we can avoid clearing transition if the direction is the same\n      type: type,\n      // create a callback for the last stages of the transition so we can call it\n      // from different point and early terminate it. Once will ensure that function\n      // is only called one time.\n      cancel: once(() => {\n        reject(TRANSITION_CANCELLED);\n        finish();\n      }),\n      finish,\n      // This store the next animation frame so we can cancel it\n      nextFrame: null\n    };\n    stages.start();\n    stages.during();\n    el.__x_transition.nextFrame = requestAnimationFrame(() => {\n      // Note: Safari's transitionDuration property will list out comma separated transition durations\n      // for every single transition property. Let's grab the first one and call it a day.\n      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n      if (duration === 0) {\n        duration = Number(getComputedStyle(el).animationDuration.replace('s', '')) * 1000;\n      }\n\n      stages.show();\n      el.__x_transition.nextFrame = requestAnimationFrame(() => {\n        stages.end();\n        setTimeout(el.__x_transition.finish, duration);\n      });\n    });\n  }\n  function isNumeric(subject) {\n    return !Array.isArray(subject) && !isNaN(subject);\n  } // Thanks @vuejs\n  // https://github.com/vuejs/vue/blob/4de4649d9637262a9b007720b59f80ac72a5620c/src/shared/util.js\n\n  function once(callback) {\n    let called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        callback.apply(this, arguments);\n      }\n    };\n  }\n\n  function handleForDirective(component, templateEl, expression, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(templateEl, 'x-for');\n    let iteratorNames = typeof expression === 'function' ? parseForExpression(component.evaluateReturnExpression(templateEl, expression)) : parseForExpression(expression);\n    let items = evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, templateEl, iteratorNames, extraVars); // As we walk the array, we'll also walk the DOM (updating/creating as we go).\n\n    let currentEl = templateEl;\n    items.forEach((item, index) => {\n      let iterationScopeVariables = getIterationScopeVariables(iteratorNames, item, index, items, extraVars());\n      let currentKey = generateKeyForIteration(component, templateEl, index, iterationScopeVariables);\n      let nextEl = lookAheadForMatchingKeyedElementAndMoveItIfFound(currentEl.nextElementSibling, currentKey); // If we haven't found a matching key, insert the element at the current position.\n\n      if (!nextEl) {\n        nextEl = addElementInLoopAfterCurrentEl(templateEl, currentEl); // And transition it in if it's not the first page load.\n\n        transitionIn(nextEl, () => {}, () => {}, component, initialUpdate);\n        nextEl.__x_for = iterationScopeVariables;\n        component.initializeElements(nextEl, () => nextEl.__x_for); // Otherwise update the element we found.\n      } else {\n        // Temporarily remove the key indicator to allow the normal \"updateElements\" to work.\n        delete nextEl.__x_for_key;\n        nextEl.__x_for = iterationScopeVariables;\n        component.updateElements(nextEl, () => nextEl.__x_for);\n      }\n\n      currentEl = nextEl;\n      currentEl.__x_for_key = currentKey;\n    });\n    removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component);\n  } // This was taken from VueJS 2.* core. Thanks Vue!\n\n  function parseForExpression(expression) {\n    let forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n    let stripParensRE = /^\\(|\\)$/g;\n    let forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n    let inMatch = String(expression).match(forAliasRE);\n    if (!inMatch) return;\n    let res = {};\n    res.items = inMatch[2].trim();\n    let item = inMatch[1].trim().replace(stripParensRE, '');\n    let iteratorMatch = item.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.item = item.replace(forIteratorRE, '').trim();\n      res.index = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.collection = iteratorMatch[2].trim();\n      }\n    } else {\n      res.item = item;\n    }\n\n    return res;\n  }\n\n  function getIterationScopeVariables(iteratorNames, item, index, items, extraVars) {\n    // We must create a new object, so each iteration has a new scope\n    let scopeVariables = extraVars ? _objectSpread2({}, extraVars) : {};\n    scopeVariables[iteratorNames.item] = item;\n    if (iteratorNames.index) scopeVariables[iteratorNames.index] = index;\n    if (iteratorNames.collection) scopeVariables[iteratorNames.collection] = items;\n    return scopeVariables;\n  }\n\n  function generateKeyForIteration(component, el, index, iterationScopeVariables) {\n    let bindKeyAttribute = getXAttrs(el, component, 'bind').filter(attr => attr.value === 'key')[0]; // If the dev hasn't specified a key, just return the index of the iteration.\n\n    if (!bindKeyAttribute) return index;\n    return component.evaluateReturnExpression(el, bindKeyAttribute.expression, () => iterationScopeVariables);\n  }\n\n  function evaluateItemsAndReturnEmptyIfXIfIsPresentAndFalseOnElement(component, el, iteratorNames, extraVars) {\n    let ifAttribute = getXAttrs(el, component, 'if')[0];\n\n    if (ifAttribute && !component.evaluateReturnExpression(el, ifAttribute.expression)) {\n      return [];\n    }\n\n    let items = component.evaluateReturnExpression(el, iteratorNames.items, extraVars); // This adds support for the `i in n` syntax.\n\n    if (isNumeric(items) && items >= 0) {\n      items = Array.from(Array(items).keys(), i => i + 1);\n    }\n\n    return items;\n  }\n\n  function addElementInLoopAfterCurrentEl(templateEl, currentEl) {\n    let clone = document.importNode(templateEl.content, true);\n    currentEl.parentElement.insertBefore(clone, currentEl.nextElementSibling);\n    return currentEl.nextElementSibling;\n  }\n\n  function lookAheadForMatchingKeyedElementAndMoveItIfFound(nextEl, currentKey) {\n    if (!nextEl) return; // If we are already past the x-for generated elements, we don't need to look ahead.\n\n    if (nextEl.__x_for_key === undefined) return; // If the the key's DO match, no need to look ahead.\n\n    if (nextEl.__x_for_key === currentKey) return nextEl; // If they don't, we'll look ahead for a match.\n    // If we find it, we'll move it to the current position in the loop.\n\n    let tmpNextEl = nextEl;\n\n    while (tmpNextEl) {\n      if (tmpNextEl.__x_for_key === currentKey) {\n        return tmpNextEl.parentElement.insertBefore(tmpNextEl, nextEl);\n      }\n\n      tmpNextEl = tmpNextEl.nextElementSibling && tmpNextEl.nextElementSibling.__x_for_key !== undefined ? tmpNextEl.nextElementSibling : false;\n    }\n  }\n\n  function removeAnyLeftOverElementsFromPreviousUpdate(currentEl, component) {\n    var nextElementFromOldLoop = currentEl.nextElementSibling && currentEl.nextElementSibling.__x_for_key !== undefined ? currentEl.nextElementSibling : false;\n\n    while (nextElementFromOldLoop) {\n      let nextElementFromOldLoopImmutable = nextElementFromOldLoop;\n      let nextSibling = nextElementFromOldLoop.nextElementSibling;\n      transitionOut(nextElementFromOldLoop, () => {\n        nextElementFromOldLoopImmutable.remove();\n      }, () => {}, component);\n      nextElementFromOldLoop = nextSibling && nextSibling.__x_for_key !== undefined ? nextSibling : false;\n    }\n  }\n\n  function handleAttributeBindingDirective(component, el, attrName, expression, extraVars, attrType, modifiers) {\n    var value = component.evaluateReturnExpression(el, expression, extraVars);\n\n    if (attrName === 'value') {\n      if (Alpine.ignoreFocusedForValueBinding && document.activeElement.isSameNode(el)) return; // If nested model key is undefined, set the default value to empty string.\n\n      if (value === undefined && String(expression).match(/\\./)) {\n        value = '';\n      }\n\n      if (el.type === 'radio') {\n        // Set radio value from x-bind:value, if no \"value\" attribute exists.\n        // If there are any initial state values, radio will have a correct\n        // \"checked\" value since x-bind:value is processed before x-model.\n        if (el.attributes.value === undefined && attrType === 'bind') {\n          el.value = value;\n        } else if (attrType !== 'bind') {\n          el.checked = checkedAttrLooseCompare(el.value, value);\n        }\n      } else if (el.type === 'checkbox') {\n        // If we are explicitly binding a string to the :value, set the string,\n        // If the value is a boolean, leave it alone, it will be set to \"on\"\n        // automatically.\n        if (typeof value !== 'boolean' && ![null, undefined].includes(value) && attrType === 'bind') {\n          el.value = String(value);\n        } else if (attrType !== 'bind') {\n          if (Array.isArray(value)) {\n            // I'm purposely not using Array.includes here because it's\n            // strict, and because of Numeric/String mis-casting, I\n            // want the \"includes\" to be \"fuzzy\".\n            el.checked = value.some(val => checkedAttrLooseCompare(val, el.value));\n          } else {\n            el.checked = !!value;\n          }\n        }\n      } else if (el.tagName === 'SELECT') {\n        updateSelect(el, value);\n      } else {\n        if (el.value === value) return;\n        el.value = value;\n      }\n    } else if (attrName === 'class') {\n      if (Array.isArray(value)) {\n        const originalClasses = el.__x_original_classes || [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(value)).join(' '));\n      } else if (typeof value === 'object') {\n        // Sorting the keys / class names by their boolean value will ensure that\n        // anything that evaluates to `false` and needs to remove classes is run first.\n        const keysSortedByBooleanValue = Object.keys(value).sort((a, b) => value[a] - value[b]);\n        keysSortedByBooleanValue.forEach(classNames => {\n          if (value[classNames]) {\n            convertClassStringToArray(classNames).forEach(className => el.classList.add(className));\n          } else {\n            convertClassStringToArray(classNames).forEach(className => el.classList.remove(className));\n          }\n        });\n      } else {\n        const originalClasses = el.__x_original_classes || [];\n        const newClasses = value ? convertClassStringToArray(value) : [];\n        el.setAttribute('class', arrayUnique(originalClasses.concat(newClasses)).join(' '));\n      }\n    } else {\n      attrName = modifiers.includes('camel') ? camelCase(attrName) : attrName; // If an attribute's bound value is null, undefined or false, remove the attribute\n\n      if ([null, undefined, false].includes(value)) {\n        el.removeAttribute(attrName);\n      } else {\n        isBooleanAttr(attrName) ? setIfChanged(el, attrName, attrName) : setIfChanged(el, attrName, value);\n      }\n    }\n  }\n\n  function setIfChanged(el, attrName, value) {\n    if (el.getAttribute(attrName) != value) {\n      el.setAttribute(attrName, value);\n    }\n  }\n\n  function updateSelect(el, value) {\n    const arrayWrappedValue = [].concat(value).map(value => {\n      return value + '';\n    });\n    Array.from(el.options).forEach(option => {\n      option.selected = arrayWrappedValue.includes(option.value || option.text);\n    });\n  }\n\n  function handleTextDirective(el, output, expression) {\n    // If nested model key is undefined, set the default value to empty string.\n    if (output === undefined && String(expression).match(/\\./)) {\n      output = '';\n    }\n\n    el.textContent = output;\n  }\n\n  function handleHtmlDirective(component, el, expression, extraVars) {\n    el.innerHTML = component.evaluateReturnExpression(el, expression, extraVars);\n  }\n\n  function handleShowDirective(component, el, value, modifiers, initialUpdate = false) {\n    const hide = () => {\n      el.style.display = 'none';\n      el.__x_is_shown = false;\n    };\n\n    const show = () => {\n      if (el.style.length === 1 && el.style.display === 'none') {\n        el.removeAttribute('style');\n      } else {\n        el.style.removeProperty('display');\n      }\n\n      el.__x_is_shown = true;\n    };\n\n    if (initialUpdate === true) {\n      if (value) {\n        show();\n      } else {\n        hide();\n      }\n\n      return;\n    }\n\n    const handle = (resolve, reject) => {\n      if (value) {\n        if (el.style.display === 'none' || el.__x_transition) {\n          transitionIn(el, () => {\n            show();\n          }, reject, component);\n        }\n\n        resolve(() => {});\n      } else {\n        if (el.style.display !== 'none') {\n          transitionOut(el, () => {\n            resolve(() => {\n              hide();\n            });\n          }, reject, component);\n        } else {\n          resolve(() => {});\n        }\n      }\n    }; // The working of x-show is a bit complex because we need to\n    // wait for any child transitions to finish before hiding\n    // some element. Also, this has to be done recursively.\n    // If x-show.immediate, foregoe the waiting.\n\n\n    if (modifiers.includes('immediate')) {\n      handle(finish => finish(), () => {});\n      return;\n    } // x-show is encountered during a DOM tree walk. If an element\n    // we encounter is NOT a child of another x-show element we\n    // can execute the previous x-show stack (if one exists).\n\n\n    if (component.showDirectiveLastElement && !component.showDirectiveLastElement.contains(el)) {\n      component.executeAndClearRemainingShowDirectiveStack();\n    }\n\n    component.showDirectiveStack.push(handle);\n    component.showDirectiveLastElement = el;\n  }\n\n  function handleIfDirective(component, el, expressionResult, initialUpdate, extraVars) {\n    warnIfMalformedTemplate(el, 'x-if');\n    const elementHasAlreadyBeenAdded = el.nextElementSibling && el.nextElementSibling.__x_inserted_me === true;\n\n    if (expressionResult && (!elementHasAlreadyBeenAdded || el.__x_transition)) {\n      const clone = document.importNode(el.content, true);\n      el.parentElement.insertBefore(clone, el.nextElementSibling);\n      transitionIn(el.nextElementSibling, () => {}, () => {}, component, initialUpdate);\n      component.initializeElements(el.nextElementSibling, extraVars);\n      el.nextElementSibling.__x_inserted_me = true;\n    } else if (!expressionResult && elementHasAlreadyBeenAdded) {\n      transitionOut(el.nextElementSibling, () => {\n        el.nextElementSibling.remove();\n      }, () => {}, component, initialUpdate);\n    }\n  }\n\n  function registerListener(component, el, event, modifiers, expression, extraVars = {}) {\n    const options = {\n      passive: modifiers.includes('passive')\n    };\n\n    if (modifiers.includes('camel')) {\n      event = camelCase(event);\n    }\n\n    let handler, listenerTarget;\n\n    if (modifiers.includes('away')) {\n      listenerTarget = document;\n\n      handler = e => {\n        // Don't do anything if the click came from the element or within it.\n        if (el.contains(e.target)) return; // Don't do anything if this element isn't currently visible.\n\n        if (el.offsetWidth < 1 && el.offsetHeight < 1) return; // Now that we are sure the element is visible, AND the click\n        // is from outside it, let's run the expression.\n\n        runListenerHandler(component, expression, e, extraVars);\n\n        if (modifiers.includes('once')) {\n          document.removeEventListener(event, handler, options);\n        }\n      };\n    } else {\n      listenerTarget = modifiers.includes('window') ? window : modifiers.includes('document') ? document : el;\n\n      handler = e => {\n        // Remove this global event handler if the element that declared it\n        // has been removed. It's now stale.\n        if (listenerTarget === window || listenerTarget === document) {\n          if (!document.body.contains(el)) {\n            listenerTarget.removeEventListener(event, handler, options);\n            return;\n          }\n        }\n\n        if (isKeyEvent(event)) {\n          if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {\n            return;\n          }\n        }\n\n        if (modifiers.includes('prevent')) e.preventDefault();\n        if (modifiers.includes('stop')) e.stopPropagation(); // If the .self modifier isn't present, or if it is present and\n        // the target element matches the element we are registering the\n        // event on, run the handler\n\n        if (!modifiers.includes('self') || e.target === el) {\n          const returnValue = runListenerHandler(component, expression, e, extraVars);\n          returnValue.then(value => {\n            if (value === false) {\n              e.preventDefault();\n            } else {\n              if (modifiers.includes('once')) {\n                listenerTarget.removeEventListener(event, handler, options);\n              }\n            }\n          });\n        }\n      };\n    }\n\n    if (modifiers.includes('debounce')) {\n      let nextModifier = modifiers[modifiers.indexOf('debounce') + 1] || 'invalid-wait';\n      let wait = isNumeric(nextModifier.split('ms')[0]) ? Number(nextModifier.split('ms')[0]) : 250;\n      handler = debounce(handler, wait);\n    }\n\n    listenerTarget.addEventListener(event, handler, options);\n  }\n\n  function runListenerHandler(component, expression, e, extraVars) {\n    return component.evaluateCommandExpression(e.target, expression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        '$event': e\n      });\n    });\n  }\n\n  function isKeyEvent(event) {\n    return ['keydown', 'keyup'].includes(event);\n  }\n\n  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {\n    let keyModifiers = modifiers.filter(i => {\n      return !['window', 'document', 'prevent', 'stop'].includes(i);\n    });\n\n    if (keyModifiers.includes('debounce')) {\n      let debounceIndex = keyModifiers.indexOf('debounce');\n      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || 'invalid-wait').split('ms')[0]) ? 2 : 1);\n    } // If no modifier is specified, we'll call it a press.\n\n\n    if (keyModifiers.length === 0) return false; // If one is passed, AND it matches the key pressed, we'll call it a press.\n\n    if (keyModifiers.length === 1 && keyModifiers[0] === keyToModifier(e.key)) return false; // The user is listening for key combinations.\n\n    const systemKeyModifiers = ['ctrl', 'shift', 'alt', 'meta', 'cmd', 'super'];\n    const selectedSystemKeyModifiers = systemKeyModifiers.filter(modifier => keyModifiers.includes(modifier));\n    keyModifiers = keyModifiers.filter(i => !selectedSystemKeyModifiers.includes(i));\n\n    if (selectedSystemKeyModifiers.length > 0) {\n      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter(modifier => {\n        // Alias \"cmd\" and \"super\" to \"meta\"\n        if (modifier === 'cmd' || modifier === 'super') modifier = 'meta';\n        return e[`${modifier}Key`];\n      }); // If all the modifiers selected are pressed, ...\n\n      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {\n        // AND the remaining key is pressed as well. It's a press.\n        if (keyModifiers[0] === keyToModifier(e.key)) return false;\n      }\n    } // We'll call it NOT a valid keypress.\n\n\n    return true;\n  }\n\n  function keyToModifier(key) {\n    switch (key) {\n      case '/':\n        return 'slash';\n\n      case ' ':\n      case 'Spacebar':\n        return 'space';\n\n      default:\n        return key && kebabCase(key);\n    }\n  }\n\n  function registerModelListener(component, el, modifiers, expression, extraVars) {\n    // If the element we are binding to is a select, a radio, or checkbox\n    // we'll listen for the change event instead of the \"input\" event.\n    var event = el.tagName.toLowerCase() === 'select' || ['checkbox', 'radio'].includes(el.type) || modifiers.includes('lazy') ? 'change' : 'input';\n    const listenerExpression = `${expression} = rightSideOfExpression($event, ${expression})`;\n    registerListener(component, el, event, modifiers, listenerExpression, () => {\n      return _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        rightSideOfExpression: generateModelAssignmentFunction(el, modifiers, expression)\n      });\n    });\n  }\n\n  function generateModelAssignmentFunction(el, modifiers, expression) {\n    if (el.type === 'radio') {\n      // Radio buttons only work properly when they share a name attribute.\n      // People might assume we take care of that for them, because\n      // they already set a shared \"x-model\" attribute.\n      if (!el.hasAttribute('name')) el.setAttribute('name', expression);\n    }\n\n    return (event, currentValue) => {\n      // Check for event.detail due to an issue where IE11 handles other events as a CustomEvent.\n      if (event instanceof CustomEvent && event.detail) {\n        return event.detail;\n      } else if (el.type === 'checkbox') {\n        // If the data we are binding to is an array, toggle its value inside the array.\n        if (Array.isArray(currentValue)) {\n          const newValue = modifiers.includes('number') ? safeParseNumber(event.target.value) : event.target.value;\n          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter(el => !checkedAttrLooseCompare(el, newValue));\n        } else {\n          return event.target.checked;\n        }\n      } else if (el.tagName.toLowerCase() === 'select' && el.multiple) {\n        return modifiers.includes('number') ? Array.from(event.target.selectedOptions).map(option => {\n          const rawValue = option.value || option.text;\n          return safeParseNumber(rawValue);\n        }) : Array.from(event.target.selectedOptions).map(option => {\n          return option.value || option.text;\n        });\n      } else {\n        const rawValue = event.target.value;\n        return modifiers.includes('number') ? safeParseNumber(rawValue) : modifiers.includes('trim') ? rawValue.trim() : rawValue;\n      }\n    };\n  }\n\n  function safeParseNumber(rawValue) {\n    const number = rawValue ? parseFloat(rawValue) : null;\n    return isNumeric(number) ? number : rawValue;\n  }\n\n  /**\n   * Copyright (C) 2017 salesforce.com, inc.\n   */\n  const { isArray } = Array;\n  const { getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\n  const { push: ArrayPush, concat: ArrayConcat, map: ArrayMap, } = Array.prototype;\n  function isUndefined(obj) {\n      return obj === undefined;\n  }\n  function isFunction(obj) {\n      return typeof obj === 'function';\n  }\n  function isObject(obj) {\n      return typeof obj === 'object';\n  }\n  const proxyToValueMap = new WeakMap();\n  function registerProxy(proxy, value) {\n      proxyToValueMap.set(proxy, value);\n  }\n  const unwrap = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\n  function wrapValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getProxy(value) : value;\n  }\n  /**\n   * Unwrap property descriptors will set value on original descriptor\n   * We only need to unwrap if value is specified\n   * @param descriptor external descrpitor provided to define new property on original value\n   */\n  function unwrapDescriptor(descriptor) {\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = unwrap(descriptor.value);\n      }\n      return descriptor;\n  }\n  function lockShadowTarget(membrane, shadowTarget, originalTarget) {\n      const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      targetKeys.forEach((key) => {\n          let descriptor = getOwnPropertyDescriptor(originalTarget, key);\n          // We do not need to wrap the descriptor if configurable\n          // Because we can deal with wrapping it when user goes through\n          // Get own property descriptor. There is also a chance that this descriptor\n          // could change sometime in the future, so we can defer wrapping\n          // until we need to\n          if (!descriptor.configurable) {\n              descriptor = wrapDescriptor(membrane, descriptor, wrapValue);\n          }\n          ObjectDefineProperty(shadowTarget, key, descriptor);\n      });\n      preventExtensions(shadowTarget);\n  }\n  class ReactiveProxyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          const oldValue = originalTarget[key];\n          if (oldValue !== value) {\n              originalTarget[key] = value;\n              valueMutated(originalTarget, key);\n          }\n          else if (key === 'length' && isArray(originalTarget)) {\n              // fix for issue #236: push will add the new index, and by the time length\n              // is updated, the internal length is already equal to the new length value\n              // therefore, the oldValue is equal to the value. This is the forking logic\n              // to support this use case.\n              valueMutated(originalTarget, key);\n          }\n          return true;\n      }\n      deleteProperty(shadowTarget, key) {\n          const { originalTarget, membrane: { valueMutated } } = this;\n          delete originalTarget[key];\n          valueMutated(originalTarget, key);\n          return true;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      isExtensible(shadowTarget) {\n          const shadowIsExtensible = isExtensible(shadowTarget);\n          if (!shadowIsExtensible) {\n              return shadowIsExtensible;\n          }\n          const { originalTarget, membrane } = this;\n          const targetIsExtensible = isExtensible(originalTarget);\n          if (!targetIsExtensible) {\n              lockShadowTarget(membrane, shadowTarget, originalTarget);\n          }\n          return targetIsExtensible;\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getPrototypeOf(shadowTarget) {\n          const { originalTarget } = this;\n          return getPrototypeOf(originalTarget);\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = this.membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value, setter or getter (if available) cannot observe\n          // mutations, just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapValue);\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          const { originalTarget, membrane } = this;\n          lockShadowTarget(membrane, shadowTarget, originalTarget);\n          preventExtensions(originalTarget);\n          return true;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          const { originalTarget, membrane } = this;\n          const { valueMutated } = membrane;\n          const { configurable } = descriptor;\n          // We have to check for value in descriptor\n          // because Object.freeze(proxy) calls this method\n          // with only { configurable: false, writeable: false }\n          // Additionally, method will only be called with writeable:false\n          // if the descriptor has a value, as opposed to getter/setter\n          // So we can just check if writable is present and then see if\n          // value is present. This eliminates getter and setter descriptors\n          if (hasOwnProperty.call(descriptor, 'writable') && !hasOwnProperty.call(descriptor, 'value')) {\n              const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n              descriptor.value = originalDescriptor.value;\n          }\n          ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n          if (configurable === false) {\n              ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor, wrapValue));\n          }\n          valueMutated(originalTarget, key);\n          return true;\n      }\n  }\n\n  function wrapReadOnlyValue(membrane, value) {\n      return membrane.valueIsObservable(value) ? membrane.getReadOnlyProxy(value) : value;\n  }\n  class ReadOnlyHandler {\n      constructor(membrane, value) {\n          this.originalTarget = value;\n          this.membrane = membrane;\n      }\n      get(shadowTarget, key) {\n          const { membrane, originalTarget } = this;\n          const value = originalTarget[key];\n          const { valueObserved } = membrane;\n          valueObserved(originalTarget, key);\n          return membrane.getReadOnlyProxy(value);\n      }\n      set(shadowTarget, key, value) {\n          return false;\n      }\n      deleteProperty(shadowTarget, key) {\n          return false;\n      }\n      apply(shadowTarget, thisArg, argArray) {\n          /* No op */\n      }\n      construct(target, argArray, newTarget) {\n          /* No op */\n      }\n      has(shadowTarget, key) {\n          const { originalTarget, membrane: { valueObserved } } = this;\n          valueObserved(originalTarget, key);\n          return key in originalTarget;\n      }\n      ownKeys(shadowTarget) {\n          const { originalTarget } = this;\n          return ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n      }\n      setPrototypeOf(shadowTarget, prototype) {\n      }\n      getOwnPropertyDescriptor(shadowTarget, key) {\n          const { originalTarget, membrane } = this;\n          const { valueObserved } = membrane;\n          // keys looked up via hasOwnProperty need to be reactive\n          valueObserved(originalTarget, key);\n          let desc = getOwnPropertyDescriptor(originalTarget, key);\n          if (isUndefined(desc)) {\n              return desc;\n          }\n          const shadowDescriptor = getOwnPropertyDescriptor(shadowTarget, key);\n          if (!isUndefined(shadowDescriptor)) {\n              return shadowDescriptor;\n          }\n          // Note: by accessing the descriptor, the key is marked as observed\n          // but access to the value or getter (if available) cannot be observed,\n          // just like regular methods, in which case we just do nothing.\n          desc = wrapDescriptor(membrane, desc, wrapReadOnlyValue);\n          if (hasOwnProperty.call(desc, 'set')) {\n              desc.set = undefined; // readOnly membrane does not allow setters\n          }\n          if (!desc.configurable) {\n              // If descriptor from original target is not configurable,\n              // We must copy the wrapped descriptor over to the shadow target.\n              // Otherwise, proxy will throw an invariant error.\n              // This is our last chance to lock the value.\n              // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n              ObjectDefineProperty(shadowTarget, key, desc);\n          }\n          return desc;\n      }\n      preventExtensions(shadowTarget) {\n          return false;\n      }\n      defineProperty(shadowTarget, key, descriptor) {\n          return false;\n      }\n  }\n  function createShadowTarget(value) {\n      let shadowTarget = undefined;\n      if (isArray(value)) {\n          shadowTarget = [];\n      }\n      else if (isObject(value)) {\n          shadowTarget = {};\n      }\n      return shadowTarget;\n  }\n  const ObjectDotPrototype = Object.prototype;\n  function defaultValueIsObservable(value) {\n      // intentionally checking for null\n      if (value === null) {\n          return false;\n      }\n      // treat all non-object types, including undefined, as non-observable values\n      if (typeof value !== 'object') {\n          return false;\n      }\n      if (isArray(value)) {\n          return true;\n      }\n      const proto = getPrototypeOf(value);\n      return (proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null);\n  }\n  const defaultValueObserved = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueMutated = (obj, key) => {\n      /* do nothing */\n  };\n  const defaultValueDistortion = (value) => value;\n  function wrapDescriptor(membrane, descriptor, getValue) {\n      const { set, get } = descriptor;\n      if (hasOwnProperty.call(descriptor, 'value')) {\n          descriptor.value = getValue(membrane, descriptor.value);\n      }\n      else {\n          if (!isUndefined(get)) {\n              descriptor.get = function () {\n                  // invoking the original getter with the original target\n                  return getValue(membrane, get.call(unwrap(this)));\n              };\n          }\n          if (!isUndefined(set)) {\n              descriptor.set = function (value) {\n                  // At this point we don't have a clear indication of whether\n                  // or not a valid mutation will occur, we don't have the key,\n                  // and we are not sure why and how they are invoking this setter.\n                  // Nevertheless we preserve the original semantics by invoking the\n                  // original setter with the original target and the unwrapped value\n                  set.call(unwrap(this), membrane.unwrapProxy(value));\n              };\n          }\n      }\n      return descriptor;\n  }\n  class ReactiveMembrane {\n      constructor(options) {\n          this.valueDistortion = defaultValueDistortion;\n          this.valueMutated = defaultValueMutated;\n          this.valueObserved = defaultValueObserved;\n          this.valueIsObservable = defaultValueIsObservable;\n          this.objectGraph = new WeakMap();\n          if (!isUndefined(options)) {\n              const { valueDistortion, valueMutated, valueObserved, valueIsObservable } = options;\n              this.valueDistortion = isFunction(valueDistortion) ? valueDistortion : defaultValueDistortion;\n              this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n              this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n              this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;\n          }\n      }\n      getProxy(value) {\n          const unwrappedValue = unwrap(value);\n          const distorted = this.valueDistortion(unwrappedValue);\n          if (this.valueIsObservable(distorted)) {\n              const o = this.getReactiveState(unwrappedValue, distorted);\n              // when trying to extract the writable version of a readonly\n              // we return the readonly.\n              return o.readOnly === value ? value : o.reactive;\n          }\n          return distorted;\n      }\n      getReadOnlyProxy(value) {\n          value = unwrap(value);\n          const distorted = this.valueDistortion(value);\n          if (this.valueIsObservable(distorted)) {\n              return this.getReactiveState(value, distorted).readOnly;\n          }\n          return distorted;\n      }\n      unwrapProxy(p) {\n          return unwrap(p);\n      }\n      getReactiveState(value, distortedValue) {\n          const { objectGraph, } = this;\n          let reactiveState = objectGraph.get(distortedValue);\n          if (reactiveState) {\n              return reactiveState;\n          }\n          const membrane = this;\n          reactiveState = {\n              get reactive() {\n                  const reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue);\n                  // caching the reactive proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'reactive', { value: proxy });\n                  return proxy;\n              },\n              get readOnly() {\n                  const readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue);\n                  // caching the readOnly proxy after the first time it is accessed\n                  const proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);\n                  registerProxy(proxy, value);\n                  ObjectDefineProperty(this, 'readOnly', { value: proxy });\n                  return proxy;\n              }\n          };\n          objectGraph.set(distortedValue, reactiveState);\n          return reactiveState;\n      }\n  }\n  /** version: 0.26.0 */\n\n  function wrap(data, mutationCallback) {\n\n    let membrane = new ReactiveMembrane({\n      valueMutated(target, key) {\n        mutationCallback(target, key);\n      }\n\n    });\n    return {\n      data: membrane.getProxy(data),\n      membrane: membrane\n    };\n  }\n  function unwrap$1(membrane, observable) {\n    let unwrappedData = membrane.unwrapProxy(observable);\n    let copy = {};\n    Object.keys(unwrappedData).forEach(key => {\n      if (['$el', '$refs', '$nextTick', '$watch'].includes(key)) return;\n      copy[key] = unwrappedData[key];\n    });\n    return copy;\n  }\n\n  class Component {\n    constructor(el, componentForClone = null) {\n      this.$el = el;\n      const dataAttr = this.$el.getAttribute('x-data');\n      const dataExpression = dataAttr === '' ? '{}' : dataAttr;\n      const initExpression = this.$el.getAttribute('x-init');\n      let dataExtras = {\n        $el: this.$el\n      };\n      let canonicalComponentElementReference = componentForClone ? componentForClone.$el : this.$el;\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(dataExtras, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference);\n          }\n        });\n      });\n      this.unobservedData = componentForClone ? componentForClone.getUnobservedData() : saferEval(el, dataExpression, dataExtras);\n      // Construct a Proxy-based observable. This will be used to handle reactivity.\n\n      let {\n        membrane,\n        data\n      } = this.wrapDataInObservable(this.unobservedData);\n      this.$data = data;\n      this.membrane = membrane; // After making user-supplied data methods reactive, we can now add\n      // our magic properties to the original data for access.\n\n      this.unobservedData.$el = this.$el;\n      this.unobservedData.$refs = this.getRefsProxy();\n      this.nextTickStack = [];\n\n      this.unobservedData.$nextTick = callback => {\n        this.nextTickStack.push(callback);\n      };\n\n      this.watchers = {};\n\n      this.unobservedData.$watch = (property, callback) => {\n        if (!this.watchers[property]) this.watchers[property] = [];\n        this.watchers[property].push(callback);\n      };\n      /* MODERN-ONLY:START */\n      // We remove this piece of code from the legacy build.\n      // In IE11, we have already defined our helpers at this point.\n      // Register custom magic properties.\n\n\n      Object.entries(Alpine.magicProperties).forEach(([name, callback]) => {\n        Object.defineProperty(this.unobservedData, `$${name}`, {\n          get: function get() {\n            return callback(canonicalComponentElementReference, this.$el);\n          }\n        });\n      });\n      /* MODERN-ONLY:END */\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement;\n      componentForClone || Alpine.onBeforeComponentInitializeds.forEach(callback => callback(this));\n      var initReturnedCallback; // If x-init is present AND we aren't cloning (skip x-init on clone)\n\n      if (initExpression && !componentForClone) {\n        // We want to allow data manipulation, but not trigger DOM updates just yet.\n        // We haven't even initialized the elements with their Alpine bindings. I mean c'mon.\n        this.pauseReactivity = true;\n        initReturnedCallback = this.evaluateReturnExpression(this.$el, initExpression);\n        this.pauseReactivity = false;\n      } // Register all our listeners and set all our attribute bindings.\n      // If we're cloning a component, the third parameter ensures no duplicate\n      // event listeners are registered (the mutation observer will take care of them)\n\n\n      this.initializeElements(this.$el, () => {}, componentForClone); // Use mutation observer to detect new elements being added within this component at run-time.\n      // Alpine's just so darn flexible amirite?\n\n      this.listenForNewElementsToInitialize();\n\n      if (typeof initReturnedCallback === 'function') {\n        // Run the callback returned from the \"x-init\" hook to allow the user to do stuff after\n        // Alpine's got it's grubby little paws all over everything.\n        initReturnedCallback.call(this.$data);\n      }\n\n      componentForClone || setTimeout(() => {\n        Alpine.onComponentInitializeds.forEach(callback => callback(this));\n      }, 0);\n    }\n\n    getUnobservedData() {\n      return unwrap$1(this.membrane, this.$data);\n    }\n\n    wrapDataInObservable(data) {\n      var self = this;\n      let updateDom = debounce(function () {\n        self.updateElements(self.$el);\n      }, 0);\n      return wrap(data, (target, key) => {\n        if (self.watchers[key]) {\n          // If there's a watcher for this specific key, run it.\n          self.watchers[key].forEach(callback => callback(target[key]));\n        } else if (Array.isArray(target)) {\n          // Arrays are special cases, if any of the items change, we consider the array as mutated.\n          Object.keys(self.watchers).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // Ignore length mutations since they would result in duplicate calls.\n            // For example, when calling push, we would get a mutation for the item's key\n            // and a second mutation for the length property.\n\n            if (key === 'length') return;\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData[part])) {\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } else {\n          // Let's walk through the watchers with \"dot-notation\" (foo.bar) and see\n          // if this mutation fits any of them.\n          Object.keys(self.watchers).filter(i => i.includes('.')).forEach(fullDotNotationKey => {\n            let dotNotationParts = fullDotNotationKey.split('.'); // If this dot-notation watcher's last \"part\" doesn't match the current\n            // key, then skip it early for performance reasons.\n\n            if (key !== dotNotationParts[dotNotationParts.length - 1]) return; // Now, walk through the dot-notation \"parts\" recursively to find\n            // a match, and call the watcher if one's found.\n\n            dotNotationParts.reduce((comparisonData, part) => {\n              if (Object.is(target, comparisonData)) {\n                // Run the watchers.\n                self.watchers[fullDotNotationKey].forEach(callback => callback(target[key]));\n              }\n\n              return comparisonData[part];\n            }, self.unobservedData);\n          });\n        } // Don't react to data changes for cases like the `x-created` hook.\n\n\n        if (self.pauseReactivity) return;\n        updateDom();\n      });\n    }\n\n    walkAndSkipNestedComponents(el, callback, initializeComponentCallback = () => {}) {\n      walk(el, el => {\n        // We've hit a component.\n        if (el.hasAttribute('x-data')) {\n          // If it's not the current one.\n          if (!el.isSameNode(this.$el)) {\n            // Initialize it if it's not.\n            if (!el.__x) initializeComponentCallback(el); // Now we'll let that sub-component deal with itself.\n\n            return false;\n          }\n        }\n\n        return callback(el);\n      });\n    }\n\n    initializeElements(rootEl, extraVars = () => {}, componentForClone = false) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop\n        if (el.__x_for_key !== undefined) return false; // Don't touch spawns from if directives\n\n        if (el.__x_inserted_me !== undefined) return false;\n        this.initializeElement(el, extraVars, componentForClone ? false : true);\n      }, el => {\n        if (!componentForClone) el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    initializeElement(el, extraVars, shouldRegisterListeners = true) {\n      // To support class attribute merging, we have to know what the element's\n      // original class attribute looked like for reference.\n      if (el.hasAttribute('class') && getXAttrs(el, this).length > 0) {\n        el.__x_original_classes = convertClassStringToArray(el.getAttribute('class'));\n      }\n\n      shouldRegisterListeners && this.registerListeners(el, extraVars);\n      this.resolveBoundAttributes(el, true, extraVars);\n    }\n\n    updateElements(rootEl, extraVars = () => {}) {\n      this.walkAndSkipNestedComponents(rootEl, el => {\n        // Don't touch spawns from for loop (and check if the root is actually a for loop in a parent, don't skip it.)\n        if (el.__x_for_key !== undefined && !el.isSameNode(this.$el)) return false;\n        this.updateElement(el, extraVars);\n      }, el => {\n        el.__x = new Component(el);\n      });\n      this.executeAndClearRemainingShowDirectiveStack();\n      this.executeAndClearNextTickStack(rootEl);\n    }\n\n    executeAndClearNextTickStack(el) {\n      // Skip spawns from alpine directives\n      if (el === this.$el && this.nextTickStack.length > 0) {\n        // We run the tick stack after the next frame to allow any\n        // running transitions to pass the initial show stage.\n        requestAnimationFrame(() => {\n          while (this.nextTickStack.length > 0) {\n            this.nextTickStack.shift()();\n          }\n        });\n      }\n    }\n\n    executeAndClearRemainingShowDirectiveStack() {\n      // The goal here is to start all the x-show transitions\n      // and build a nested promise chain so that elements\n      // only hide when the children are finished hiding.\n      this.showDirectiveStack.reverse().map(handler => {\n        return new Promise((resolve, reject) => {\n          handler(resolve, reject);\n        });\n      }).reduce((promiseChain, promise) => {\n        return promiseChain.then(() => {\n          return promise.then(finishElement => {\n            finishElement();\n          });\n        });\n      }, Promise.resolve(() => {})).catch(e => {\n        if (e !== TRANSITION_CANCELLED) throw e;\n      }); // We've processed the handler stack. let's clear it.\n\n      this.showDirectiveStack = [];\n      this.showDirectiveLastElement = undefined;\n    }\n\n    updateElement(el, extraVars) {\n      this.resolveBoundAttributes(el, false, extraVars);\n    }\n\n    registerListeners(el, extraVars) {\n      getXAttrs(el, this).forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'on':\n            registerListener(this, el, value, modifiers, expression, extraVars);\n            break;\n\n          case 'model':\n            registerModelListener(this, el, modifiers, expression, extraVars);\n            break;\n        }\n      });\n    }\n\n    resolveBoundAttributes(el, initialUpdate = false, extraVars) {\n      let attrs = getXAttrs(el, this);\n      attrs.forEach(({\n        type,\n        value,\n        modifiers,\n        expression\n      }) => {\n        switch (type) {\n          case 'model':\n            handleAttributeBindingDirective(this, el, 'value', expression, extraVars, type, modifiers);\n            break;\n\n          case 'bind':\n            // The :key binding on an x-for is special, ignore it.\n            if (el.tagName.toLowerCase() === 'template' && value === 'key') return;\n            handleAttributeBindingDirective(this, el, value, expression, extraVars, type, modifiers);\n            break;\n\n          case 'text':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleTextDirective(el, output, expression);\n            break;\n\n          case 'html':\n            handleHtmlDirective(this, el, expression, extraVars);\n            break;\n\n          case 'show':\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleShowDirective(this, el, output, modifiers, initialUpdate);\n            break;\n\n          case 'if':\n            // If this element also has x-for on it, don't process x-if.\n            // We will let the \"x-for\" directive handle the \"if\"ing.\n            if (attrs.some(i => i.type === 'for')) return;\n            var output = this.evaluateReturnExpression(el, expression, extraVars);\n            handleIfDirective(this, el, output, initialUpdate, extraVars);\n            break;\n\n          case 'for':\n            handleForDirective(this, el, expression, initialUpdate, extraVars);\n            break;\n\n          case 'cloak':\n            el.removeAttribute('x-cloak');\n            break;\n        }\n      });\n    }\n\n    evaluateReturnExpression(el, expression, extraVars = () => {}) {\n      return saferEval(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    evaluateCommandExpression(el, expression, extraVars = () => {}) {\n      return saferEvalNoReturn(el, expression, this.$data, _objectSpread2(_objectSpread2({}, extraVars()), {}, {\n        $dispatch: this.getDispatchFunction(el)\n      }));\n    }\n\n    getDispatchFunction(el) {\n      return (event, detail = {}) => {\n        el.dispatchEvent(new CustomEvent(event, {\n          detail,\n          bubbles: true\n        }));\n      };\n    }\n\n    listenForNewElementsToInitialize() {\n      const targetNode = this.$el;\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        for (let i = 0; i < mutations.length; i++) {\n          // Filter out mutations triggered from child components.\n          const closestParentComponent = mutations[i].target.closest('[x-data]');\n          if (!(closestParentComponent && closestParentComponent.isSameNode(this.$el))) continue;\n\n          if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'x-data') {\n            const xAttr = mutations[i].target.getAttribute('x-data') || '{}';\n            const rawData = saferEval(this.$el, xAttr, {\n              $el: this.$el\n            });\n            Object.keys(rawData).forEach(key => {\n              if (this.$data[key] !== rawData[key]) {\n                this.$data[key] = rawData[key];\n              }\n            });\n          }\n\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              if (node.nodeType !== 1 || node.__x_inserted_me) return;\n\n              if (node.matches('[x-data]') && !node.__x) {\n                node.__x = new Component(node);\n                return;\n              }\n\n              this.initializeElements(node);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    }\n\n    getRefsProxy() {\n      var self = this;\n      var refObj = {};\n      // One of the goals of this is to not hold elements in memory, but rather re-evaluate\n      // the DOM when the system needs something from it. This way, the framework is flexible and\n      // friendly to outside DOM changes from libraries like Vue/Livewire.\n      // For this reason, I'm using an \"on-demand\" proxy to fake a \"$refs\" object.\n\n      return new Proxy(refObj, {\n        get(object, property) {\n          if (property === '$isAlpineProxy') return true;\n          var ref; // We can't just query the DOM because it's hard to filter out refs in\n          // nested components.\n\n          self.walkAndSkipNestedComponents(self.$el, el => {\n            if (el.hasAttribute('x-ref') && el.getAttribute('x-ref') === property) {\n              ref = el;\n            }\n          });\n          return ref;\n        }\n\n      });\n    }\n\n  }\n\n  const Alpine = {\n    version: \"2.8.2\",\n    pauseMutationObserver: false,\n    magicProperties: {},\n    onComponentInitializeds: [],\n    onBeforeComponentInitializeds: [],\n    ignoreFocusedForValueBinding: false,\n    start: async function start() {\n      if (!isTesting()) {\n        await domReady();\n      }\n\n      this.discoverComponents(el => {\n        this.initializeComponent(el);\n      }); // It's easier and more performant to just support Turbolinks than listen\n      // to MutationObserver mutations at the document level.\n\n      document.addEventListener(\"turbolinks:load\", () => {\n        this.discoverUninitializedComponents(el => {\n          this.initializeComponent(el);\n        });\n      });\n      this.listenForNewUninitializedComponentsAtRunTime();\n    },\n    discoverComponents: function discoverComponents(callback) {\n      const rootEls = document.querySelectorAll('[x-data]');\n      rootEls.forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    discoverUninitializedComponents: function discoverUninitializedComponents(callback, el = null) {\n      const rootEls = (el || document).querySelectorAll('[x-data]');\n      Array.from(rootEls).filter(el => el.__x === undefined).forEach(rootEl => {\n        callback(rootEl);\n      });\n    },\n    listenForNewUninitializedComponentsAtRunTime: function listenForNewUninitializedComponentsAtRunTime() {\n      const targetNode = document.querySelector('body');\n      const observerOptions = {\n        childList: true,\n        attributes: true,\n        subtree: true\n      };\n      const observer = new MutationObserver(mutations => {\n        if (this.pauseMutationObserver) return;\n\n        for (let i = 0; i < mutations.length; i++) {\n          if (mutations[i].addedNodes.length > 0) {\n            mutations[i].addedNodes.forEach(node => {\n              // Discard non-element nodes (like line-breaks)\n              if (node.nodeType !== 1) return; // Discard any changes happening within an existing component.\n              // They will take care of themselves.\n\n              if (node.parentElement && node.parentElement.closest('[x-data]')) return;\n              this.discoverUninitializedComponents(el => {\n                this.initializeComponent(el);\n              }, node.parentElement);\n            });\n          }\n        }\n      });\n      observer.observe(targetNode, observerOptions);\n    },\n    initializeComponent: function initializeComponent(el) {\n      if (!el.__x) {\n        // Wrap in a try/catch so that we don't prevent other components\n        // from initializing when one component contains an error.\n        try {\n          el.__x = new Component(el);\n        } catch (error) {\n          setTimeout(() => {\n            throw error;\n          }, 0);\n        }\n      }\n    },\n    clone: function clone(component, newEl) {\n      if (!newEl.__x) {\n        newEl.__x = new Component(newEl, component);\n      }\n    },\n    addMagicProperty: function addMagicProperty(name, callback) {\n      this.magicProperties[name] = callback;\n    },\n    onComponentInitialized: function onComponentInitialized(callback) {\n      this.onComponentInitializeds.push(callback);\n    },\n    onBeforeComponentInitialized: function onBeforeComponentInitialized(callback) {\n      this.onBeforeComponentInitializeds.push(callback);\n    }\n  };\n\n  if (!isTesting()) {\n    window.Alpine = Alpine;\n\n    if (window.deferLoadingAlpine) {\n      window.deferLoadingAlpine(function () {\n        window.Alpine.start();\n      });\n    } else {\n      window.Alpine.start();\n    }\n  }\n\n  return Alpine;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxwaW5lanMvZGlzdC9hbHBpbmUuanM/ZGYyNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxDQUNvRDtBQUN0RCxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVSw4RkFBOEYsVUFBVTtBQUNqSixLQUFLO0FBQ0wsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxNQUFNLG9CQUFvQixXQUFXOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QztBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hbHBpbmVqcy9kaXN0L2FscGluZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuQWxwaW5lID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgICAgaWYgKGkgJSAyKSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLy8gVGhhbmtzIEBzdGltdWx1czpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N0aW11bHVzanMvc3RpbXVsdXMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvJTQwc3RpbXVsdXMvY29yZS9zcmMvYXBwbGljYXRpb24udHNcbiAgZnVuY3Rpb24gZG9tUmVhZHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgcmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlVbmlxdWUoYXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGFycmF5KSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNUZXN0aW5nKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiTm9kZS5qc1wiKSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwianNkb21cIik7XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUodmFsdWVBLCB2YWx1ZUIpIHtcbiAgICByZXR1cm4gdmFsdWVBID09IHZhbHVlQjtcbiAgfVxuICBmdW5jdGlvbiB3YXJuSWZNYWxmb3JtZWRUZW1wbGF0ZShlbCwgZGlyZWN0aXZlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RlbXBsYXRlJykge1xuICAgICAgY29uc29sZS53YXJuKGBBbHBpbmU6IFske2RpcmVjdGl2ZX1dIGRpcmVjdGl2ZSBzaG91bGQgb25seSBiZSBhZGRlZCB0byA8dGVtcGxhdGU+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYWxwaW5lanMvYWxwaW5lIyR7ZGlyZWN0aXZlfWApO1xuICAgIH0gZWxzZSBpZiAoZWwuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudCAhPT0gMSkge1xuICAgICAgY29uc29sZS53YXJuKGBBbHBpbmU6IDx0ZW1wbGF0ZT4gdGFnIHdpdGggWyR7ZGlyZWN0aXZlfV0gZW5jb3VudGVyZWQgd2l0aCBhbiB1bmV4cGVjdGVkIG51bWJlciBvZiByb290IGVsZW1lbnRzLiBNYWtlIHN1cmUgPHRlbXBsYXRlPiBoYXMgYSBzaW5nbGUgcm9vdCBlbGVtZW50LiBgKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24ga2ViYWJDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS5yZXBsYWNlKC9bX1xcc10vLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gY2FtZWxDYXNlKHN1YmplY3QpIHtcbiAgICByZXR1cm4gc3ViamVjdC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oXFx3KS9nLCAobWF0Y2gsIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2FsayhlbCwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2soZWwpID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIGxldCBub2RlID0gZWwuZmlyc3RFbGVtZW50Q2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgd2Fsayhub2RlLCBjYWxsYmFjayk7XG4gICAgICBub2RlID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uIGxhdGVyKCkge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZWwsIGV4cHJlc3Npb24sIGVycm9yKSA9PiB7XG4gICAgY29uc29sZS53YXJuKGBBbHBpbmUgRXJyb3I6IFwiJHtlcnJvcn1cIlxcblxcbkV4cHJlc3Npb246IFwiJHtleHByZXNzaW9ufVwiXFxuRWxlbWVudDpgLCBlbCk7XG5cbiAgICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKGVycm9yLCB7XG4gICAgICAgIGVsLFxuICAgICAgICBleHByZXNzaW9uXG4gICAgICB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0cnlDYXRjaChjYiwge1xuICAgIGVsLFxuICAgIGV4cHJlc3Npb25cbiAgfSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNiKCk7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlID8gdmFsdWUuY2F0Y2goZSA9PiBoYW5kbGVFcnJvcihlbCwgZXhwcmVzc2lvbiwgZSkpIDogdmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZWwsIGV4cHJlc3Npb24sIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVyRXZhbChlbCwgZXhwcmVzc2lvbiwgZGF0YUNvbnRleHQsIGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMgPSB7fSkge1xuICAgIHJldHVybiB0cnlDYXRjaCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGV4cHJlc3Npb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uY2FsbChkYXRhQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oWyckZGF0YScsIC4uLk9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWxwZXJWYXJpYWJsZXMpXSwgYHZhciBfX2FscGluZV9yZXN1bHQ7IHdpdGgoJGRhdGEpIHsgX19hbHBpbmVfcmVzdWx0ID0gJHtleHByZXNzaW9ufSB9OyByZXR1cm4gX19hbHBpbmVfcmVzdWx0YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpO1xuICAgIH0sIHtcbiAgICAgIGVsLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNhZmVyRXZhbE5vUmV0dXJuKGVsLCBleHByZXNzaW9uLCBkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyA9IHt9KSB7XG4gICAgcmV0dXJuIHRyeUNhdGNoKCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV4cHJlc3Npb24uY2FsbChkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlc1snJGV2ZW50J10pKTtcbiAgICAgIH1cblxuICAgICAgbGV0IEFzeW5jRnVuY3Rpb24gPSBGdW5jdGlvbjtcbiAgICAgIC8qIE1PREVSTi1PTkxZOlNUQVJUICovXG5cbiAgICAgIEFzeW5jRnVuY3Rpb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYXN5bmMgZnVuY3Rpb24gKCkge30pLmNvbnN0cnVjdG9yO1xuICAgICAgLyogTU9ERVJOLU9OTFk6RU5EICovXG4gICAgICAvLyBGb3IgdGhlIGNhc2VzIHdoZW4gdXNlcnMgcGFzcyBvbmx5IGEgZnVuY3Rpb24gcmVmZXJlbmNlIHRvIHRoZSBjYWxsZXI6IGB4LW9uOmNsaWNrPVwiZm9vXCJgXG4gICAgICAvLyBXaGVyZSBcImZvb1wiIGlzIGEgZnVuY3Rpb24uIEFsc28sIHdlJ2xsIHBhc3MgdGhlIGZ1bmN0aW9uIHRoZSBldmVudCBpbnN0YW5jZSB3aGVuIHdlIGNhbGwgaXQuXG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyhkYXRhQ29udGV4dCkuaW5jbHVkZXMoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgbGV0IG1ldGhvZFJlZmVyZW5jZSA9IG5ldyBGdW5jdGlvbihbJ2RhdGFDb250ZXh0JywgLi4uT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyldLCBgd2l0aChkYXRhQ29udGV4dCkgeyByZXR1cm4gJHtleHByZXNzaW9ufSB9YCkoZGF0YUNvbnRleHQsIC4uLk9iamVjdC52YWx1ZXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcykpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kUmVmZXJlbmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXRob2RSZWZlcmVuY2UuY2FsbChkYXRhQ29udGV4dCwgYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlc1snJGV2ZW50J10pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQXN5bmNGdW5jdGlvbihbJ2RhdGFDb250ZXh0JywgLi4uT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlbHBlclZhcmlhYmxlcyldLCBgd2l0aChkYXRhQ29udGV4dCkgeyAke2V4cHJlc3Npb259IH1gKShkYXRhQ29udGV4dCwgLi4uT2JqZWN0LnZhbHVlcyhhZGRpdGlvbmFsSGVscGVyVmFyaWFibGVzKSkpO1xuICAgIH0sIHtcbiAgICAgIGVsLFxuICAgICAgZXhwcmVzc2lvblxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHhBdHRyUkUgPSAvXngtKG9ufGJpbmR8ZGF0YXx0ZXh0fGh0bWx8bW9kZWx8aWZ8Zm9yfHNob3d8Y2xvYWt8dHJhbnNpdGlvbnxyZWZ8c3ByZWFkKVxcYi87XG4gIGZ1bmN0aW9uIGlzWEF0dHIoYXR0cikge1xuICAgIGNvbnN0IG5hbWUgPSByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChhdHRyLm5hbWUpO1xuICAgIHJldHVybiB4QXR0clJFLnRlc3QobmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0WEF0dHJzKGVsLCBjb21wb25lbnQsIHR5cGUpIHtcbiAgICBsZXQgZGlyZWN0aXZlcyA9IEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZmlsdGVyKGlzWEF0dHIpLm1hcChwYXJzZUh0bWxBdHRyaWJ1dGUpOyAvLyBHZXQgYW4gb2JqZWN0IG9mIGRpcmVjdGl2ZXMgZnJvbSB4LXNwcmVhZC5cblxuICAgIGxldCBzcHJlYWREaXJlY3RpdmUgPSBkaXJlY3RpdmVzLmZpbHRlcihkaXJlY3RpdmUgPT4gZGlyZWN0aXZlLnR5cGUgPT09ICdzcHJlYWQnKVswXTtcblxuICAgIGlmIChzcHJlYWREaXJlY3RpdmUpIHtcbiAgICAgIGxldCBzcHJlYWRPYmplY3QgPSBzYWZlckV2YWwoZWwsIHNwcmVhZERpcmVjdGl2ZS5leHByZXNzaW9uLCBjb21wb25lbnQuJGRhdGEpOyAvLyBBZGQgeC1zcHJlYWQgZGlyZWN0aXZlcyB0byB0aGUgcGlsZSBvZiBleGlzdGluZyBkaXJlY3RpdmVzLlxuXG4gICAgICBkaXJlY3RpdmVzID0gZGlyZWN0aXZlcy5jb25jYXQoT2JqZWN0LmVudHJpZXMoc3ByZWFkT2JqZWN0KS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IHBhcnNlSHRtbEF0dHJpYnV0ZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSByZXR1cm4gZGlyZWN0aXZlcy5maWx0ZXIoaSA9PiBpLnR5cGUgPT09IHR5cGUpO1xuICAgIHJldHVybiBzb3J0RGlyZWN0aXZlcyhkaXJlY3RpdmVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnREaXJlY3RpdmVzKGRpcmVjdGl2ZXMpIHtcbiAgICBsZXQgZGlyZWN0aXZlT3JkZXIgPSBbJ2JpbmQnLCAnbW9kZWwnLCAnc2hvdycsICdjYXRjaC1hbGwnXTtcbiAgICByZXR1cm4gZGlyZWN0aXZlcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBsZXQgdHlwZUEgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGEudHlwZSkgPT09IC0xID8gJ2NhdGNoLWFsbCcgOiBhLnR5cGU7XG4gICAgICBsZXQgdHlwZUIgPSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKGIudHlwZSkgPT09IC0xID8gJ2NhdGNoLWFsbCcgOiBiLnR5cGU7XG4gICAgICByZXR1cm4gZGlyZWN0aXZlT3JkZXIuaW5kZXhPZih0eXBlQSkgLSBkaXJlY3RpdmVPcmRlci5pbmRleE9mKHR5cGVCKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSHRtbEF0dHJpYnV0ZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE5hbWUgPSByZXBsYWNlQXRBbmRDb2xvbldpdGhTdGFuZGFyZFN5bnRheChuYW1lKTtcbiAgICBjb25zdCB0eXBlTWF0Y2ggPSBub3JtYWxpemVkTmFtZS5tYXRjaCh4QXR0clJFKTtcbiAgICBjb25zdCB2YWx1ZU1hdGNoID0gbm9ybWFsaXplZE5hbWUubWF0Y2goLzooW2EtekEtWjAtOVxcLTpdKykvKTtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBub3JtYWxpemVkTmFtZS5tYXRjaCgvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZykgfHwgW107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHR5cGVNYXRjaCA/IHR5cGVNYXRjaFsxXSA6IG51bGwsXG4gICAgICB2YWx1ZTogdmFsdWVNYXRjaCA/IHZhbHVlTWF0Y2hbMV0gOiBudWxsLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnMubWFwKGkgPT4gaS5yZXBsYWNlKCcuJywgJycpKSxcbiAgICAgIGV4cHJlc3Npb246IHZhbHVlXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc0Jvb2xlYW5BdHRyKGF0dHJOYW1lKSB7XG4gICAgLy8gQXMgcGVyIEhUTUwgc3BlYyB0YWJsZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjYXR0cmlidXRlcy0zOmJvb2xlYW4tYXR0cmlidXRlXG4gICAgLy8gQXJyYXkgcm91Z2hseSBvcmRlcmVkIGJ5IGVzdGltYXRlZCB1c2FnZVxuICAgIGNvbnN0IGJvb2xlYW5BdHRyaWJ1dGVzID0gWydkaXNhYmxlZCcsICdjaGVja2VkJywgJ3JlcXVpcmVkJywgJ3JlYWRvbmx5JywgJ2hpZGRlbicsICdvcGVuJywgJ3NlbGVjdGVkJywgJ2F1dG9mb2N1cycsICdpdGVtc2NvcGUnLCAnbXVsdGlwbGUnLCAnbm92YWxpZGF0ZScsICdhbGxvd2Z1bGxzY3JlZW4nLCAnYWxsb3dwYXltZW50cmVxdWVzdCcsICdmb3Jtbm92YWxpZGF0ZScsICdhdXRvcGxheScsICdjb250cm9scycsICdsb29wJywgJ211dGVkJywgJ3BsYXlzaW5saW5lJywgJ2RlZmF1bHQnLCAnaXNtYXAnLCAncmV2ZXJzZWQnLCAnYXN5bmMnLCAnZGVmZXInLCAnbm9tb2R1bGUnXTtcbiAgICByZXR1cm4gYm9vbGVhbkF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0ck5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlcGxhY2VBdEFuZENvbG9uV2l0aFN0YW5kYXJkU3ludGF4KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdAJykpIHtcbiAgICAgIHJldHVybiBuYW1lLnJlcGxhY2UoJ0AnLCAneC1vbjonKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKCc6JywgJ3gtYmluZDonKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuICBmdW5jdGlvbiBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGNsYXNzTGlzdCwgZmlsdGVyRm4gPSBCb29sZWFuKSB7XG4gICAgcmV0dXJuIGNsYXNzTGlzdC5zcGxpdCgnICcpLmZpbHRlcihmaWx0ZXJGbik7XG4gIH1cbiAgY29uc3QgVFJBTlNJVElPTl9UWVBFX0lOID0gJ2luJztcbiAgY29uc3QgVFJBTlNJVElPTl9UWVBFX09VVCA9ICdvdXQnO1xuICBjb25zdCBUUkFOU0lUSU9OX0NBTkNFTExFRCA9ICdjYW5jZWxsZWQnO1xuICBmdW5jdGlvbiB0cmFuc2l0aW9uSW4oZWwsIHNob3csIHJlamVjdCwgY29tcG9uZW50LCBmb3JjZVNraXAgPSBmYWxzZSkge1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJhbnNpdGlvbiBvbiB0aGUgaW5pdGlhbCBwYWdlIGxvYWQuXG4gICAgaWYgKGZvcmNlU2tpcCkgcmV0dXJuIHNob3coKTtcblxuICAgIGlmIChlbC5fX3hfdHJhbnNpdGlvbiAmJiBlbC5fX3hfdHJhbnNpdGlvbi50eXBlID09PSBUUkFOU0lUSU9OX1RZUEVfSU4pIHtcbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBzaW1pbGFyIHRyYW5zaXRpb24gZ29pbmcgb24sIHRoaXMgd2FzIHByb2JhYmx5IHRyaWdnZXJlZCBieVxuICAgICAgLy8gYSBjaGFuZ2UgaW4gYSBkaWZmZXJlbnQgcHJvcGVydHksIGxldCdzIGp1c3QgbGVhdmUgdGhlIHByZXZpb3VzIG9uZSBkb2luZyBpdHMgam9iXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cnMgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3RyYW5zaXRpb24nKTtcbiAgICBjb25zdCBzaG93QXR0ciA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnc2hvdycpWzBdOyAvLyBJZiB0aGlzIGlzIHRyaWdnZXJlZCBieSBhIHgtc2hvdy50cmFuc2l0aW9uLlxuXG4gICAgaWYgKHNob3dBdHRyICYmIHNob3dBdHRyLm1vZGlmaWVycy5pbmNsdWRlcygndHJhbnNpdGlvbicpKSB7XG4gICAgICBsZXQgbW9kaWZpZXJzID0gc2hvd0F0dHIubW9kaWZpZXJzOyAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5vdXQsIHdlJ2xsIHNraXAgdGhlIFwiaW5cIiB0cmFuc2l0aW9uLlxuXG4gICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdpbicpKSByZXR1cm4gc2hvdygpO1xuICAgICAgY29uc3Qgc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA9IG1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSAmJiBtb2RpZmllcnMuaW5jbHVkZXMoJ291dCcpOyAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5pbi4uLm91dC4uLiBvbmx5IHVzZSBcImluXCIgcmVsYXRlZCBtb2RpZmllcnMgZm9yIHRoaXMgdHJhbnNpdGlvbi5cblxuICAgICAgbW9kaWZpZXJzID0gc2V0dGluZ0JvdGhTaWRlc09mVHJhbnNpdGlvbiA/IG1vZGlmaWVycy5maWx0ZXIoKGksIGluZGV4KSA9PiBpbmRleCA8IG1vZGlmaWVycy5pbmRleE9mKCdvdXQnKSkgOiBtb2RpZmllcnM7XG4gICAgICB0cmFuc2l0aW9uSGVscGVySW4oZWwsIG1vZGlmaWVycywgc2hvdywgcmVqZWN0KTsgLy8gT3RoZXJ3aXNlLCB3ZSBjYW4gYXNzdW1lIHgtdHJhbnNpdGlvbjplbnRlci5cbiAgICB9IGVsc2UgaWYgKGF0dHJzLnNvbWUoYXR0ciA9PiBbJ2VudGVyJywgJ2VudGVyLXN0YXJ0JywgJ2VudGVyLWVuZCddLmluY2x1ZGVzKGF0dHIudmFsdWUpKSkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXNJbihlbCwgY29tcG9uZW50LCBhdHRycywgc2hvdywgcmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbmVpdGhlciwganVzdCBzaG93IHRoYXQgZGFtbiB0aGluZy5cbiAgICAgIHNob3coKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbk91dChlbCwgaGlkZSwgcmVqZWN0LCBjb21wb25lbnQsIGZvcmNlU2tpcCA9IGZhbHNlKSB7XG4gICAgLy8gV2UgZG9uJ3Qgd2FudCB0byB0cmFuc2l0aW9uIG9uIHRoZSBpbml0aWFsIHBhZ2UgbG9hZC5cbiAgICBpZiAoZm9yY2VTa2lwKSByZXR1cm4gaGlkZSgpO1xuXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uICYmIGVsLl9feF90cmFuc2l0aW9uLnR5cGUgPT09IFRSQU5TSVRJT05fVFlQRV9PVVQpIHtcbiAgICAgIC8vIHRoZXJlIGlzIGFscmVhZHkgYSBzaW1pbGFyIHRyYW5zaXRpb24gZ29pbmcgb24sIHRoaXMgd2FzIHByb2JhYmx5IHRyaWdnZXJlZCBieVxuICAgICAgLy8gYSBjaGFuZ2UgaW4gYSBkaWZmZXJlbnQgcHJvcGVydHksIGxldCdzIGp1c3QgbGVhdmUgdGhlIHByZXZpb3VzIG9uZSBkb2luZyBpdHMgam9iXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cnMgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ3RyYW5zaXRpb24nKTtcbiAgICBjb25zdCBzaG93QXR0ciA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnc2hvdycpWzBdO1xuXG4gICAgaWYgKHNob3dBdHRyICYmIHNob3dBdHRyLm1vZGlmaWVycy5pbmNsdWRlcygndHJhbnNpdGlvbicpKSB7XG4gICAgICBsZXQgbW9kaWZpZXJzID0gc2hvd0F0dHIubW9kaWZpZXJzO1xuICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnaW4nKSAmJiAhbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKSkgcmV0dXJuIGhpZGUoKTtcbiAgICAgIGNvbnN0IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2luJykgJiYgbW9kaWZpZXJzLmluY2x1ZGVzKCdvdXQnKTtcbiAgICAgIG1vZGlmaWVycyA9IHNldHRpbmdCb3RoU2lkZXNPZlRyYW5zaXRpb24gPyBtb2RpZmllcnMuZmlsdGVyKChpLCBpbmRleCkgPT4gaW5kZXggPiBtb2RpZmllcnMuaW5kZXhPZignb3V0JykpIDogbW9kaWZpZXJzO1xuICAgICAgdHJhbnNpdGlvbkhlbHBlck91dChlbCwgbW9kaWZpZXJzLCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uLCBoaWRlLCByZWplY3QpO1xuICAgIH0gZWxzZSBpZiAoYXR0cnMuc29tZShhdHRyID0+IFsnbGVhdmUnLCAnbGVhdmUtc3RhcnQnLCAnbGVhdmUtZW5kJ10uaW5jbHVkZXMoYXR0ci52YWx1ZSkpKSB7XG4gICAgICB0cmFuc2l0aW9uQ2xhc3Nlc091dChlbCwgY29tcG9uZW50LCBhdHRycywgaGlkZSwgcmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlkZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSGVscGVySW4oZWwsIG1vZGlmaWVycywgc2hvd0NhbGxiYWNrLCByZWplY3QpIHtcbiAgICAvLyBEZWZhdWx0IHZhbHVlcyBpbnNwaXJlZCBieTogaHR0cHM6Ly9tYXRlcmlhbC5pby9kZXNpZ24vbW90aW9uL3NwZWVkLmh0bWwjZHVyYXRpb25cbiAgICBjb25zdCBzdHlsZVZhbHVlcyA9IHtcbiAgICAgIGR1cmF0aW9uOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ2R1cmF0aW9uJywgMTUwKSxcbiAgICAgIG9yaWdpbjogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdvcmlnaW4nLCAnY2VudGVyJyksXG4gICAgICBmaXJzdDoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZTogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdzY2FsZScsIDk1KVxuICAgICAgfSxcbiAgICAgIHNlY29uZDoge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzY2FsZTogMTAwXG4gICAgICB9XG4gICAgfTtcbiAgICB0cmFuc2l0aW9uSGVscGVyKGVsLCBtb2RpZmllcnMsIHNob3dDYWxsYmFjaywgKCkgPT4ge30sIHJlamVjdCwgc3R5bGVWYWx1ZXMsIFRSQU5TSVRJT05fVFlQRV9JTik7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlck91dChlbCwgbW9kaWZpZXJzLCBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uLCBoaWRlQ2FsbGJhY2ssIHJlamVjdCkge1xuICAgIC8vIE1ha2UgdGhlIFwib3V0XCIgdHJhbnNpdGlvbiAuNXggc2xvd2VyIHRoYW4gdGhlIFwiaW5cIi4gKFZpc3VhbGx5IGJldHRlcilcbiAgICAvLyBIT1dFVkVSLCBpZiB0aGV5IGV4cGxpY2l0bHkgc2V0IGEgZHVyYXRpb24gZm9yIHRoZSBcIm91dFwiIHRyYW5zaXRpb24sXG4gICAgLy8gdXNlIHRoYXQuXG4gICAgY29uc3QgZHVyYXRpb24gPSBzZXR0aW5nQm90aFNpZGVzT2ZUcmFuc2l0aW9uID8gbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdkdXJhdGlvbicsIDE1MCkgOiBtb2RpZmllclZhbHVlKG1vZGlmaWVycywgJ2R1cmF0aW9uJywgMTUwKSAvIDI7XG4gICAgY29uc3Qgc3R5bGVWYWx1ZXMgPSB7XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICBvcmlnaW46IG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCAnb3JpZ2luJywgJ2NlbnRlcicpLFxuICAgICAgZmlyc3Q6IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc2NhbGU6IDEwMFxuICAgICAgfSxcbiAgICAgIHNlY29uZDoge1xuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBzY2FsZTogbW9kaWZpZXJWYWx1ZShtb2RpZmllcnMsICdzY2FsZScsIDk1KVxuICAgICAgfVxuICAgIH07XG4gICAgdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCAoKSA9PiB7fSwgaGlkZUNhbGxiYWNrLCByZWplY3QsIHN0eWxlVmFsdWVzLCBUUkFOU0lUSU9OX1RZUEVfT1VUKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vZGlmaWVyVmFsdWUobW9kaWZpZXJzLCBrZXksIGZhbGxiYWNrKSB7XG4gICAgLy8gSWYgdGhlIG1vZGlmaWVyIGlzbid0IHByZXNlbnQsIHVzZSB0aGUgZGVmYXVsdC5cbiAgICBpZiAobW9kaWZpZXJzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHJldHVybiBmYWxsYmFjazsgLy8gSWYgaXQgSVMgcHJlc2VudCwgZ3JhYiB0aGUgdmFsdWUgYWZ0ZXIgaXQ6IHgtc2hvdy50cmFuc2l0aW9uLmR1cmF0aW9uLjUwMG1zXG5cbiAgICBjb25zdCByYXdWYWx1ZSA9IG1vZGlmaWVyc1ttb2RpZmllcnMuaW5kZXhPZihrZXkpICsgMV07XG4gICAgaWYgKCFyYXdWYWx1ZSkgcmV0dXJuIGZhbGxiYWNrO1xuXG4gICAgaWYgKGtleSA9PT0gJ3NjYWxlJykge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHZlcnkgbmV4dCB2YWx1ZSBpcyBOT1QgYSBudW1iZXIgYW5kIHJldHVybiB0aGUgZmFsbGJhY2suXG4gICAgICAvLyBJZiB4LXNob3cudHJhbnNpdGlvbi5zY2FsZSwgd2UnbGwgdXNlIHRoZSBkZWZhdWx0IHNjYWxlIHZhbHVlLlxuICAgICAgLy8gVGhhdCBpcyBob3cgYSB1c2VyIG9wdHMgb3V0IG9mIHRoZSBvcGFjaXR5IHRyYW5zaXRpb24uXG4gICAgICBpZiAoIWlzTnVtZXJpYyhyYXdWYWx1ZSkpIHJldHVybiBmYWxsYmFjaztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAvLyBTdXBwb3J0IHgtc2hvdy50cmFuc2l0aW9uLmR1cmF0aW9uLjUwMG1zICYmIGR1cmF0aW9uLjUwMFxuICAgICAgbGV0IG1hdGNoID0gcmF3VmFsdWUubWF0Y2goLyhbMC05XSspbXMvKTtcbiAgICAgIGlmIChtYXRjaCkgcmV0dXJuIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdvcmlnaW4nKSB7XG4gICAgICAvLyBTdXBwb3J0IGNoYWluaW5nIG9yaWdpbiBkaXJlY3Rpb25zOiB4LXNob3cudHJhbnNpdGlvbi50b3AucmlnaHRcbiAgICAgIGlmIChbJ3RvcCcsICdyaWdodCcsICdsZWZ0JywgJ2NlbnRlcicsICdib3R0b20nXS5pbmNsdWRlcyhtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdKSkge1xuICAgICAgICByZXR1cm4gW3Jhd1ZhbHVlLCBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2Yoa2V5KSArIDJdXS5qb2luKCcgJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd1ZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlcihlbCwgbW9kaWZpZXJzLCBob29rMSwgaG9vazIsIHJlamVjdCwgc3R5bGVWYWx1ZXMsIHR5cGUpIHtcbiAgICAvLyBjbGVhciB0aGUgcHJldmlvdXMgdHJhbnNpdGlvbiBpZiBleGlzdHMgdG8gYXZvaWQgY2FjaGluZyB0aGUgd3Jvbmcgc3R5bGVzXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uKSB7XG4gICAgICBlbC5fX3hfdHJhbnNpdGlvbi5jYW5jZWwgJiYgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgfSAvLyBJZiB0aGUgdXNlciBzZXQgdGhlc2Ugc3R5bGUgdmFsdWVzLCB3ZSdsbCBwdXQgdGhlbSBiYWNrIHdoZW4gd2UncmUgZG9uZSB3aXRoIHRoZW0uXG5cblxuICAgIGNvbnN0IG9wYWNpdHlDYWNoZSA9IGVsLnN0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2FjaGUgPSBlbC5zdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3QgdHJhbnNmb3JtT3JpZ2luQ2FjaGUgPSBlbC5zdHlsZS50cmFuc2Zvcm1PcmlnaW47IC8vIElmIG5vIG1vZGlmaWVycyBhcmUgcHJlc2VudDogeC1zaG93LnRyYW5zaXRpb24sIHdlJ2xsIGRlZmF1bHQgdG8gYm90aCBvcGFjaXR5IGFuZCBzY2FsZS5cblxuICAgIGNvbnN0IG5vTW9kaWZpZXJzID0gIW1vZGlmaWVycy5pbmNsdWRlcygnb3BhY2l0eScpICYmICFtb2RpZmllcnMuaW5jbHVkZXMoJ3NjYWxlJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbk9wYWNpdHkgPSBub01vZGlmaWVycyB8fCBtb2RpZmllcnMuaW5jbHVkZXMoJ29wYWNpdHknKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uU2NhbGUgPSBub01vZGlmaWVycyB8fCBtb2RpZmllcnMuaW5jbHVkZXMoJ3NjYWxlJyk7IC8vIFRoZXNlIGFyZSB0aGUgZXhwbGljaXQgc3RhZ2VzIG9mIGEgdHJhbnNpdGlvbiAoc2FtZSBzdGFnZXMgZm9yIGluIGFuZCBmb3Igb3V0KS5cbiAgICAvLyBUaGlzIHdheSB5b3UgY2FuIGdldCBhIGJpcmRzIGV5ZSB2aWV3IG9mIHRoZSBob29rcywgYW5kIHRoZSBkaWZmZXJlbmNlc1xuICAgIC8vIGJldHdlZW4gdGhlbS5cblxuICAgIGNvbnN0IHN0YWdlcyA9IHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodHJhbnNpdGlvbk9wYWNpdHkpIGVsLnN0eWxlLm9wYWNpdHkgPSBzdHlsZVZhbHVlcy5maXJzdC5vcGFjaXR5O1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzdHlsZVZhbHVlcy5maXJzdC5zY2FsZSAvIDEwMH0pYDtcbiAgICAgIH0sXG5cbiAgICAgIGR1cmluZygpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gc3R5bGVWYWx1ZXMub3JpZ2luO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBbdHJhbnNpdGlvbk9wYWNpdHkgPyBgb3BhY2l0eWAgOiBgYCwgdHJhbnNpdGlvblNjYWxlID8gYHRyYW5zZm9ybWAgOiBgYF0uam9pbignICcpLnRyaW0oKTtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gYCR7c3R5bGVWYWx1ZXMuZHVyYXRpb24gLyAxMDAwfXNgO1xuICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBgY3ViaWMtYmV6aWVyKDAuNCwgMC4wLCAwLjIsIDEpYDtcbiAgICAgIH0sXG5cbiAgICAgIHNob3coKSB7XG4gICAgICAgIGhvb2sxKCk7XG4gICAgICB9LFxuXG4gICAgICBlbmQoKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uT3BhY2l0eSkgZWwuc3R5bGUub3BhY2l0eSA9IHN0eWxlVmFsdWVzLnNlY29uZC5vcGFjaXR5O1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzdHlsZVZhbHVlcy5zZWNvbmQuc2NhbGUgLyAxMDB9KWA7XG4gICAgICB9LFxuXG4gICAgICBoaWRlKCkge1xuICAgICAgICBob29rMigpO1xuICAgICAgfSxcblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25PcGFjaXR5KSBlbC5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eUNhY2hlO1xuICAgICAgICBpZiAodHJhbnNpdGlvblNjYWxlKSBlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1DYWNoZTtcbiAgICAgICAgaWYgKHRyYW5zaXRpb25TY2FsZSkgZWwuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtT3JpZ2luQ2FjaGU7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25Qcm9wZXJ0eSA9IG51bGw7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KTtcbiAgfVxuXG4gIGNvbnN0IGVuc3VyZVN0cmluZ0V4cHJlc3Npb24gPSAoZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXBvbmVudC5ldmFsdWF0ZVJldHVybkV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24pIDogZXhwcmVzc2lvbjtcbiAgfTtcblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3Nlc0luKGVsLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIHNob3dDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgY29uc3QgZW50ZXIgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdlbnRlcicpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGVudGVyU3RhcnQgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdlbnRlci1zdGFydCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGVudGVyRW5kID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnZW50ZXItZW5kJykgfHwge1xuICAgICAgZXhwcmVzc2lvbjogJydcbiAgICB9KS5leHByZXNzaW9uLCBlbCwgY29tcG9uZW50KSk7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGVudGVyLCBlbnRlclN0YXJ0LCBlbnRlckVuZCwgc2hvd0NhbGxiYWNrLCAoKSA9PiB7fSwgVFJBTlNJVElPTl9UWVBFX0lOLCByZWplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25DbGFzc2VzT3V0KGVsLCBjb21wb25lbnQsIGRpcmVjdGl2ZXMsIGhpZGVDYWxsYmFjaywgcmVqZWN0KSB7XG4gICAgY29uc3QgbGVhdmUgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdsZWF2ZScpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGxlYXZlU3RhcnQgPSBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGVuc3VyZVN0cmluZ0V4cHJlc3Npb24oKGRpcmVjdGl2ZXMuZmluZChpID0+IGkudmFsdWUgPT09ICdsZWF2ZS1zdGFydCcpIHx8IHtcbiAgICAgIGV4cHJlc3Npb246ICcnXG4gICAgfSkuZXhwcmVzc2lvbiwgZWwsIGNvbXBvbmVudCkpO1xuICAgIGNvbnN0IGxlYXZlRW5kID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbnN1cmVTdHJpbmdFeHByZXNzaW9uKChkaXJlY3RpdmVzLmZpbmQoaSA9PiBpLnZhbHVlID09PSAnbGVhdmUtZW5kJykgfHwge1xuICAgICAgZXhwcmVzc2lvbjogJydcbiAgICB9KS5leHByZXNzaW9uLCBlbCwgY29tcG9uZW50KSk7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMoZWwsIGxlYXZlLCBsZWF2ZVN0YXJ0LCBsZWF2ZUVuZCwgKCkgPT4ge30sIGhpZGVDYWxsYmFjaywgVFJBTlNJVElPTl9UWVBFX09VVCwgcmVqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2l0aW9uQ2xhc3NlcyhlbCwgY2xhc3Nlc0R1cmluZywgY2xhc3Nlc1N0YXJ0LCBjbGFzc2VzRW5kLCBob29rMSwgaG9vazIsIHR5cGUsIHJlamVjdCkge1xuICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0cmFuc2l0aW9uIGlmIGV4aXN0cyB0byBhdm9pZCBjYWNoaW5nIHRoZSB3cm9uZyBjbGFzc2VzXG4gICAgaWYgKGVsLl9feF90cmFuc2l0aW9uKSB7XG4gICAgICBlbC5fX3hfdHJhbnNpdGlvbi5jYW5jZWwgJiYgZWwuX194X3RyYW5zaXRpb24uY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc2VzID0gZWwuX194X29yaWdpbmFsX2NsYXNzZXMgfHwgW107XG4gICAgY29uc3Qgc3RhZ2VzID0ge1xuICAgICAgc3RhcnQoKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc1N0YXJ0KTtcbiAgICAgIH0sXG5cbiAgICAgIGR1cmluZygpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzRHVyaW5nKTtcbiAgICAgIH0sXG5cbiAgICAgIHNob3coKSB7XG4gICAgICAgIGhvb2sxKCk7XG4gICAgICB9LFxuXG4gICAgICBlbmQoKSB7XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSBjbGFzc2VzIHRoYXQgd2VyZSBpbiB0aGUgb3JpZ2luYWwgY2xhc3MgYXR0cmlidXRlLlxuICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNTdGFydC5maWx0ZXIoaSA9PiAhb3JpZ2luYWxDbGFzc2VzLmluY2x1ZGVzKGkpKSk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3Nlc0VuZCk7XG4gICAgICB9LFxuXG4gICAgICBoaWRlKCkge1xuICAgICAgICBob29rMigpO1xuICAgICAgfSxcblxuICAgICAgY2xlYW51cCgpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzRHVyaW5nLmZpbHRlcihpID0+ICFvcmlnaW5hbENsYXNzZXMuaW5jbHVkZXMoaSkpKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzRW5kLmZpbHRlcihpID0+ICFvcmlnaW5hbENsYXNzZXMuaW5jbHVkZXMoaSkpKTtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdHJhbnNpdGlvbihlbCwgc3RhZ2VzLCB0eXBlLCByZWplY3QpO1xuICB9XG4gIGZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHN0YWdlcywgdHlwZSwgcmVqZWN0KSB7XG4gICAgY29uc3QgZmluaXNoID0gb25jZSgoKSA9PiB7XG4gICAgICBzdGFnZXMuaGlkZSgpOyAvLyBBZGRpbmcgYW4gXCJpc0Nvbm5lY3RlZFwiIGNoZWNrLCBpbiBjYXNlIHRoZSBjYWxsYmFja1xuICAgICAgLy8gcmVtb3ZlZCB0aGUgZWxlbWVudCBmcm9tIHRoZSBET00uXG5cbiAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICBzdGFnZXMuY2xlYW51cCgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgZWwuX194X3RyYW5zaXRpb247XG4gICAgfSk7XG4gICAgZWwuX194X3RyYW5zaXRpb24gPSB7XG4gICAgICAvLyBTZXQgdHJhbnNpdGlvbiB0eXBlIHNvIHdlIGNhbiBhdm9pZCBjbGVhcmluZyB0cmFuc2l0aW9uIGlmIHRoZSBkaXJlY3Rpb24gaXMgdGhlIHNhbWVcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAvLyBjcmVhdGUgYSBjYWxsYmFjayBmb3IgdGhlIGxhc3Qgc3RhZ2VzIG9mIHRoZSB0cmFuc2l0aW9uIHNvIHdlIGNhbiBjYWxsIGl0XG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBwb2ludCBhbmQgZWFybHkgdGVybWluYXRlIGl0LiBPbmNlIHdpbGwgZW5zdXJlIHRoYXQgZnVuY3Rpb25cbiAgICAgIC8vIGlzIG9ubHkgY2FsbGVkIG9uZSB0aW1lLlxuICAgICAgY2FuY2VsOiBvbmNlKCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFRSQU5TSVRJT05fQ0FOQ0VMTEVEKTtcbiAgICAgICAgZmluaXNoKCk7XG4gICAgICB9KSxcbiAgICAgIGZpbmlzaCxcbiAgICAgIC8vIFRoaXMgc3RvcmUgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lIHNvIHdlIGNhbiBjYW5jZWwgaXRcbiAgICAgIG5leHRGcmFtZTogbnVsbFxuICAgIH07XG4gICAgc3RhZ2VzLnN0YXJ0KCk7XG4gICAgc3RhZ2VzLmR1cmluZygpO1xuICAgIGVsLl9feF90cmFuc2l0aW9uLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOb3RlOiBTYWZhcmkncyB0cmFuc2l0aW9uRHVyYXRpb24gcHJvcGVydHkgd2lsbCBsaXN0IG91dCBjb21tYSBzZXBhcmF0ZWQgdHJhbnNpdGlvbiBkdXJhdGlvbnNcbiAgICAgIC8vIGZvciBldmVyeSBzaW5nbGUgdHJhbnNpdGlvbiBwcm9wZXJ0eS4gTGV0J3MgZ3JhYiB0aGUgZmlyc3Qgb25lIGFuZCBjYWxsIGl0IGEgZGF5LlxuICAgICAgbGV0IGR1cmF0aW9uID0gTnVtYmVyKGdldENvbXB1dGVkU3R5bGUoZWwpLnRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKC8sLiovLCAnJykucmVwbGFjZSgncycsICcnKSkgKiAxMDAwO1xuXG4gICAgICBpZiAoZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShlbCkuYW5pbWF0aW9uRHVyYXRpb24ucmVwbGFjZSgncycsICcnKSkgKiAxMDAwO1xuICAgICAgfVxuXG4gICAgICBzdGFnZXMuc2hvdygpO1xuICAgICAgZWwuX194X3RyYW5zaXRpb24ubmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgc3RhZ2VzLmVuZCgpO1xuICAgICAgICBzZXRUaW1lb3V0KGVsLl9feF90cmFuc2l0aW9uLmZpbmlzaCwgZHVyYXRpb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gaXNOdW1lcmljKHN1YmplY3QpIHtcbiAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc3ViamVjdCkgJiYgIWlzTmFOKHN1YmplY3QpO1xuICB9IC8vIFRoYW5rcyBAdnVlanNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9ibG9iLzRkZTQ2NDlkOTYzNzI2MmE5YjAwNzcyMGI1OWY4MGFjNzJhNTYyMGMvc3JjL3NoYXJlZC91dGlsLmpzXG5cbiAgZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRm9yRGlyZWN0aXZlKGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgZXhwcmVzc2lvbiwgaW5pdGlhbFVwZGF0ZSwgZXh0cmFWYXJzKSB7XG4gICAgd2FybklmTWFsZm9ybWVkVGVtcGxhdGUodGVtcGxhdGVFbCwgJ3gtZm9yJyk7XG4gICAgbGV0IGl0ZXJhdG9yTmFtZXMgPSB0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnNlRm9yRXhwcmVzc2lvbihjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKHRlbXBsYXRlRWwsIGV4cHJlc3Npb24pKSA6IHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICBsZXQgaXRlbXMgPSBldmFsdWF0ZUl0ZW1zQW5kUmV0dXJuRW1wdHlJZlhJZklzUHJlc2VudEFuZEZhbHNlT25FbGVtZW50KGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgaXRlcmF0b3JOYW1lcywgZXh0cmFWYXJzKTsgLy8gQXMgd2Ugd2FsayB0aGUgYXJyYXksIHdlJ2xsIGFsc28gd2FsayB0aGUgRE9NICh1cGRhdGluZy9jcmVhdGluZyBhcyB3ZSBnbykuXG5cbiAgICBsZXQgY3VycmVudEVsID0gdGVtcGxhdGVFbDtcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgbGV0IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzID0gZ2V0SXRlcmF0aW9uU2NvcGVWYXJpYWJsZXMoaXRlcmF0b3JOYW1lcywgaXRlbSwgaW5kZXgsIGl0ZW1zLCBleHRyYVZhcnMoKSk7XG4gICAgICBsZXQgY3VycmVudEtleSA9IGdlbmVyYXRlS2V5Rm9ySXRlcmF0aW9uKGNvbXBvbmVudCwgdGVtcGxhdGVFbCwgaW5kZXgsIGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKTtcbiAgICAgIGxldCBuZXh0RWwgPSBsb29rQWhlYWRGb3JNYXRjaGluZ0tleWVkRWxlbWVudEFuZE1vdmVJdElmRm91bmQoY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZywgY3VycmVudEtleSk7IC8vIElmIHdlIGhhdmVuJ3QgZm91bmQgYSBtYXRjaGluZyBrZXksIGluc2VydCB0aGUgZWxlbWVudCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cblxuICAgICAgaWYgKCFuZXh0RWwpIHtcbiAgICAgICAgbmV4dEVsID0gYWRkRWxlbWVudEluTG9vcEFmdGVyQ3VycmVudEVsKHRlbXBsYXRlRWwsIGN1cnJlbnRFbCk7IC8vIEFuZCB0cmFuc2l0aW9uIGl0IGluIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCBwYWdlIGxvYWQuXG5cbiAgICAgICAgdHJhbnNpdGlvbkluKG5leHRFbCwgKCkgPT4ge30sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgICAgICBuZXh0RWwuX194X2ZvciA9IGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzO1xuICAgICAgICBjb21wb25lbnQuaW5pdGlhbGl6ZUVsZW1lbnRzKG5leHRFbCwgKCkgPT4gbmV4dEVsLl9feF9mb3IpOyAvLyBPdGhlcndpc2UgdXBkYXRlIHRoZSBlbGVtZW50IHdlIGZvdW5kLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgcmVtb3ZlIHRoZSBrZXkgaW5kaWNhdG9yIHRvIGFsbG93IHRoZSBub3JtYWwgXCJ1cGRhdGVFbGVtZW50c1wiIHRvIHdvcmsuXG4gICAgICAgIGRlbGV0ZSBuZXh0RWwuX194X2Zvcl9rZXk7XG4gICAgICAgIG5leHRFbC5fX3hfZm9yID0gaXRlcmF0aW9uU2NvcGVWYXJpYWJsZXM7XG4gICAgICAgIGNvbXBvbmVudC51cGRhdGVFbGVtZW50cyhuZXh0RWwsICgpID0+IG5leHRFbC5fX3hfZm9yKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudEVsID0gbmV4dEVsO1xuICAgICAgY3VycmVudEVsLl9feF9mb3Jfa2V5ID0gY3VycmVudEtleTtcbiAgICB9KTtcbiAgICByZW1vdmVBbnlMZWZ0T3ZlckVsZW1lbnRzRnJvbVByZXZpb3VzVXBkYXRlKGN1cnJlbnRFbCwgY29tcG9uZW50KTtcbiAgfSAvLyBUaGlzIHdhcyB0YWtlbiBmcm9tIFZ1ZUpTIDIuKiBjb3JlLiBUaGFua3MgVnVlIVxuXG4gIGZ1bmN0aW9uIHBhcnNlRm9yRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgbGV0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG4gICAgbGV0IHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG4gICAgbGV0IGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG4gICAgbGV0IGluTWF0Y2ggPSBTdHJpbmcoZXhwcmVzc2lvbikubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSByZXR1cm47XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIHJlcy5pdGVtcyA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICAgIGxldCBpdGVtID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgbGV0IGl0ZXJhdG9yTWF0Y2ggPSBpdGVtLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgIHJlcy5pdGVtID0gaXRlbS5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XG4gICAgICByZXMuaW5kZXggPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcblxuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLmNvbGxlY3Rpb24gPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzLml0ZW0gPSBpdGVtO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJdGVyYXRpb25TY29wZVZhcmlhYmxlcyhpdGVyYXRvck5hbWVzLCBpdGVtLCBpbmRleCwgaXRlbXMsIGV4dHJhVmFycykge1xuICAgIC8vIFdlIG11c3QgY3JlYXRlIGEgbmV3IG9iamVjdCwgc28gZWFjaCBpdGVyYXRpb24gaGFzIGEgbmV3IHNjb3BlXG4gICAgbGV0IHNjb3BlVmFyaWFibGVzID0gZXh0cmFWYXJzID8gX29iamVjdFNwcmVhZDIoe30sIGV4dHJhVmFycykgOiB7fTtcbiAgICBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLml0ZW1dID0gaXRlbTtcbiAgICBpZiAoaXRlcmF0b3JOYW1lcy5pbmRleCkgc2NvcGVWYXJpYWJsZXNbaXRlcmF0b3JOYW1lcy5pbmRleF0gPSBpbmRleDtcbiAgICBpZiAoaXRlcmF0b3JOYW1lcy5jb2xsZWN0aW9uKSBzY29wZVZhcmlhYmxlc1tpdGVyYXRvck5hbWVzLmNvbGxlY3Rpb25dID0gaXRlbXM7XG4gICAgcmV0dXJuIHNjb3BlVmFyaWFibGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVLZXlGb3JJdGVyYXRpb24oY29tcG9uZW50LCBlbCwgaW5kZXgsIGl0ZXJhdGlvblNjb3BlVmFyaWFibGVzKSB7XG4gICAgbGV0IGJpbmRLZXlBdHRyaWJ1dGUgPSBnZXRYQXR0cnMoZWwsIGNvbXBvbmVudCwgJ2JpbmQnKS5maWx0ZXIoYXR0ciA9PiBhdHRyLnZhbHVlID09PSAna2V5JylbMF07IC8vIElmIHRoZSBkZXYgaGFzbid0IHNwZWNpZmllZCBhIGtleSwganVzdCByZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBpdGVyYXRpb24uXG5cbiAgICBpZiAoIWJpbmRLZXlBdHRyaWJ1dGUpIHJldHVybiBpbmRleDtcbiAgICByZXR1cm4gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgYmluZEtleUF0dHJpYnV0ZS5leHByZXNzaW9uLCAoKSA9PiBpdGVyYXRpb25TY29wZVZhcmlhYmxlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBldmFsdWF0ZUl0ZW1zQW5kUmV0dXJuRW1wdHlJZlhJZklzUHJlc2VudEFuZEZhbHNlT25FbGVtZW50KGNvbXBvbmVudCwgZWwsIGl0ZXJhdG9yTmFtZXMsIGV4dHJhVmFycykge1xuICAgIGxldCBpZkF0dHJpYnV0ZSA9IGdldFhBdHRycyhlbCwgY29tcG9uZW50LCAnaWYnKVswXTtcblxuICAgIGlmIChpZkF0dHJpYnV0ZSAmJiAhY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgaWZBdHRyaWJ1dGUuZXhwcmVzc2lvbikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgaXRlbXMgPSBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBpdGVyYXRvck5hbWVzLml0ZW1zLCBleHRyYVZhcnMpOyAvLyBUaGlzIGFkZHMgc3VwcG9ydCBmb3IgdGhlIGBpIGluIG5gIHN5bnRheC5cblxuICAgIGlmIChpc051bWVyaWMoaXRlbXMpICYmIGl0ZW1zID49IDApIHtcbiAgICAgIGl0ZW1zID0gQXJyYXkuZnJvbShBcnJheShpdGVtcykua2V5cygpLCBpID0+IGkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFbGVtZW50SW5Mb29wQWZ0ZXJDdXJyZW50RWwodGVtcGxhdGVFbCwgY3VycmVudEVsKSB7XG4gICAgbGV0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZUVsLmNvbnRlbnQsIHRydWUpO1xuICAgIGN1cnJlbnRFbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShjbG9uZSwgY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgcmV0dXJuIGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBsb29rQWhlYWRGb3JNYXRjaGluZ0tleWVkRWxlbWVudEFuZE1vdmVJdElmRm91bmQobmV4dEVsLCBjdXJyZW50S2V5KSB7XG4gICAgaWYgKCFuZXh0RWwpIHJldHVybjsgLy8gSWYgd2UgYXJlIGFscmVhZHkgcGFzdCB0aGUgeC1mb3IgZ2VuZXJhdGVkIGVsZW1lbnRzLCB3ZSBkb24ndCBuZWVkIHRvIGxvb2sgYWhlYWQuXG5cbiAgICBpZiAobmV4dEVsLl9feF9mb3Jfa2V5ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gSWYgdGhlIHRoZSBrZXkncyBETyBtYXRjaCwgbm8gbmVlZCB0byBsb29rIGFoZWFkLlxuXG4gICAgaWYgKG5leHRFbC5fX3hfZm9yX2tleSA9PT0gY3VycmVudEtleSkgcmV0dXJuIG5leHRFbDsgLy8gSWYgdGhleSBkb24ndCwgd2UnbGwgbG9vayBhaGVhZCBmb3IgYSBtYXRjaC5cbiAgICAvLyBJZiB3ZSBmaW5kIGl0LCB3ZSdsbCBtb3ZlIGl0IHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBsb29wLlxuXG4gICAgbGV0IHRtcE5leHRFbCA9IG5leHRFbDtcblxuICAgIHdoaWxlICh0bXBOZXh0RWwpIHtcbiAgICAgIGlmICh0bXBOZXh0RWwuX194X2Zvcl9rZXkgPT09IGN1cnJlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRtcE5leHRFbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0bXBOZXh0RWwsIG5leHRFbCk7XG4gICAgICB9XG5cbiAgICAgIHRtcE5leHRFbCA9IHRtcE5leHRFbC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgdG1wTmV4dEVsLm5leHRFbGVtZW50U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gdG1wTmV4dEVsLm5leHRFbGVtZW50U2libGluZyA6IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFueUxlZnRPdmVyRWxlbWVudHNGcm9tUHJldmlvdXNVcGRhdGUoY3VycmVudEVsLCBjb21wb25lbnQpIHtcbiAgICB2YXIgbmV4dEVsZW1lbnRGcm9tT2xkTG9vcCA9IGN1cnJlbnRFbC5uZXh0RWxlbWVudFNpYmxpbmcgJiYgY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gY3VycmVudEVsLm5leHRFbGVtZW50U2libGluZyA6IGZhbHNlO1xuXG4gICAgd2hpbGUgKG5leHRFbGVtZW50RnJvbU9sZExvb3ApIHtcbiAgICAgIGxldCBuZXh0RWxlbWVudEZyb21PbGRMb29wSW1tdXRhYmxlID0gbmV4dEVsZW1lbnRGcm9tT2xkTG9vcDtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IG5leHRFbGVtZW50RnJvbU9sZExvb3AubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgdHJhbnNpdGlvbk91dChuZXh0RWxlbWVudEZyb21PbGRMb29wLCAoKSA9PiB7XG4gICAgICAgIG5leHRFbGVtZW50RnJvbU9sZExvb3BJbW11dGFibGUucmVtb3ZlKCk7XG4gICAgICB9LCAoKSA9PiB7fSwgY29tcG9uZW50KTtcbiAgICAgIG5leHRFbGVtZW50RnJvbU9sZExvb3AgPSBuZXh0U2libGluZyAmJiBuZXh0U2libGluZy5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkID8gbmV4dFNpYmxpbmcgOiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVCaW5kaW5nRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGF0dHJOYW1lLCBleHByZXNzaW9uLCBleHRyYVZhcnMsIGF0dHJUeXBlLCBtb2RpZmllcnMpIHtcbiAgICB2YXIgdmFsdWUgPSBjb21wb25lbnQuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuXG4gICAgaWYgKGF0dHJOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICBpZiAoQWxwaW5lLmlnbm9yZUZvY3VzZWRGb3JWYWx1ZUJpbmRpbmcgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKSkgcmV0dXJuOyAvLyBJZiBuZXN0ZWQgbW9kZWwga2V5IGlzIHVuZGVmaW5lZCwgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIHRvIGVtcHR5IHN0cmluZy5cblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgU3RyaW5nKGV4cHJlc3Npb24pLm1hdGNoKC9cXC4vKSkge1xuICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWwudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAvLyBTZXQgcmFkaW8gdmFsdWUgZnJvbSB4LWJpbmQ6dmFsdWUsIGlmIG5vIFwidmFsdWVcIiBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGluaXRpYWwgc3RhdGUgdmFsdWVzLCByYWRpbyB3aWxsIGhhdmUgYSBjb3JyZWN0XG4gICAgICAgIC8vIFwiY2hlY2tlZFwiIHZhbHVlIHNpbmNlIHgtYmluZDp2YWx1ZSBpcyBwcm9jZXNzZWQgYmVmb3JlIHgtbW9kZWwuXG4gICAgICAgIGlmIChlbC5hdHRyaWJ1dGVzLnZhbHVlID09PSB1bmRlZmluZWQgJiYgYXR0clR5cGUgPT09ICdiaW5kJykge1xuICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0clR5cGUgIT09ICdiaW5kJykge1xuICAgICAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkQXR0ckxvb3NlQ29tcGFyZShlbC52YWx1ZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIGV4cGxpY2l0bHkgYmluZGluZyBhIHN0cmluZyB0byB0aGUgOnZhbHVlLCBzZXQgdGhlIHN0cmluZyxcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiwgbGVhdmUgaXQgYWxvbmUsIGl0IHdpbGwgYmUgc2V0IHRvIFwib25cIlxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicgJiYgIVtudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKHZhbHVlKSAmJiBhdHRyVHlwZSA9PT0gJ2JpbmQnKSB7XG4gICAgICAgICAgZWwudmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGF0dHJUeXBlICE9PSAnYmluZCcpIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIEknbSBwdXJwb3NlbHkgbm90IHVzaW5nIEFycmF5LmluY2x1ZGVzIGhlcmUgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAvLyBzdHJpY3QsIGFuZCBiZWNhdXNlIG9mIE51bWVyaWMvU3RyaW5nIG1pcy1jYXN0aW5nLCBJXG4gICAgICAgICAgICAvLyB3YW50IHRoZSBcImluY2x1ZGVzXCIgdG8gYmUgXCJmdXp6eVwiLlxuICAgICAgICAgICAgZWwuY2hlY2tlZCA9IHZhbHVlLnNvbWUodmFsID0+IGNoZWNrZWRBdHRyTG9vc2VDb21wYXJlKHZhbCwgZWwudmFsdWUpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICAgIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLnZhbHVlID09PSB2YWx1ZSkgcmV0dXJuO1xuICAgICAgICBlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXR0ck5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENsYXNzZXMgPSBlbC5fX3hfb3JpZ2luYWxfY2xhc3NlcyB8fCBbXTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGFycmF5VW5pcXVlKG9yaWdpbmFsQ2xhc3Nlcy5jb25jYXQodmFsdWUpKS5qb2luKCcgJykpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIFNvcnRpbmcgdGhlIGtleXMgLyBjbGFzcyBuYW1lcyBieSB0aGVpciBib29sZWFuIHZhbHVlIHdpbGwgZW5zdXJlIHRoYXRcbiAgICAgICAgLy8gYW55dGhpbmcgdGhhdCBldmFsdWF0ZXMgdG8gYGZhbHNlYCBhbmQgbmVlZHMgdG8gcmVtb3ZlIGNsYXNzZXMgaXMgcnVuIGZpcnN0LlxuICAgICAgICBjb25zdCBrZXlzU29ydGVkQnlCb29sZWFuVmFsdWUgPSBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgoYSwgYikgPT4gdmFsdWVbYV0gLSB2YWx1ZVtiXSk7XG4gICAgICAgIGtleXNTb3J0ZWRCeUJvb2xlYW5WYWx1ZS5mb3JFYWNoKGNsYXNzTmFtZXMgPT4ge1xuICAgICAgICAgIGlmICh2YWx1ZVtjbGFzc05hbWVzXSkge1xuICAgICAgICAgICAgY29udmVydENsYXNzU3RyaW5nVG9BcnJheShjbGFzc05hbWVzKS5mb3JFYWNoKGNsYXNzTmFtZSA9PiBlbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KGNsYXNzTmFtZXMpLmZvckVhY2goY2xhc3NOYW1lID0+IGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQ2xhc3NlcyA9IGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdDbGFzc2VzID0gdmFsdWUgPyBjb252ZXJ0Q2xhc3NTdHJpbmdUb0FycmF5KHZhbHVlKSA6IFtdO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYXJyYXlVbmlxdWUob3JpZ2luYWxDbGFzc2VzLmNvbmNhdChuZXdDbGFzc2VzKSkuam9pbignICcpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ck5hbWUgPSBtb2RpZmllcnMuaW5jbHVkZXMoJ2NhbWVsJykgPyBjYW1lbENhc2UoYXR0ck5hbWUpIDogYXR0ck5hbWU7IC8vIElmIGFuIGF0dHJpYnV0ZSdzIGJvdW5kIHZhbHVlIGlzIG51bGwsIHVuZGVmaW5lZCBvciBmYWxzZSwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGVcblxuICAgICAgaWYgKFtudWxsLCB1bmRlZmluZWQsIGZhbHNlXS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzQm9vbGVhbkF0dHIoYXR0ck5hbWUpID8gc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgYXR0ck5hbWUpIDogc2V0SWZDaGFuZ2VkKGVsLCBhdHRyTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElmQ2hhbmdlZChlbCwgYXR0ck5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGVsLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgIT0gdmFsdWUpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdChlbCwgdmFsdWUpIHtcbiAgICBjb25zdCBhcnJheVdyYXBwZWRWYWx1ZSA9IFtdLmNvbmNhdCh2YWx1ZSkubWFwKHZhbHVlID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuICAgIH0pO1xuICAgIEFycmF5LmZyb20oZWwub3B0aW9ucykuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgb3B0aW9uLnNlbGVjdGVkID0gYXJyYXlXcmFwcGVkVmFsdWUuaW5jbHVkZXMob3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVRleHREaXJlY3RpdmUoZWwsIG91dHB1dCwgZXhwcmVzc2lvbikge1xuICAgIC8vIElmIG5lc3RlZCBtb2RlbCBrZXkgaXMgdW5kZWZpbmVkLCBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgdG8gZW1wdHkgc3RyaW5nLlxuICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCAmJiBTdHJpbmcoZXhwcmVzc2lvbikubWF0Y2goL1xcLi8pKSB7XG4gICAgICBvdXRwdXQgPSAnJztcbiAgICB9XG5cbiAgICBlbC50ZXh0Q29udGVudCA9IG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUh0bWxEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gY29tcG9uZW50LmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVNob3dEaXJlY3RpdmUoY29tcG9uZW50LCBlbCwgdmFsdWUsIG1vZGlmaWVycywgaW5pdGlhbFVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGlkZSA9ICgpID0+IHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBlbC5fX3hfaXNfc2hvd24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgIGlmIChlbC5zdHlsZS5sZW5ndGggPT09IDEgJiYgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdkaXNwbGF5Jyk7XG4gICAgICB9XG5cbiAgICAgIGVsLl9feF9pc19zaG93biA9IHRydWU7XG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlID0gKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHwgZWwuX194X3RyYW5zaXRpb24pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uSW4oZWwsICgpID0+IHtcbiAgICAgICAgICAgIHNob3coKTtcbiAgICAgICAgICB9LCByZWplY3QsIGNvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCgpID0+IHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICB0cmFuc2l0aW9uT3V0KGVsLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCgpID0+IHtcbiAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgcmVqZWN0LCBjb21wb25lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKCkgPT4ge30pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTsgLy8gVGhlIHdvcmtpbmcgb2YgeC1zaG93IGlzIGEgYml0IGNvbXBsZXggYmVjYXVzZSB3ZSBuZWVkIHRvXG4gICAgLy8gd2FpdCBmb3IgYW55IGNoaWxkIHRyYW5zaXRpb25zIHRvIGZpbmlzaCBiZWZvcmUgaGlkaW5nXG4gICAgLy8gc29tZSBlbGVtZW50LiBBbHNvLCB0aGlzIGhhcyB0byBiZSBkb25lIHJlY3Vyc2l2ZWx5LlxuICAgIC8vIElmIHgtc2hvdy5pbW1lZGlhdGUsIGZvcmVnb2UgdGhlIHdhaXRpbmcuXG5cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2ltbWVkaWF0ZScpKSB7XG4gICAgICBoYW5kbGUoZmluaXNoID0+IGZpbmlzaCgpLCAoKSA9PiB7fSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB4LXNob3cgaXMgZW5jb3VudGVyZWQgZHVyaW5nIGEgRE9NIHRyZWUgd2Fsay4gSWYgYW4gZWxlbWVudFxuICAgIC8vIHdlIGVuY291bnRlciBpcyBOT1QgYSBjaGlsZCBvZiBhbm90aGVyIHgtc2hvdyBlbGVtZW50IHdlXG4gICAgLy8gY2FuIGV4ZWN1dGUgdGhlIHByZXZpb3VzIHgtc2hvdyBzdGFjayAoaWYgb25lIGV4aXN0cykuXG5cblxuICAgIGlmIChjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50ICYmICFjb21wb25lbnQuc2hvd0RpcmVjdGl2ZUxhc3RFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgY29tcG9uZW50LmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgIH1cblxuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlU3RhY2sucHVzaChoYW5kbGUpO1xuICAgIGNvbXBvbmVudC5zaG93RGlyZWN0aXZlTGFzdEVsZW1lbnQgPSBlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUlmRGlyZWN0aXZlKGNvbXBvbmVudCwgZWwsIGV4cHJlc3Npb25SZXN1bHQsIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycykge1xuICAgIHdhcm5JZk1hbGZvcm1lZFRlbXBsYXRlKGVsLCAneC1pZicpO1xuICAgIGNvbnN0IGVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkID0gZWwubmV4dEVsZW1lbnRTaWJsaW5nICYmIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPT09IHRydWU7XG5cbiAgICBpZiAoZXhwcmVzc2lvblJlc3VsdCAmJiAoIWVsZW1lbnRIYXNBbHJlYWR5QmVlbkFkZGVkIHx8IGVsLl9feF90cmFuc2l0aW9uKSkge1xuICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKGVsLmNvbnRlbnQsIHRydWUpO1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICB0cmFuc2l0aW9uSW4oZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7fSwgKCkgPT4ge30sIGNvbXBvbmVudCwgaW5pdGlhbFVwZGF0ZSk7XG4gICAgICBjb21wb25lbnQuaW5pdGlhbGl6ZUVsZW1lbnRzKGVsLm5leHRFbGVtZW50U2libGluZywgZXh0cmFWYXJzKTtcbiAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5fX3hfaW5zZXJ0ZWRfbWUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIWV4cHJlc3Npb25SZXN1bHQgJiYgZWxlbWVudEhhc0FscmVhZHlCZWVuQWRkZWQpIHtcbiAgICAgIHRyYW5zaXRpb25PdXQoZWwubmV4dEVsZW1lbnRTaWJsaW5nLCAoKSA9PiB7XG4gICAgICAgIGVsLm5leHRFbGVtZW50U2libGluZy5yZW1vdmUoKTtcbiAgICAgIH0sICgpID0+IHt9LCBjb21wb25lbnQsIGluaXRpYWxVcGRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTGlzdGVuZXIoY29tcG9uZW50LCBlbCwgZXZlbnQsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcGFzc2l2ZTogbW9kaWZpZXJzLmluY2x1ZGVzKCdwYXNzaXZlJylcbiAgICB9O1xuXG4gICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygnY2FtZWwnKSkge1xuICAgICAgZXZlbnQgPSBjYW1lbENhc2UoZXZlbnQpO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVyLCBsaXN0ZW5lclRhcmdldDtcblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2F3YXknKSkge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBkb2N1bWVudDtcblxuICAgICAgaGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgY2xpY2sgY2FtZSBmcm9tIHRoZSBlbGVtZW50IG9yIHdpdGhpbiBpdC5cbiAgICAgICAgaWYgKGVsLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuOyAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGlzIGVsZW1lbnQgaXNuJ3QgY3VycmVudGx5IHZpc2libGUuXG5cbiAgICAgICAgaWYgKGVsLm9mZnNldFdpZHRoIDwgMSAmJiBlbC5vZmZzZXRIZWlnaHQgPCAxKSByZXR1cm47IC8vIE5vdyB0aGF0IHdlIGFyZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUsIEFORCB0aGUgY2xpY2tcbiAgICAgICAgLy8gaXMgZnJvbSBvdXRzaWRlIGl0LCBsZXQncyBydW4gdGhlIGV4cHJlc3Npb24uXG5cbiAgICAgICAgcnVuTGlzdGVuZXJIYW5kbGVyKGNvbXBvbmVudCwgZXhwcmVzc2lvbiwgZSwgZXh0cmFWYXJzKTtcblxuICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvbmNlJykpIHtcbiAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdGVuZXJUYXJnZXQgPSBtb2RpZmllcnMuaW5jbHVkZXMoJ3dpbmRvdycpID8gd2luZG93IDogbW9kaWZpZXJzLmluY2x1ZGVzKCdkb2N1bWVudCcpID8gZG9jdW1lbnQgOiBlbDtcblxuICAgICAgaGFuZGxlciA9IGUgPT4ge1xuICAgICAgICAvLyBSZW1vdmUgdGhpcyBnbG9iYWwgZXZlbnQgaGFuZGxlciBpZiB0aGUgZWxlbWVudCB0aGF0IGRlY2xhcmVkIGl0XG4gICAgICAgIC8vIGhhcyBiZWVuIHJlbW92ZWQuIEl0J3Mgbm93IHN0YWxlLlxuICAgICAgICBpZiAobGlzdGVuZXJUYXJnZXQgPT09IHdpbmRvdyB8fCBsaXN0ZW5lclRhcmdldCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNLZXlFdmVudChldmVudCkpIHtcbiAgICAgICAgICBpZiAoaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vZGlmaWVycy5pbmNsdWRlcygncHJldmVudCcpKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ3N0b3AnKSkgZS5zdG9wUHJvcGFnYXRpb24oKTsgLy8gSWYgdGhlIC5zZWxmIG1vZGlmaWVyIGlzbid0IHByZXNlbnQsIG9yIGlmIGl0IGlzIHByZXNlbnQgYW5kXG4gICAgICAgIC8vIHRoZSB0YXJnZXQgZWxlbWVudCBtYXRjaGVzIHRoZSBlbGVtZW50IHdlIGFyZSByZWdpc3RlcmluZyB0aGVcbiAgICAgICAgLy8gZXZlbnQgb24sIHJ1biB0aGUgaGFuZGxlclxuXG4gICAgICAgIGlmICghbW9kaWZpZXJzLmluY2x1ZGVzKCdzZWxmJykgfHwgZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBydW5MaXN0ZW5lckhhbmRsZXIoY29tcG9uZW50LCBleHByZXNzaW9uLCBlLCBleHRyYVZhcnMpO1xuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLmluY2x1ZGVzKCdvbmNlJykpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChtb2RpZmllcnMuaW5jbHVkZXMoJ2RlYm91bmNlJykpIHtcbiAgICAgIGxldCBuZXh0TW9kaWZpZXIgPSBtb2RpZmllcnNbbW9kaWZpZXJzLmluZGV4T2YoJ2RlYm91bmNlJykgKyAxXSB8fCAnaW52YWxpZC13YWl0JztcbiAgICAgIGxldCB3YWl0ID0gaXNOdW1lcmljKG5leHRNb2RpZmllci5zcGxpdCgnbXMnKVswXSkgPyBOdW1iZXIobmV4dE1vZGlmaWVyLnNwbGl0KCdtcycpWzBdKSA6IDI1MDtcbiAgICAgIGhhbmRsZXIgPSBkZWJvdW5jZShoYW5kbGVyLCB3YWl0KTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkxpc3RlbmVySGFuZGxlcihjb21wb25lbnQsIGV4cHJlc3Npb24sIGUsIGV4dHJhVmFycykge1xuICAgIHJldHVybiBjb21wb25lbnQuZXZhbHVhdGVDb21tYW5kRXhwcmVzc2lvbihlLnRhcmdldCwgZXhwcmVzc2lvbiwgKCkgPT4ge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICckZXZlbnQnOiBlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzS2V5RXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gWydrZXlkb3duJywgJ2tleXVwJ10uaW5jbHVkZXMoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNMaXN0ZW5pbmdGb3JBU3BlY2lmaWNLZXlUaGF0SGFzbnRCZWVuUHJlc3NlZChlLCBtb2RpZmllcnMpIHtcbiAgICBsZXQga2V5TW9kaWZpZXJzID0gbW9kaWZpZXJzLmZpbHRlcihpID0+IHtcbiAgICAgIHJldHVybiAhWyd3aW5kb3cnLCAnZG9jdW1lbnQnLCAncHJldmVudCcsICdzdG9wJ10uaW5jbHVkZXMoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAoa2V5TW9kaWZpZXJzLmluY2x1ZGVzKCdkZWJvdW5jZScpKSB7XG4gICAgICBsZXQgZGVib3VuY2VJbmRleCA9IGtleU1vZGlmaWVycy5pbmRleE9mKCdkZWJvdW5jZScpO1xuICAgICAga2V5TW9kaWZpZXJzLnNwbGljZShkZWJvdW5jZUluZGV4LCBpc051bWVyaWMoKGtleU1vZGlmaWVyc1tkZWJvdW5jZUluZGV4ICsgMV0gfHwgJ2ludmFsaWQtd2FpdCcpLnNwbGl0KCdtcycpWzBdKSA/IDIgOiAxKTtcbiAgICB9IC8vIElmIG5vIG1vZGlmaWVyIGlzIHNwZWNpZmllZCwgd2UnbGwgY2FsbCBpdCBhIHByZXNzLlxuXG5cbiAgICBpZiAoa2V5TW9kaWZpZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlOyAvLyBJZiBvbmUgaXMgcGFzc2VkLCBBTkQgaXQgbWF0Y2hlcyB0aGUga2V5IHByZXNzZWQsIHdlJ2xsIGNhbGwgaXQgYSBwcmVzcy5cblxuICAgIGlmIChrZXlNb2RpZmllcnMubGVuZ3RoID09PSAxICYmIGtleU1vZGlmaWVyc1swXSA9PT0ga2V5VG9Nb2RpZmllcihlLmtleSkpIHJldHVybiBmYWxzZTsgLy8gVGhlIHVzZXIgaXMgbGlzdGVuaW5nIGZvciBrZXkgY29tYmluYXRpb25zLlxuXG4gICAgY29uc3Qgc3lzdGVtS2V5TW9kaWZpZXJzID0gWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJywgJ2NtZCcsICdzdXBlciddO1xuICAgIGNvbnN0IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzID0gc3lzdGVtS2V5TW9kaWZpZXJzLmZpbHRlcihtb2RpZmllciA9PiBrZXlNb2RpZmllcnMuaW5jbHVkZXMobW9kaWZpZXIpKTtcbiAgICBrZXlNb2RpZmllcnMgPSBrZXlNb2RpZmllcnMuZmlsdGVyKGkgPT4gIXNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmluY2x1ZGVzKGkpKTtcblxuICAgIGlmIChzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBhY3RpdmVseVByZXNzZWRLZXlNb2RpZmllcnMgPSBzZWxlY3RlZFN5c3RlbUtleU1vZGlmaWVycy5maWx0ZXIobW9kaWZpZXIgPT4ge1xuICAgICAgICAvLyBBbGlhcyBcImNtZFwiIGFuZCBcInN1cGVyXCIgdG8gXCJtZXRhXCJcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnY21kJyB8fCBtb2RpZmllciA9PT0gJ3N1cGVyJykgbW9kaWZpZXIgPSAnbWV0YSc7XG4gICAgICAgIHJldHVybiBlW2Ake21vZGlmaWVyfUtleWBdO1xuICAgICAgfSk7IC8vIElmIGFsbCB0aGUgbW9kaWZpZXJzIHNlbGVjdGVkIGFyZSBwcmVzc2VkLCAuLi5cblxuICAgICAgaWYgKGFjdGl2ZWx5UHJlc3NlZEtleU1vZGlmaWVycy5sZW5ndGggPT09IHNlbGVjdGVkU3lzdGVtS2V5TW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAvLyBBTkQgdGhlIHJlbWFpbmluZyBrZXkgaXMgcHJlc3NlZCBhcyB3ZWxsLiBJdCdzIGEgcHJlc3MuXG4gICAgICAgIGlmIChrZXlNb2RpZmllcnNbMF0gPT09IGtleVRvTW9kaWZpZXIoZS5rZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSAvLyBXZSdsbCBjYWxsIGl0IE5PVCBhIHZhbGlkIGtleXByZXNzLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGtleVRvTW9kaWZpZXIoa2V5KSB7XG4gICAgc3dpdGNoIChrZXkpIHtcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICByZXR1cm4gJ3NsYXNoJztcblxuICAgICAgY2FzZSAnICc6XG4gICAgICBjYXNlICdTcGFjZWJhcic6XG4gICAgICAgIHJldHVybiAnc3BhY2UnO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4ga2V5ICYmIGtlYmFiQ2FzZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kZWxMaXN0ZW5lcihjb21wb25lbnQsIGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycykge1xuICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIGFyZSBiaW5kaW5nIHRvIGlzIGEgc2VsZWN0LCBhIHJhZGlvLCBvciBjaGVja2JveFxuICAgIC8vIHdlJ2xsIGxpc3RlbiBmb3IgdGhlIGNoYW5nZSBldmVudCBpbnN0ZWFkIG9mIHRoZSBcImlucHV0XCIgZXZlbnQuXG4gICAgdmFyIGV2ZW50ID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0JyB8fCBbJ2NoZWNrYm94JywgJ3JhZGlvJ10uaW5jbHVkZXMoZWwudHlwZSkgfHwgbW9kaWZpZXJzLmluY2x1ZGVzKCdsYXp5JykgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgY29uc3QgbGlzdGVuZXJFeHByZXNzaW9uID0gYCR7ZXhwcmVzc2lvbn0gPSByaWdodFNpZGVPZkV4cHJlc3Npb24oJGV2ZW50LCAke2V4cHJlc3Npb259KWA7XG4gICAgcmVnaXN0ZXJMaXN0ZW5lcihjb21wb25lbnQsIGVsLCBldmVudCwgbW9kaWZpZXJzLCBsaXN0ZW5lckV4cHJlc3Npb24sICgpID0+IHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZXh0cmFWYXJzKCkpLCB7fSwge1xuICAgICAgICByaWdodFNpZGVPZkV4cHJlc3Npb246IGdlbmVyYXRlTW9kZWxBc3NpZ25tZW50RnVuY3Rpb24oZWwsIG1vZGlmaWVycywgZXhwcmVzc2lvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVNb2RlbEFzc2lnbm1lbnRGdW5jdGlvbihlbCwgbW9kaWZpZXJzLCBleHByZXNzaW9uKSB7XG4gICAgaWYgKGVsLnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgIC8vIFJhZGlvIGJ1dHRvbnMgb25seSB3b3JrIHByb3Blcmx5IHdoZW4gdGhleSBzaGFyZSBhIG5hbWUgYXR0cmlidXRlLlxuICAgICAgLy8gUGVvcGxlIG1pZ2h0IGFzc3VtZSB3ZSB0YWtlIGNhcmUgb2YgdGhhdCBmb3IgdGhlbSwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBhbHJlYWR5IHNldCBhIHNoYXJlZCBcIngtbW9kZWxcIiBhdHRyaWJ1dGUuXG4gICAgICBpZiAoIWVsLmhhc0F0dHJpYnV0ZSgnbmFtZScpKSBlbC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBleHByZXNzaW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGV2ZW50LCBjdXJyZW50VmFsdWUpID0+IHtcbiAgICAgIC8vIENoZWNrIGZvciBldmVudC5kZXRhaWwgZHVlIHRvIGFuIGlzc3VlIHdoZXJlIElFMTEgaGFuZGxlcyBvdGhlciBldmVudHMgYXMgYSBDdXN0b21FdmVudC5cbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGV2ZW50LmRldGFpbCkge1xuICAgICAgICByZXR1cm4gZXZlbnQuZGV0YWlsO1xuICAgICAgfSBlbHNlIGlmIChlbC50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIC8vIElmIHRoZSBkYXRhIHdlIGFyZSBiaW5kaW5nIHRvIGlzIGFuIGFycmF5LCB0b2dnbGUgaXRzIHZhbHVlIGluc2lkZSB0aGUgYXJyYXkuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBzYWZlUGFyc2VOdW1iZXIoZXZlbnQudGFyZ2V0LnZhbHVlKSA6IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjdXJyZW50VmFsdWUuY29uY2F0KFtuZXdWYWx1ZV0pIDogY3VycmVudFZhbHVlLmZpbHRlcihlbCA9PiAhY2hlY2tlZEF0dHJMb29zZUNvbXBhcmUoZWwsIG5ld1ZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jaGVja2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NlbGVjdCcgJiYgZWwubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBBcnJheS5mcm9tKGV2ZW50LnRhcmdldC5zZWxlY3RlZE9wdGlvbnMpLm1hcChvcHRpb24gPT4ge1xuICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gb3B0aW9uLnZhbHVlIHx8IG9wdGlvbi50ZXh0O1xuICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpO1xuICAgICAgICB9KSA6IEFycmF5LmZyb20oZXZlbnQudGFyZ2V0LnNlbGVjdGVkT3B0aW9ucykubWFwKG9wdGlvbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbi52YWx1ZSB8fCBvcHRpb24udGV4dDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByYXdWYWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5pbmNsdWRlcygnbnVtYmVyJykgPyBzYWZlUGFyc2VOdW1iZXIocmF3VmFsdWUpIDogbW9kaWZpZXJzLmluY2x1ZGVzKCd0cmltJykgPyByYXdWYWx1ZS50cmltKCkgOiByYXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2FmZVBhcnNlTnVtYmVyKHJhd1ZhbHVlKSB7XG4gICAgY29uc3QgbnVtYmVyID0gcmF3VmFsdWUgPyBwYXJzZUZsb2F0KHJhd1ZhbHVlKSA6IG51bGw7XG4gICAgcmV0dXJuIGlzTnVtZXJpYyhudW1iZXIpID8gbnVtYmVyIDogcmF3VmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ29weXJpZ2h0IChDKSAyMDE3IHNhbGVzZm9yY2UuY29tLCBpbmMuXG4gICAqL1xuICBjb25zdCB7IGlzQXJyYXkgfSA9IEFycmF5O1xuICBjb25zdCB7IGdldFByb3RvdHlwZU9mLCBjcmVhdGU6IE9iamVjdENyZWF0ZSwgZGVmaW5lUHJvcGVydHk6IE9iamVjdERlZmluZVByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0aWVzOiBPYmplY3REZWZpbmVQcm9wZXJ0aWVzLCBpc0V4dGVuc2libGUsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciwgZ2V0T3duUHJvcGVydHlOYW1lcywgZ2V0T3duUHJvcGVydHlTeW1ib2xzLCBwcmV2ZW50RXh0ZW5zaW9ucywgaGFzT3duUHJvcGVydHksIH0gPSBPYmplY3Q7XG4gIGNvbnN0IHsgcHVzaDogQXJyYXlQdXNoLCBjb25jYXQ6IEFycmF5Q29uY2F0LCBtYXA6IEFycmF5TWFwLCB9ID0gQXJyYXkucHJvdG90eXBlO1xuICBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG4gIH1cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG4gIH1cbiAgY29uc3QgcHJveHlUb1ZhbHVlTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgZnVuY3Rpb24gcmVnaXN0ZXJQcm94eShwcm94eSwgdmFsdWUpIHtcbiAgICAgIHByb3h5VG9WYWx1ZU1hcC5zZXQocHJveHksIHZhbHVlKTtcbiAgfVxuICBjb25zdCB1bndyYXAgPSAocmVwbGljYU9yQW55KSA9PiBwcm94eVRvVmFsdWVNYXAuZ2V0KHJlcGxpY2FPckFueSkgfHwgcmVwbGljYU9yQW55O1xuXG4gIGZ1bmN0aW9uIHdyYXBWYWx1ZShtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBtZW1icmFuZS52YWx1ZUlzT2JzZXJ2YWJsZSh2YWx1ZSkgPyBtZW1icmFuZS5nZXRQcm94eSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogVW53cmFwIHByb3BlcnR5IGRlc2NyaXB0b3JzIHdpbGwgc2V0IHZhbHVlIG9uIG9yaWdpbmFsIGRlc2NyaXB0b3JcbiAgICogV2Ugb25seSBuZWVkIHRvIHVud3JhcCBpZiB2YWx1ZSBpcyBzcGVjaWZpZWRcbiAgICogQHBhcmFtIGRlc2NyaXB0b3IgZXh0ZXJuYWwgZGVzY3JwaXRvciBwcm92aWRlZCB0byBkZWZpbmUgbmV3IHByb3BlcnR5IG9uIG9yaWdpbmFsIHZhbHVlXG4gICAqL1xuICBmdW5jdGlvbiB1bndyYXBEZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2NyaXB0b3IsICd2YWx1ZScpKSB7XG4gICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IHVud3JhcChkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG4gIGZ1bmN0aW9uIGxvY2tTaGFkb3dUYXJnZXQobWVtYnJhbmUsIHNoYWRvd1RhcmdldCwgb3JpZ2luYWxUYXJnZXQpIHtcbiAgICAgIGNvbnN0IHRhcmdldEtleXMgPSBBcnJheUNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWxUYXJnZXQpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWxUYXJnZXQpKTtcbiAgICAgIHRhcmdldEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgbGV0IGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgLy8gV2UgZG8gbm90IG5lZWQgdG8gd3JhcCB0aGUgZGVzY3JpcHRvciBpZiBjb25maWd1cmFibGVcbiAgICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbiBkZWFsIHdpdGggd3JhcHBpbmcgaXQgd2hlbiB1c2VyIGdvZXMgdGhyb3VnaFxuICAgICAgICAgIC8vIEdldCBvd24gcHJvcGVydHkgZGVzY3JpcHRvci4gVGhlcmUgaXMgYWxzbyBhIGNoYW5jZSB0aGF0IHRoaXMgZGVzY3JpcHRvclxuICAgICAgICAgIC8vIGNvdWxkIGNoYW5nZSBzb21ldGltZSBpbiB0aGUgZnV0dXJlLCBzbyB3ZSBjYW4gZGVmZXIgd3JhcHBpbmdcbiAgICAgICAgICAvLyB1bnRpbCB3ZSBuZWVkIHRvXG4gICAgICAgICAgaWYgKCFkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2NyaXB0b3IsIHdyYXBWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgIH0pO1xuICAgICAgcHJldmVudEV4dGVuc2lvbnMoc2hhZG93VGFyZ2V0KTtcbiAgfVxuICBjbGFzcyBSZWFjdGl2ZVByb3h5SGFuZGxlciB7XG4gICAgICBjb25zdHJ1Y3RvcihtZW1icmFuZSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsVGFyZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5tZW1icmFuZSA9IG1lbWJyYW5lO1xuICAgICAgfVxuICAgICAgZ2V0KHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcmlnaW5hbFRhcmdldFtrZXldO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVPYnNlcnZlZCB9ID0gbWVtYnJhbmU7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gbWVtYnJhbmUuZ2V0UHJveHkodmFsdWUpO1xuICAgICAgfVxuICAgICAgc2V0KHNoYWRvd1RhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lOiB7IHZhbHVlTXV0YXRlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIG9yaWdpbmFsVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWVNdXRhdGVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdsZW5ndGgnICYmIGlzQXJyYXkob3JpZ2luYWxUYXJnZXQpKSB7XG4gICAgICAgICAgICAgIC8vIGZpeCBmb3IgaXNzdWUgIzIzNjogcHVzaCB3aWxsIGFkZCB0aGUgbmV3IGluZGV4LCBhbmQgYnkgdGhlIHRpbWUgbGVuZ3RoXG4gICAgICAgICAgICAgIC8vIGlzIHVwZGF0ZWQsIHRoZSBpbnRlcm5hbCBsZW5ndGggaXMgYWxyZWFkeSBlcXVhbCB0byB0aGUgbmV3IGxlbmd0aCB2YWx1ZVxuICAgICAgICAgICAgICAvLyB0aGVyZWZvcmUsIHRoZSBvbGRWYWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUuIFRoaXMgaXMgdGhlIGZvcmtpbmcgbG9naWNcbiAgICAgICAgICAgICAgLy8gdG8gc3VwcG9ydCB0aGlzIHVzZSBjYXNlLlxuICAgICAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZGVsZXRlUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU11dGF0ZWQgfSB9ID0gdGhpcztcbiAgICAgICAgICBkZWxldGUgb3JpZ2luYWxUYXJnZXRba2V5XTtcbiAgICAgICAgICB2YWx1ZU11dGF0ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBhcHBseShzaGFkb3dUYXJnZXQsIHRoaXNBcmcsIGFyZ0FycmF5KSB7XG4gICAgICAgICAgLyogTm8gb3AgKi9cbiAgICAgIH1cbiAgICAgIGNvbnN0cnVjdCh0YXJnZXQsIGFyZ0FycmF5LCBuZXdUYXJnZXQpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgaGFzKHNoYWRvd1RhcmdldCwga2V5KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmU6IHsgdmFsdWVPYnNlcnZlZCB9IH0gPSB0aGlzO1xuICAgICAgICAgIHZhbHVlT2JzZXJ2ZWQob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGtleSBpbiBvcmlnaW5hbFRhcmdldDtcbiAgICAgIH1cbiAgICAgIG93bktleXMoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gQXJyYXlDb25jYXQuY2FsbChnZXRPd25Qcm9wZXJ0eU5hbWVzKG9yaWdpbmFsVGFyZ2V0KSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9yaWdpbmFsVGFyZ2V0KSk7XG4gICAgICB9XG4gICAgICBpc0V4dGVuc2libGUoc2hhZG93VGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3Qgc2hhZG93SXNFeHRlbnNpYmxlID0gaXNFeHRlbnNpYmxlKHNoYWRvd1RhcmdldCk7XG4gICAgICAgICAgaWYgKCFzaGFkb3dJc0V4dGVuc2libGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd0lzRXh0ZW5zaWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBvcmlnaW5hbFRhcmdldCwgbWVtYnJhbmUgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0SXNFeHRlbnNpYmxlID0gaXNFeHRlbnNpYmxlKG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICBpZiAoIXRhcmdldElzRXh0ZW5zaWJsZSkge1xuICAgICAgICAgICAgICBsb2NrU2hhZG93VGFyZ2V0KG1lbWJyYW5lLCBzaGFkb3dUYXJnZXQsIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRhcmdldElzRXh0ZW5zaWJsZTtcbiAgICAgIH1cbiAgICAgIHNldFByb3RvdHlwZU9mKHNoYWRvd1RhcmdldCwgcHJvdG90eXBlKSB7XG4gICAgICB9XG4gICAgICBnZXRQcm90b3R5cGVPZihzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBnZXRQcm90b3R5cGVPZihvcmlnaW5hbFRhcmdldCk7XG4gICAgICB9XG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IHRoaXMubWVtYnJhbmU7XG4gICAgICAgICAgLy8ga2V5cyBsb29rZWQgdXAgdmlhIGhhc093blByb3BlcnR5IG5lZWQgdG8gYmUgcmVhY3RpdmVcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGxldCBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkZXNjKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2hhZG93RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzaGFkb3dUYXJnZXQsIGtleSk7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChzaGFkb3dEZXNjcmlwdG9yKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2hhZG93RGVzY3JpcHRvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTm90ZTogYnkgYWNjZXNzaW5nIHRoZSBkZXNjcmlwdG9yLCB0aGUga2V5IGlzIG1hcmtlZCBhcyBvYnNlcnZlZFxuICAgICAgICAgIC8vIGJ1dCBhY2Nlc3MgdG8gdGhlIHZhbHVlLCBzZXR0ZXIgb3IgZ2V0dGVyIChpZiBhdmFpbGFibGUpIGNhbm5vdCBvYnNlcnZlXG4gICAgICAgICAgLy8gbXV0YXRpb25zLCBqdXN0IGxpa2UgcmVndWxhciBtZXRob2RzLCBpbiB3aGljaCBjYXNlIHdlIGp1c3QgZG8gbm90aGluZy5cbiAgICAgICAgICBkZXNjID0gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2MsIHdyYXBWYWx1ZSk7XG4gICAgICAgICAgaWYgKCFkZXNjLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgICAgICAgICAvLyBJZiBkZXNjcmlwdG9yIGZyb20gb3JpZ2luYWwgdGFyZ2V0IGlzIG5vdCBjb25maWd1cmFibGUsXG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgY29weSB0aGUgd3JhcHBlZCBkZXNjcmlwdG9yIG92ZXIgdG8gdGhlIHNoYWRvdyB0YXJnZXQuXG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgcHJveHkgd2lsbCB0aHJvdyBhbiBpbnZhcmlhbnQgZXJyb3IuXG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgb3VyIGxhc3QgY2hhbmNlIHRvIGxvY2sgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eS9oYW5kbGVyL2dldE93blByb3BlcnR5RGVzY3JpcHRvciNJbnZhcmlhbnRzXG4gICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICB9XG4gICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBsb2NrU2hhZG93VGFyZ2V0KG1lbWJyYW5lLCBzaGFkb3dUYXJnZXQsIG9yaWdpbmFsVGFyZ2V0KTtcbiAgICAgICAgICBwcmV2ZW50RXh0ZW5zaW9ucyhvcmlnaW5hbFRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBkZWZpbmVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICAgICAgICAgIGNvbnN0IHsgb3JpZ2luYWxUYXJnZXQsIG1lbWJyYW5lIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHsgdmFsdWVNdXRhdGVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICBjb25zdCB7IGNvbmZpZ3VyYWJsZSB9ID0gZGVzY3JpcHRvcjtcbiAgICAgICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGZvciB2YWx1ZSBpbiBkZXNjcmlwdG9yXG4gICAgICAgICAgLy8gYmVjYXVzZSBPYmplY3QuZnJlZXplKHByb3h5KSBjYWxscyB0aGlzIG1ldGhvZFxuICAgICAgICAgIC8vIHdpdGggb25seSB7IGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRlYWJsZTogZmFsc2UgfVxuICAgICAgICAgIC8vIEFkZGl0aW9uYWxseSwgbWV0aG9kIHdpbGwgb25seSBiZSBjYWxsZWQgd2l0aCB3cml0ZWFibGU6ZmFsc2VcbiAgICAgICAgICAvLyBpZiB0aGUgZGVzY3JpcHRvciBoYXMgYSB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBnZXR0ZXIvc2V0dGVyXG4gICAgICAgICAgLy8gU28gd2UgY2FuIGp1c3QgY2hlY2sgaWYgd3JpdGFibGUgaXMgcHJlc2VudCBhbmQgdGhlbiBzZWUgaWZcbiAgICAgICAgICAvLyB2YWx1ZSBpcyBwcmVzZW50LiBUaGlzIGVsaW1pbmF0ZXMgZ2V0dGVyIGFuZCBzZXR0ZXIgZGVzY3JpcHRvcnNcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChkZXNjcmlwdG9yLCAndmFsdWUnKSkge1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbERlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWxUYXJnZXQsIGtleSk7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IudmFsdWUgPSBvcmlnaW5hbERlc2NyaXB0b3IudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KG9yaWdpbmFsVGFyZ2V0LCBrZXksIHVud3JhcERlc2NyaXB0b3IoZGVzY3JpcHRvcikpO1xuICAgICAgICAgIGlmIChjb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIE9iamVjdERlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzY3JpcHRvciwgd3JhcFZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlTXV0YXRlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBSZWFkT25seVZhbHVlKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG1lbWJyYW5lLnZhbHVlSXNPYnNlcnZhYmxlKHZhbHVlKSA/IG1lbWJyYW5lLmdldFJlYWRPbmx5UHJveHkodmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgY2xhc3MgUmVhZE9ubHlIYW5kbGVyIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1lbWJyYW5lLCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXQgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLm1lbWJyYW5lID0gbWVtYnJhbmU7XG4gICAgICB9XG4gICAgICBnZXQoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG1lbWJyYW5lLCBvcmlnaW5hbFRhcmdldCB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9yaWdpbmFsVGFyZ2V0W2tleV07XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZU9ic2VydmVkIH0gPSBtZW1icmFuZTtcbiAgICAgICAgICB2YWx1ZU9ic2VydmVkKG9yaWdpbmFsVGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIHJldHVybiBtZW1icmFuZS5nZXRSZWFkT25seVByb3h5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHNldChzaGFkb3dUYXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBkZWxldGVQcm9wZXJ0eShzaGFkb3dUYXJnZXQsIGtleSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGFwcGx5KHNoYWRvd1RhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgICAgICAvKiBObyBvcCAqL1xuICAgICAgfVxuICAgICAgY29uc3RydWN0KHRhcmdldCwgYXJnQXJyYXksIG5ld1RhcmdldCkge1xuICAgICAgICAgIC8qIE5vIG9wICovXG4gICAgICB9XG4gICAgICBoYXMoc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZTogeyB2YWx1ZU9ic2VydmVkIH0gfSA9IHRoaXM7XG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICByZXR1cm4ga2V5IGluIG9yaWdpbmFsVGFyZ2V0O1xuICAgICAgfVxuICAgICAgb3duS2V5cyhzaGFkb3dUYXJnZXQpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0IH0gPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBBcnJheUNvbmNhdC5jYWxsKGdldE93blByb3BlcnR5TmFtZXMob3JpZ2luYWxUYXJnZXQpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMob3JpZ2luYWxUYXJnZXQpKTtcbiAgICAgIH1cbiAgICAgIHNldFByb3RvdHlwZU9mKHNoYWRvd1RhcmdldCwgcHJvdG90eXBlKSB7XG4gICAgICB9XG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICBjb25zdCB7IG9yaWdpbmFsVGFyZ2V0LCBtZW1icmFuZSB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCB7IHZhbHVlT2JzZXJ2ZWQgfSA9IG1lbWJyYW5lO1xuICAgICAgICAgIC8vIGtleXMgbG9va2VkIHVwIHZpYSBoYXNPd25Qcm9wZXJ0eSBuZWVkIHRvIGJlIHJlYWN0aXZlXG4gICAgICAgICAgdmFsdWVPYnNlcnZlZChvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBsZXQgZGVzYyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvcmlnaW5hbFRhcmdldCwga2V5KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGVzYykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNoYWRvd0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc2hhZG93VGFyZ2V0LCBrZXkpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2hhZG93RGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd0Rlc2NyaXB0b3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGU6IGJ5IGFjY2Vzc2luZyB0aGUgZGVzY3JpcHRvciwgdGhlIGtleSBpcyBtYXJrZWQgYXMgb2JzZXJ2ZWRcbiAgICAgICAgICAvLyBidXQgYWNjZXNzIHRvIHRoZSB2YWx1ZSBvciBnZXR0ZXIgKGlmIGF2YWlsYWJsZSkgY2Fubm90IGJlIG9ic2VydmVkLFxuICAgICAgICAgIC8vIGp1c3QgbGlrZSByZWd1bGFyIG1ldGhvZHMsIGluIHdoaWNoIGNhc2Ugd2UganVzdCBkbyBub3RoaW5nLlxuICAgICAgICAgIGRlc2MgPSB3cmFwRGVzY3JpcHRvcihtZW1icmFuZSwgZGVzYywgd3JhcFJlYWRPbmx5VmFsdWUpO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGRlc2MsICdzZXQnKSkge1xuICAgICAgICAgICAgICBkZXNjLnNldCA9IHVuZGVmaW5lZDsgLy8gcmVhZE9ubHkgbWVtYnJhbmUgZG9lcyBub3QgYWxsb3cgc2V0dGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRlc2MuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIElmIGRlc2NyaXB0b3IgZnJvbSBvcmlnaW5hbCB0YXJnZXQgaXMgbm90IGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgICAgLy8gV2UgbXVzdCBjb3B5IHRoZSB3cmFwcGVkIGRlc2NyaXB0b3Igb3ZlciB0byB0aGUgc2hhZG93IHRhcmdldC5cbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBwcm94eSB3aWxsIHRocm93IGFuIGludmFyaWFudCBlcnJvci5cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBvdXIgbGFzdCBjaGFuY2UgdG8gbG9jayB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5L2hhbmRsZXIvZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yI0ludmFyaWFudHNcbiAgICAgICAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHkoc2hhZG93VGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVzYztcbiAgICAgIH1cbiAgICAgIHByZXZlbnRFeHRlbnNpb25zKHNoYWRvd1RhcmdldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVByb3BlcnR5KHNoYWRvd1RhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYWRvd1RhcmdldCh2YWx1ZSkge1xuICAgICAgbGV0IHNoYWRvd1RhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHNoYWRvd1RhcmdldCA9IFtdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgc2hhZG93VGFyZ2V0ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gc2hhZG93VGFyZ2V0O1xuICB9XG4gIGNvbnN0IE9iamVjdERvdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZUlzT2JzZXJ2YWJsZSh2YWx1ZSkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBjaGVja2luZyBmb3IgbnVsbFxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gdHJlYXQgYWxsIG5vbi1vYmplY3QgdHlwZXMsIGluY2x1ZGluZyB1bmRlZmluZWQsIGFzIG5vbi1vYnNlcnZhYmxlIHZhbHVlc1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWUpO1xuICAgICAgcmV0dXJuIChwcm90byA9PT0gT2JqZWN0RG90UHJvdG90eXBlIHx8IHByb3RvID09PSBudWxsIHx8IGdldFByb3RvdHlwZU9mKHByb3RvKSA9PT0gbnVsbCk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdFZhbHVlT2JzZXJ2ZWQgPSAob2JqLCBrZXkpID0+IHtcbiAgICAgIC8qIGRvIG5vdGhpbmcgKi9cbiAgfTtcbiAgY29uc3QgZGVmYXVsdFZhbHVlTXV0YXRlZCA9IChvYmosIGtleSkgPT4ge1xuICAgICAgLyogZG8gbm90aGluZyAqL1xuICB9O1xuICBjb25zdCBkZWZhdWx0VmFsdWVEaXN0b3J0aW9uID0gKHZhbHVlKSA9PiB2YWx1ZTtcbiAgZnVuY3Rpb24gd3JhcERlc2NyaXB0b3IobWVtYnJhbmUsIGRlc2NyaXB0b3IsIGdldFZhbHVlKSB7XG4gICAgICBjb25zdCB7IHNldCwgZ2V0IH0gPSBkZXNjcmlwdG9yO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yLnZhbHVlID0gZ2V0VmFsdWUobWVtYnJhbmUsIGRlc2NyaXB0b3IudmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChnZXQpKSB7XG4gICAgICAgICAgICAgIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgLy8gaW52b2tpbmcgdGhlIG9yaWdpbmFsIGdldHRlciB3aXRoIHRoZSBvcmlnaW5hbCB0YXJnZXRcbiAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZShtZW1icmFuZSwgZ2V0LmNhbGwodW53cmFwKHRoaXMpKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc2V0KSkge1xuICAgICAgICAgICAgICBkZXNjcmlwdG9yLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBkb24ndCBoYXZlIGEgY2xlYXIgaW5kaWNhdGlvbiBvZiB3aGV0aGVyXG4gICAgICAgICAgICAgICAgICAvLyBvciBub3QgYSB2YWxpZCBtdXRhdGlvbiB3aWxsIG9jY3VyLCB3ZSBkb24ndCBoYXZlIHRoZSBrZXksXG4gICAgICAgICAgICAgICAgICAvLyBhbmQgd2UgYXJlIG5vdCBzdXJlIHdoeSBhbmQgaG93IHRoZXkgYXJlIGludm9raW5nIHRoaXMgc2V0dGVyLlxuICAgICAgICAgICAgICAgICAgLy8gTmV2ZXJ0aGVsZXNzIHdlIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBzZW1hbnRpY3MgYnkgaW52b2tpbmcgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBzZXR0ZXIgd2l0aCB0aGUgb3JpZ2luYWwgdGFyZ2V0IGFuZCB0aGUgdW53cmFwcGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICBzZXQuY2FsbCh1bndyYXAodGhpcyksIG1lbWJyYW5lLnVud3JhcFByb3h5KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gIH1cbiAgY2xhc3MgUmVhY3RpdmVNZW1icmFuZSB7XG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZURpc3RvcnRpb24gPSBkZWZhdWx0VmFsdWVEaXN0b3J0aW9uO1xuICAgICAgICAgIHRoaXMudmFsdWVNdXRhdGVkID0gZGVmYXVsdFZhbHVlTXV0YXRlZDtcbiAgICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZWQgPSBkZWZhdWx0VmFsdWVPYnNlcnZlZDtcbiAgICAgICAgICB0aGlzLnZhbHVlSXNPYnNlcnZhYmxlID0gZGVmYXVsdFZhbHVlSXNPYnNlcnZhYmxlO1xuICAgICAgICAgIHRoaXMub2JqZWN0R3JhcGggPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZURpc3RvcnRpb24sIHZhbHVlTXV0YXRlZCwgdmFsdWVPYnNlcnZlZCwgdmFsdWVJc09ic2VydmFibGUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgIHRoaXMudmFsdWVEaXN0b3J0aW9uID0gaXNGdW5jdGlvbih2YWx1ZURpc3RvcnRpb24pID8gdmFsdWVEaXN0b3J0aW9uIDogZGVmYXVsdFZhbHVlRGlzdG9ydGlvbjtcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZU11dGF0ZWQgPSBpc0Z1bmN0aW9uKHZhbHVlTXV0YXRlZCkgPyB2YWx1ZU11dGF0ZWQgOiBkZWZhdWx0VmFsdWVNdXRhdGVkO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZWQgPSBpc0Z1bmN0aW9uKHZhbHVlT2JzZXJ2ZWQpID8gdmFsdWVPYnNlcnZlZCA6IGRlZmF1bHRWYWx1ZU9ic2VydmVkO1xuICAgICAgICAgICAgICB0aGlzLnZhbHVlSXNPYnNlcnZhYmxlID0gaXNGdW5jdGlvbih2YWx1ZUlzT2JzZXJ2YWJsZSkgPyB2YWx1ZUlzT2JzZXJ2YWJsZSA6IGRlZmF1bHRWYWx1ZUlzT2JzZXJ2YWJsZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBnZXRQcm94eSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gdW53cmFwKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBkaXN0b3J0ZWQgPSB0aGlzLnZhbHVlRGlzdG9ydGlvbih1bndyYXBwZWRWYWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVJc09ic2VydmFibGUoZGlzdG9ydGVkKSkge1xuICAgICAgICAgICAgICBjb25zdCBvID0gdGhpcy5nZXRSZWFjdGl2ZVN0YXRlKHVud3JhcHBlZFZhbHVlLCBkaXN0b3J0ZWQpO1xuICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBleHRyYWN0IHRoZSB3cml0YWJsZSB2ZXJzaW9uIG9mIGEgcmVhZG9ubHlcbiAgICAgICAgICAgICAgLy8gd2UgcmV0dXJuIHRoZSByZWFkb25seS5cbiAgICAgICAgICAgICAgcmV0dXJuIG8ucmVhZE9ubHkgPT09IHZhbHVlID8gdmFsdWUgOiBvLnJlYWN0aXZlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlzdG9ydGVkO1xuICAgICAgfVxuICAgICAgZ2V0UmVhZE9ubHlQcm94eSh2YWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gdW53cmFwKHZhbHVlKTtcbiAgICAgICAgICBjb25zdCBkaXN0b3J0ZWQgPSB0aGlzLnZhbHVlRGlzdG9ydGlvbih2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRoaXMudmFsdWVJc09ic2VydmFibGUoZGlzdG9ydGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWFjdGl2ZVN0YXRlKHZhbHVlLCBkaXN0b3J0ZWQpLnJlYWRPbmx5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGlzdG9ydGVkO1xuICAgICAgfVxuICAgICAgdW53cmFwUHJveHkocCkge1xuICAgICAgICAgIHJldHVybiB1bndyYXAocCk7XG4gICAgICB9XG4gICAgICBnZXRSZWFjdGl2ZVN0YXRlKHZhbHVlLCBkaXN0b3J0ZWRWYWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgb2JqZWN0R3JhcGgsIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCByZWFjdGl2ZVN0YXRlID0gb2JqZWN0R3JhcGguZ2V0KGRpc3RvcnRlZFZhbHVlKTtcbiAgICAgICAgICBpZiAocmVhY3RpdmVTdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVhY3RpdmVTdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWVtYnJhbmUgPSB0aGlzO1xuICAgICAgICAgIHJlYWN0aXZlU3RhdGUgPSB7XG4gICAgICAgICAgICAgIGdldCByZWFjdGl2ZSgpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWN0aXZlSGFuZGxlciA9IG5ldyBSZWFjdGl2ZVByb3h5SGFuZGxlcihtZW1icmFuZSwgZGlzdG9ydGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgLy8gY2FjaGluZyB0aGUgcmVhY3RpdmUgcHJveHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNyZWF0ZVNoYWRvd1RhcmdldChkaXN0b3J0ZWRWYWx1ZSksIHJlYWN0aXZlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICByZWdpc3RlclByb3h5KHByb3h5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhY3RpdmUnLCB7IHZhbHVlOiBwcm94eSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZ2V0IHJlYWRPbmx5KCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZE9ubHlIYW5kbGVyID0gbmV3IFJlYWRPbmx5SGFuZGxlcihtZW1icmFuZSwgZGlzdG9ydGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgLy8gY2FjaGluZyB0aGUgcmVhZE9ubHkgcHJveHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaXMgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KGNyZWF0ZVNoYWRvd1RhcmdldChkaXN0b3J0ZWRWYWx1ZSksIHJlYWRPbmx5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICByZWdpc3RlclByb3h5KHByb3h5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eSh0aGlzLCAncmVhZE9ubHknLCB7IHZhbHVlOiBwcm94eSB9KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgb2JqZWN0R3JhcGguc2V0KGRpc3RvcnRlZFZhbHVlLCByZWFjdGl2ZVN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gcmVhY3RpdmVTdGF0ZTtcbiAgICAgIH1cbiAgfVxuICAvKiogdmVyc2lvbjogMC4yNi4wICovXG5cbiAgZnVuY3Rpb24gd3JhcChkYXRhLCBtdXRhdGlvbkNhbGxiYWNrKSB7XG5cbiAgICBsZXQgbWVtYnJhbmUgPSBuZXcgUmVhY3RpdmVNZW1icmFuZSh7XG4gICAgICB2YWx1ZU11dGF0ZWQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgbXV0YXRpb25DYWxsYmFjayh0YXJnZXQsIGtleSk7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbWVtYnJhbmUuZ2V0UHJveHkoZGF0YSksXG4gICAgICBtZW1icmFuZTogbWVtYnJhbmVcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHVud3JhcCQxKG1lbWJyYW5lLCBvYnNlcnZhYmxlKSB7XG4gICAgbGV0IHVud3JhcHBlZERhdGEgPSBtZW1icmFuZS51bndyYXBQcm94eShvYnNlcnZhYmxlKTtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHVud3JhcHBlZERhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChbJyRlbCcsICckcmVmcycsICckbmV4dFRpY2snLCAnJHdhdGNoJ10uaW5jbHVkZXMoa2V5KSkgcmV0dXJuO1xuICAgICAgY29weVtrZXldID0gdW53cmFwcGVkRGF0YVtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG5cbiAgY2xhc3MgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgY29tcG9uZW50Rm9yQ2xvbmUgPSBudWxsKSB7XG4gICAgICB0aGlzLiRlbCA9IGVsO1xuICAgICAgY29uc3QgZGF0YUF0dHIgPSB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUoJ3gtZGF0YScpO1xuICAgICAgY29uc3QgZGF0YUV4cHJlc3Npb24gPSBkYXRhQXR0ciA9PT0gJycgPyAne30nIDogZGF0YUF0dHI7XG4gICAgICBjb25zdCBpbml0RXhwcmVzc2lvbiA9IHRoaXMuJGVsLmdldEF0dHJpYnV0ZSgneC1pbml0Jyk7XG4gICAgICBsZXQgZGF0YUV4dHJhcyA9IHtcbiAgICAgICAgJGVsOiB0aGlzLiRlbFxuICAgICAgfTtcbiAgICAgIGxldCBjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlID0gY29tcG9uZW50Rm9yQ2xvbmUgPyBjb21wb25lbnRGb3JDbG9uZS4kZWwgOiB0aGlzLiRlbDtcbiAgICAgIE9iamVjdC5lbnRyaWVzKEFscGluZS5tYWdpY1Byb3BlcnRpZXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFFeHRyYXMsIGAkJHtuYW1lfWAsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhID0gY29tcG9uZW50Rm9yQ2xvbmUgPyBjb21wb25lbnRGb3JDbG9uZS5nZXRVbm9ic2VydmVkRGF0YSgpIDogc2FmZXJFdmFsKGVsLCBkYXRhRXhwcmVzc2lvbiwgZGF0YUV4dHJhcyk7XG4gICAgICAvLyBDb25zdHJ1Y3QgYSBQcm94eS1iYXNlZCBvYnNlcnZhYmxlLiBUaGlzIHdpbGwgYmUgdXNlZCB0byBoYW5kbGUgcmVhY3Rpdml0eS5cblxuICAgICAgbGV0IHtcbiAgICAgICAgbWVtYnJhbmUsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLndyYXBEYXRhSW5PYnNlcnZhYmxlKHRoaXMudW5vYnNlcnZlZERhdGEpO1xuICAgICAgdGhpcy4kZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLm1lbWJyYW5lID0gbWVtYnJhbmU7IC8vIEFmdGVyIG1ha2luZyB1c2VyLXN1cHBsaWVkIGRhdGEgbWV0aG9kcyByZWFjdGl2ZSwgd2UgY2FuIG5vdyBhZGRcbiAgICAgIC8vIG91ciBtYWdpYyBwcm9wZXJ0aWVzIHRvIHRoZSBvcmlnaW5hbCBkYXRhIGZvciBhY2Nlc3MuXG5cbiAgICAgIHRoaXMudW5vYnNlcnZlZERhdGEuJGVsID0gdGhpcy4kZWw7XG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiRyZWZzID0gdGhpcy5nZXRSZWZzUHJveHkoKTtcbiAgICAgIHRoaXMubmV4dFRpY2tTdGFjayA9IFtdO1xuXG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiRuZXh0VGljayA9IGNhbGxiYWNrID0+IHtcbiAgICAgICAgdGhpcy5uZXh0VGlja1N0YWNrLnB1c2goY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgdGhpcy53YXRjaGVycyA9IHt9O1xuXG4gICAgICB0aGlzLnVub2JzZXJ2ZWREYXRhLiR3YXRjaCA9IChwcm9wZXJ0eSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLndhdGNoZXJzW3Byb3BlcnR5XSkgdGhpcy53YXRjaGVyc1twcm9wZXJ0eV0gPSBbXTtcbiAgICAgICAgdGhpcy53YXRjaGVyc1twcm9wZXJ0eV0ucHVzaChjYWxsYmFjayk7XG4gICAgICB9O1xuICAgICAgLyogTU9ERVJOLU9OTFk6U1RBUlQgKi9cbiAgICAgIC8vIFdlIHJlbW92ZSB0aGlzIHBpZWNlIG9mIGNvZGUgZnJvbSB0aGUgbGVnYWN5IGJ1aWxkLlxuICAgICAgLy8gSW4gSUUxMSwgd2UgaGF2ZSBhbHJlYWR5IGRlZmluZWQgb3VyIGhlbHBlcnMgYXQgdGhpcyBwb2ludC5cbiAgICAgIC8vIFJlZ2lzdGVyIGN1c3RvbSBtYWdpYyBwcm9wZXJ0aWVzLlxuXG5cbiAgICAgIE9iamVjdC5lbnRyaWVzKEFscGluZS5tYWdpY1Byb3BlcnRpZXMpLmZvckVhY2goKFtuYW1lLCBjYWxsYmFja10pID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMudW5vYnNlcnZlZERhdGEsIGAkJHtuYW1lfWAsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjYW5vbmljYWxDb21wb25lbnRFbGVtZW50UmVmZXJlbmNlLCB0aGlzLiRlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLyogTU9ERVJOLU9OTFk6RU5EICovXG5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrID0gW107XG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudDtcbiAgICAgIGNvbXBvbmVudEZvckNsb25lIHx8IEFscGluZS5vbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRoaXMpKTtcbiAgICAgIHZhciBpbml0UmV0dXJuZWRDYWxsYmFjazsgLy8gSWYgeC1pbml0IGlzIHByZXNlbnQgQU5EIHdlIGFyZW4ndCBjbG9uaW5nIChza2lwIHgtaW5pdCBvbiBjbG9uZSlcblxuICAgICAgaWYgKGluaXRFeHByZXNzaW9uICYmICFjb21wb25lbnRGb3JDbG9uZSkge1xuICAgICAgICAvLyBXZSB3YW50IHRvIGFsbG93IGRhdGEgbWFuaXB1bGF0aW9uLCBidXQgbm90IHRyaWdnZXIgRE9NIHVwZGF0ZXMganVzdCB5ZXQuXG4gICAgICAgIC8vIFdlIGhhdmVuJ3QgZXZlbiBpbml0aWFsaXplZCB0aGUgZWxlbWVudHMgd2l0aCB0aGVpciBBbHBpbmUgYmluZGluZ3MuIEkgbWVhbiBjJ21vbi5cbiAgICAgICAgdGhpcy5wYXVzZVJlYWN0aXZpdHkgPSB0cnVlO1xuICAgICAgICBpbml0UmV0dXJuZWRDYWxsYmFjayA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKHRoaXMuJGVsLCBpbml0RXhwcmVzc2lvbik7XG4gICAgICAgIHRoaXMucGF1c2VSZWFjdGl2aXR5ID0gZmFsc2U7XG4gICAgICB9IC8vIFJlZ2lzdGVyIGFsbCBvdXIgbGlzdGVuZXJzIGFuZCBzZXQgYWxsIG91ciBhdHRyaWJ1dGUgYmluZGluZ3MuXG4gICAgICAvLyBJZiB3ZSdyZSBjbG9uaW5nIGEgY29tcG9uZW50LCB0aGUgdGhpcmQgcGFyYW1ldGVyIGVuc3VyZXMgbm8gZHVwbGljYXRlXG4gICAgICAvLyBldmVudCBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgKHRoZSBtdXRhdGlvbiBvYnNlcnZlciB3aWxsIHRha2UgY2FyZSBvZiB0aGVtKVxuXG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZUVsZW1lbnRzKHRoaXMuJGVsLCAoKSA9PiB7fSwgY29tcG9uZW50Rm9yQ2xvbmUpOyAvLyBVc2UgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gZGV0ZWN0IG5ldyBlbGVtZW50cyBiZWluZyBhZGRlZCB3aXRoaW4gdGhpcyBjb21wb25lbnQgYXQgcnVuLXRpbWUuXG4gICAgICAvLyBBbHBpbmUncyBqdXN0IHNvIGRhcm4gZmxleGlibGUgYW1pcml0ZT9cblxuICAgICAgdGhpcy5saXN0ZW5Gb3JOZXdFbGVtZW50c1RvSW5pdGlhbGl6ZSgpO1xuXG4gICAgICBpZiAodHlwZW9mIGluaXRSZXR1cm5lZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFJ1biB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZnJvbSB0aGUgXCJ4LWluaXRcIiBob29rIHRvIGFsbG93IHRoZSB1c2VyIHRvIGRvIHN0dWZmIGFmdGVyXG4gICAgICAgIC8vIEFscGluZSdzIGdvdCBpdCdzIGdydWJieSBsaXR0bGUgcGF3cyBhbGwgb3ZlciBldmVyeXRoaW5nLlxuICAgICAgICBpbml0UmV0dXJuZWRDYWxsYmFjay5jYWxsKHRoaXMuJGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRGb3JDbG9uZSB8fCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQWxwaW5lLm9uQ29tcG9uZW50SW5pdGlhbGl6ZWRzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGhpcykpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgZ2V0VW5vYnNlcnZlZERhdGEoKSB7XG4gICAgICByZXR1cm4gdW53cmFwJDEodGhpcy5tZW1icmFuZSwgdGhpcy4kZGF0YSk7XG4gICAgfVxuXG4gICAgd3JhcERhdGFJbk9ic2VydmFibGUoZGF0YSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgbGV0IHVwZGF0ZURvbSA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi51cGRhdGVFbGVtZW50cyhzZWxmLiRlbCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiB3cmFwKGRhdGEsICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICBpZiAoc2VsZi53YXRjaGVyc1trZXldKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHdhdGNoZXIgZm9yIHRoaXMgc3BlY2lmaWMga2V5LCBydW4gaXQuXG4gICAgICAgICAgc2VsZi53YXRjaGVyc1trZXldLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2sodGFyZ2V0W2tleV0pKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAvLyBBcnJheXMgYXJlIHNwZWNpYWwgY2FzZXMsIGlmIGFueSBvZiB0aGUgaXRlbXMgY2hhbmdlLCB3ZSBjb25zaWRlciB0aGUgYXJyYXkgYXMgbXV0YXRlZC5cbiAgICAgICAgICBPYmplY3Qua2V5cyhzZWxmLndhdGNoZXJzKS5mb3JFYWNoKGZ1bGxEb3ROb3RhdGlvbktleSA9PiB7XG4gICAgICAgICAgICBsZXQgZG90Tm90YXRpb25QYXJ0cyA9IGZ1bGxEb3ROb3RhdGlvbktleS5zcGxpdCgnLicpOyAvLyBJZ25vcmUgbGVuZ3RoIG11dGF0aW9ucyBzaW5jZSB0aGV5IHdvdWxkIHJlc3VsdCBpbiBkdXBsaWNhdGUgY2FsbHMuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiBjYWxsaW5nIHB1c2gsIHdlIHdvdWxkIGdldCBhIG11dGF0aW9uIGZvciB0aGUgaXRlbSdzIGtleVxuICAgICAgICAgICAgLy8gYW5kIGEgc2Vjb25kIG11dGF0aW9uIGZvciB0aGUgbGVuZ3RoIHByb3BlcnR5LlxuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnbGVuZ3RoJykgcmV0dXJuO1xuICAgICAgICAgICAgZG90Tm90YXRpb25QYXJ0cy5yZWR1Y2UoKGNvbXBhcmlzb25EYXRhLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaXModGFyZ2V0LCBjb21wYXJpc29uRGF0YVtwYXJ0XSkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLndhdGNoZXJzW2Z1bGxEb3ROb3RhdGlvbktleV0uZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjayh0YXJnZXQpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb21wYXJpc29uRGF0YVtwYXJ0XTtcbiAgICAgICAgICAgIH0sIHNlbGYudW5vYnNlcnZlZERhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExldCdzIHdhbGsgdGhyb3VnaCB0aGUgd2F0Y2hlcnMgd2l0aCBcImRvdC1ub3RhdGlvblwiIChmb28uYmFyKSBhbmQgc2VlXG4gICAgICAgICAgLy8gaWYgdGhpcyBtdXRhdGlvbiBmaXRzIGFueSBvZiB0aGVtLlxuICAgICAgICAgIE9iamVjdC5rZXlzKHNlbGYud2F0Y2hlcnMpLmZpbHRlcihpID0+IGkuaW5jbHVkZXMoJy4nKSkuZm9yRWFjaChmdWxsRG90Tm90YXRpb25LZXkgPT4ge1xuICAgICAgICAgICAgbGV0IGRvdE5vdGF0aW9uUGFydHMgPSBmdWxsRG90Tm90YXRpb25LZXkuc3BsaXQoJy4nKTsgLy8gSWYgdGhpcyBkb3Qtbm90YXRpb24gd2F0Y2hlcidzIGxhc3QgXCJwYXJ0XCIgZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudFxuICAgICAgICAgICAgLy8ga2V5LCB0aGVuIHNraXAgaXQgZWFybHkgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG5cbiAgICAgICAgICAgIGlmIChrZXkgIT09IGRvdE5vdGF0aW9uUGFydHNbZG90Tm90YXRpb25QYXJ0cy5sZW5ndGggLSAxXSkgcmV0dXJuOyAvLyBOb3csIHdhbGsgdGhyb3VnaCB0aGUgZG90LW5vdGF0aW9uIFwicGFydHNcIiByZWN1cnNpdmVseSB0byBmaW5kXG4gICAgICAgICAgICAvLyBhIG1hdGNoLCBhbmQgY2FsbCB0aGUgd2F0Y2hlciBpZiBvbmUncyBmb3VuZC5cblxuICAgICAgICAgICAgZG90Tm90YXRpb25QYXJ0cy5yZWR1Y2UoKGNvbXBhcmlzb25EYXRhLCBwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChPYmplY3QuaXModGFyZ2V0LCBjb21wYXJpc29uRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBSdW4gdGhlIHdhdGNoZXJzLlxuICAgICAgICAgICAgICAgIHNlbGYud2F0Y2hlcnNbZnVsbERvdE5vdGF0aW9uS2V5XS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRhcmdldFtrZXldKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gY29tcGFyaXNvbkRhdGFbcGFydF07XG4gICAgICAgICAgICB9LCBzZWxmLnVub2JzZXJ2ZWREYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBEb24ndCByZWFjdCB0byBkYXRhIGNoYW5nZXMgZm9yIGNhc2VzIGxpa2UgdGhlIGB4LWNyZWF0ZWRgIGhvb2suXG5cblxuICAgICAgICBpZiAoc2VsZi5wYXVzZVJlYWN0aXZpdHkpIHJldHVybjtcbiAgICAgICAgdXBkYXRlRG9tKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMoZWwsIGNhbGxiYWNrLCBpbml0aWFsaXplQ29tcG9uZW50Q2FsbGJhY2sgPSAoKSA9PiB7fSkge1xuICAgICAgd2FsayhlbCwgZWwgPT4ge1xuICAgICAgICAvLyBXZSd2ZSBoaXQgYSBjb21wb25lbnQuXG4gICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3gtZGF0YScpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgICAgIGlmICghZWwuaXNTYW1lTm9kZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgaXQgaWYgaXQncyBub3QuXG4gICAgICAgICAgICBpZiAoIWVsLl9feCkgaW5pdGlhbGl6ZUNvbXBvbmVudENhbGxiYWNrKGVsKTsgLy8gTm93IHdlJ2xsIGxldCB0aGF0IHN1Yi1jb21wb25lbnQgZGVhbCB3aXRoIGl0c2VsZi5cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplRWxlbWVudHMocm9vdEVsLCBleHRyYVZhcnMgPSAoKSA9PiB7fSwgY29tcG9uZW50Rm9yQ2xvbmUgPSBmYWxzZSkge1xuICAgICAgdGhpcy53YWxrQW5kU2tpcE5lc3RlZENvbXBvbmVudHMocm9vdEVsLCBlbCA9PiB7XG4gICAgICAgIC8vIERvbid0IHRvdWNoIHNwYXducyBmcm9tIGZvciBsb29wXG4gICAgICAgIGlmIChlbC5fX3hfZm9yX2tleSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7IC8vIERvbid0IHRvdWNoIHNwYXducyBmcm9tIGlmIGRpcmVjdGl2ZXNcblxuICAgICAgICBpZiAoZWwuX194X2luc2VydGVkX21lICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplRWxlbWVudChlbCwgZXh0cmFWYXJzLCBjb21wb25lbnRGb3JDbG9uZSA/IGZhbHNlIDogdHJ1ZSk7XG4gICAgICB9LCBlbCA9PiB7XG4gICAgICAgIGlmICghY29tcG9uZW50Rm9yQ2xvbmUpIGVsLl9feCA9IG5ldyBDb21wb25lbnQoZWwpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmV4ZWN1dGVBbmRDbGVhclJlbWFpbmluZ1Nob3dEaXJlY3RpdmVTdGFjaygpO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJOZXh0VGlja1N0YWNrKHJvb3RFbCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZUVsZW1lbnQoZWwsIGV4dHJhVmFycywgc2hvdWxkUmVnaXN0ZXJMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICAvLyBUbyBzdXBwb3J0IGNsYXNzIGF0dHJpYnV0ZSBtZXJnaW5nLCB3ZSBoYXZlIHRvIGtub3cgd2hhdCB0aGUgZWxlbWVudCdzXG4gICAgICAvLyBvcmlnaW5hbCBjbGFzcyBhdHRyaWJ1dGUgbG9va2VkIGxpa2UgZm9yIHJlZmVyZW5jZS5cbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NsYXNzJykgJiYgZ2V0WEF0dHJzKGVsLCB0aGlzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGVsLl9feF9vcmlnaW5hbF9jbGFzc2VzID0gY29udmVydENsYXNzU3RyaW5nVG9BcnJheShlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykpO1xuICAgICAgfVxuXG4gICAgICBzaG91bGRSZWdpc3Rlckxpc3RlbmVycyAmJiB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKGVsLCBleHRyYVZhcnMpO1xuICAgICAgdGhpcy5yZXNvbHZlQm91bmRBdHRyaWJ1dGVzKGVsLCB0cnVlLCBleHRyYVZhcnMpO1xuICAgIH1cblxuICAgIHVwZGF0ZUVsZW1lbnRzKHJvb3RFbCwgZXh0cmFWYXJzID0gKCkgPT4ge30pIHtcbiAgICAgIHRoaXMud2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKHJvb3RFbCwgZWwgPT4ge1xuICAgICAgICAvLyBEb24ndCB0b3VjaCBzcGF3bnMgZnJvbSBmb3IgbG9vcCAoYW5kIGNoZWNrIGlmIHRoZSByb290IGlzIGFjdHVhbGx5IGEgZm9yIGxvb3AgaW4gYSBwYXJlbnQsIGRvbid0IHNraXAgaXQuKVxuICAgICAgICBpZiAoZWwuX194X2Zvcl9rZXkgIT09IHVuZGVmaW5lZCAmJiAhZWwuaXNTYW1lTm9kZSh0aGlzLiRlbCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGVsLCBleHRyYVZhcnMpO1xuICAgICAgfSwgZWwgPT4ge1xuICAgICAgICBlbC5fX3ggPSBuZXcgQ29tcG9uZW50KGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5leGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKTtcbiAgICAgIHRoaXMuZXhlY3V0ZUFuZENsZWFyTmV4dFRpY2tTdGFjayhyb290RWwpO1xuICAgIH1cblxuICAgIGV4ZWN1dGVBbmRDbGVhck5leHRUaWNrU3RhY2soZWwpIHtcbiAgICAgIC8vIFNraXAgc3Bhd25zIGZyb20gYWxwaW5lIGRpcmVjdGl2ZXNcbiAgICAgIGlmIChlbCA9PT0gdGhpcy4kZWwgJiYgdGhpcy5uZXh0VGlja1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gV2UgcnVuIHRoZSB0aWNrIHN0YWNrIGFmdGVyIHRoZSBuZXh0IGZyYW1lIHRvIGFsbG93IGFueVxuICAgICAgICAvLyBydW5uaW5nIHRyYW5zaXRpb25zIHRvIHBhc3MgdGhlIGluaXRpYWwgc2hvdyBzdGFnZS5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB3aGlsZSAodGhpcy5uZXh0VGlja1N0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFRpY2tTdGFjay5zaGlmdCgpKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleGVjdXRlQW5kQ2xlYXJSZW1haW5pbmdTaG93RGlyZWN0aXZlU3RhY2soKSB7XG4gICAgICAvLyBUaGUgZ29hbCBoZXJlIGlzIHRvIHN0YXJ0IGFsbCB0aGUgeC1zaG93IHRyYW5zaXRpb25zXG4gICAgICAvLyBhbmQgYnVpbGQgYSBuZXN0ZWQgcHJvbWlzZSBjaGFpbiBzbyB0aGF0IGVsZW1lbnRzXG4gICAgICAvLyBvbmx5IGhpZGUgd2hlbiB0aGUgY2hpbGRyZW4gYXJlIGZpbmlzaGVkIGhpZGluZy5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrLnJldmVyc2UoKS5tYXAoaGFuZGxlciA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaGFuZGxlcihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLnJlZHVjZSgocHJvbWlzZUNoYWluLCBwcm9taXNlKSA9PiB7XG4gICAgICAgIHJldHVybiBwcm9taXNlQ2hhaW4udGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmaW5pc2hFbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGZpbmlzaEVsZW1lbnQoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9LCBQcm9taXNlLnJlc29sdmUoKCkgPT4ge30pKS5jYXRjaChlID0+IHtcbiAgICAgICAgaWYgKGUgIT09IFRSQU5TSVRJT05fQ0FOQ0VMTEVEKSB0aHJvdyBlO1xuICAgICAgfSk7IC8vIFdlJ3ZlIHByb2Nlc3NlZCB0aGUgaGFuZGxlciBzdGFjay4gbGV0J3MgY2xlYXIgaXQuXG5cbiAgICAgIHRoaXMuc2hvd0RpcmVjdGl2ZVN0YWNrID0gW107XG4gICAgICB0aGlzLnNob3dEaXJlY3RpdmVMYXN0RWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB1cGRhdGVFbGVtZW50KGVsLCBleHRyYVZhcnMpIHtcbiAgICAgIHRoaXMucmVzb2x2ZUJvdW5kQXR0cmlidXRlcyhlbCwgZmFsc2UsIGV4dHJhVmFycyk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnMoZWwsIGV4dHJhVmFycykge1xuICAgICAgZ2V0WEF0dHJzKGVsLCB0aGlzKS5mb3JFYWNoKCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIGV4cHJlc3Npb25cbiAgICAgIH0pID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnb24nOlxuICAgICAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcih0aGlzLCBlbCwgdmFsdWUsIG1vZGlmaWVycywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbW9kZWwnOlxuICAgICAgICAgICAgcmVnaXN0ZXJNb2RlbExpc3RlbmVyKHRoaXMsIGVsLCBtb2RpZmllcnMsIGV4cHJlc3Npb24sIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzb2x2ZUJvdW5kQXR0cmlidXRlcyhlbCwgaW5pdGlhbFVwZGF0ZSA9IGZhbHNlLCBleHRyYVZhcnMpIHtcbiAgICAgIGxldCBhdHRycyA9IGdldFhBdHRycyhlbCwgdGhpcyk7XG4gICAgICBhdHRycy5mb3JFYWNoKCh7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBtb2RpZmllcnMsXG4gICAgICAgIGV4cHJlc3Npb25cbiAgICAgIH0pID0+IHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbW9kZWwnOlxuICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlQmluZGluZ0RpcmVjdGl2ZSh0aGlzLCBlbCwgJ3ZhbHVlJywgZXhwcmVzc2lvbiwgZXh0cmFWYXJzLCB0eXBlLCBtb2RpZmllcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiaW5kJzpcbiAgICAgICAgICAgIC8vIFRoZSA6a2V5IGJpbmRpbmcgb24gYW4geC1mb3IgaXMgc3BlY2lhbCwgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RlbXBsYXRlJyAmJiB2YWx1ZSA9PT0gJ2tleScpIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZUJpbmRpbmdEaXJlY3RpdmUodGhpcywgZWwsIHZhbHVlLCBleHByZXNzaW9uLCBleHRyYVZhcnMsIHR5cGUsIG1vZGlmaWVycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuZXZhbHVhdGVSZXR1cm5FeHByZXNzaW9uKGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgaGFuZGxlVGV4dERpcmVjdGl2ZShlbCwgb3V0cHV0LCBleHByZXNzaW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgICAgICBoYW5kbGVIdG1sRGlyZWN0aXZlKHRoaXMsIGVsLCBleHByZXNzaW9uLCBleHRyYVZhcnMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzaG93JzpcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGhhbmRsZVNob3dEaXJlY3RpdmUodGhpcywgZWwsIG91dHB1dCwgbW9kaWZpZXJzLCBpbml0aWFsVXBkYXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaWYnOlxuICAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGFsc28gaGFzIHgtZm9yIG9uIGl0LCBkb24ndCBwcm9jZXNzIHgtaWYuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIGxldCB0aGUgXCJ4LWZvclwiIGRpcmVjdGl2ZSBoYW5kbGUgdGhlIFwiaWZcImluZy5cbiAgICAgICAgICAgIGlmIChhdHRycy5zb21lKGkgPT4gaS50eXBlID09PSAnZm9yJykpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLmV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzKTtcbiAgICAgICAgICAgIGhhbmRsZUlmRGlyZWN0aXZlKHRoaXMsIGVsLCBvdXRwdXQsIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Zvcic6XG4gICAgICAgICAgICBoYW5kbGVGb3JEaXJlY3RpdmUodGhpcywgZWwsIGV4cHJlc3Npb24sIGluaXRpYWxVcGRhdGUsIGV4dHJhVmFycyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Nsb2FrJzpcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgneC1jbG9haycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGV2YWx1YXRlUmV0dXJuRXhwcmVzc2lvbihlbCwgZXhwcmVzc2lvbiwgZXh0cmFWYXJzID0gKCkgPT4ge30pIHtcbiAgICAgIHJldHVybiBzYWZlckV2YWwoZWwsIGV4cHJlc3Npb24sIHRoaXMuJGRhdGEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICRkaXNwYXRjaDogdGhpcy5nZXREaXNwYXRjaEZ1bmN0aW9uKGVsKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGV2YWx1YXRlQ29tbWFuZEV4cHJlc3Npb24oZWwsIGV4cHJlc3Npb24sIGV4dHJhVmFycyA9ICgpID0+IHt9KSB7XG4gICAgICByZXR1cm4gc2FmZXJFdmFsTm9SZXR1cm4oZWwsIGV4cHJlc3Npb24sIHRoaXMuJGRhdGEsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYVZhcnMoKSksIHt9LCB7XG4gICAgICAgICRkaXNwYXRjaDogdGhpcy5nZXREaXNwYXRjaEZ1bmN0aW9uKGVsKVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIGdldERpc3BhdGNoRnVuY3Rpb24oZWwpIHtcbiAgICAgIHJldHVybiAoZXZlbnQsIGRldGFpbCA9IHt9KSA9PiB7XG4gICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50LCB7XG4gICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBsaXN0ZW5Gb3JOZXdFbGVtZW50c1RvSW5pdGlhbGl6ZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLiRlbDtcbiAgICAgIGNvbnN0IG9ic2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICB9O1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIC8vIEZpbHRlciBvdXQgbXV0YXRpb25zIHRyaWdnZXJlZCBmcm9tIGNoaWxkIGNvbXBvbmVudHMuXG4gICAgICAgICAgY29uc3QgY2xvc2VzdFBhcmVudENvbXBvbmVudCA9IG11dGF0aW9uc1tpXS50YXJnZXQuY2xvc2VzdCgnW3gtZGF0YV0nKTtcbiAgICAgICAgICBpZiAoIShjbG9zZXN0UGFyZW50Q29tcG9uZW50ICYmIGNsb3Nlc3RQYXJlbnRDb21wb25lbnQuaXNTYW1lTm9kZSh0aGlzLiRlbCkpKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChtdXRhdGlvbnNbaV0udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnICYmIG11dGF0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lID09PSAneC1kYXRhJykge1xuICAgICAgICAgICAgY29uc3QgeEF0dHIgPSBtdXRhdGlvbnNbaV0udGFyZ2V0LmdldEF0dHJpYnV0ZSgneC1kYXRhJykgfHwgJ3t9JztcbiAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBzYWZlckV2YWwodGhpcy4kZWwsIHhBdHRyLCB7XG4gICAgICAgICAgICAgICRlbDogdGhpcy4kZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocmF3RGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICBpZiAodGhpcy4kZGF0YVtrZXldICE9PSByYXdEYXRhW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRkYXRhW2tleV0gPSByYXdEYXRhW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSB8fCBub2RlLl9feF9pbnNlcnRlZF9tZSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgIGlmIChub2RlLm1hdGNoZXMoJ1t4LWRhdGFdJykgJiYgIW5vZGUuX194KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fX3ggPSBuZXcgQ29tcG9uZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUVsZW1lbnRzKG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICB9XG5cbiAgICBnZXRSZWZzUHJveHkoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgcmVmT2JqID0ge307XG4gICAgICAvLyBPbmUgb2YgdGhlIGdvYWxzIG9mIHRoaXMgaXMgdG8gbm90IGhvbGQgZWxlbWVudHMgaW4gbWVtb3J5LCBidXQgcmF0aGVyIHJlLWV2YWx1YXRlXG4gICAgICAvLyB0aGUgRE9NIHdoZW4gdGhlIHN5c3RlbSBuZWVkcyBzb21ldGhpbmcgZnJvbSBpdC4gVGhpcyB3YXksIHRoZSBmcmFtZXdvcmsgaXMgZmxleGlibGUgYW5kXG4gICAgICAvLyBmcmllbmRseSB0byBvdXRzaWRlIERPTSBjaGFuZ2VzIGZyb20gbGlicmFyaWVzIGxpa2UgVnVlL0xpdmV3aXJlLlxuICAgICAgLy8gRm9yIHRoaXMgcmVhc29uLCBJJ20gdXNpbmcgYW4gXCJvbi1kZW1hbmRcIiBwcm94eSB0byBmYWtlIGEgXCIkcmVmc1wiIG9iamVjdC5cblxuICAgICAgcmV0dXJuIG5ldyBQcm94eShyZWZPYmosIHtcbiAgICAgICAgZ2V0KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICBpZiAocHJvcGVydHkgPT09ICckaXNBbHBpbmVQcm94eScpIHJldHVybiB0cnVlO1xuICAgICAgICAgIHZhciByZWY7IC8vIFdlIGNhbid0IGp1c3QgcXVlcnkgdGhlIERPTSBiZWNhdXNlIGl0J3MgaGFyZCB0byBmaWx0ZXIgb3V0IHJlZnMgaW5cbiAgICAgICAgICAvLyBuZXN0ZWQgY29tcG9uZW50cy5cblxuICAgICAgICAgIHNlbGYud2Fsa0FuZFNraXBOZXN0ZWRDb21wb25lbnRzKHNlbGYuJGVsLCBlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCd4LXJlZicpICYmIGVsLmdldEF0dHJpYnV0ZSgneC1yZWYnKSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgcmVmID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcbiAgICB9XG5cbiAgfVxuXG4gIGNvbnN0IEFscGluZSA9IHtcbiAgICB2ZXJzaW9uOiBcIjIuOC4yXCIsXG4gICAgcGF1c2VNdXRhdGlvbk9ic2VydmVyOiBmYWxzZSxcbiAgICBtYWdpY1Byb3BlcnRpZXM6IHt9LFxuICAgIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWRzOiBbXSxcbiAgICBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkczogW10sXG4gICAgaWdub3JlRm9jdXNlZEZvclZhbHVlQmluZGluZzogZmFsc2UsXG4gICAgc3RhcnQ6IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgaWYgKCFpc1Rlc3RpbmcoKSkge1xuICAgICAgICBhd2FpdCBkb21SZWFkeSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpc2NvdmVyQ29tcG9uZW50cyhlbCA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNvbXBvbmVudChlbCk7XG4gICAgICB9KTsgLy8gSXQncyBlYXNpZXIgYW5kIG1vcmUgcGVyZm9ybWFudCB0byBqdXN0IHN1cHBvcnQgVHVyYm9saW5rcyB0aGFuIGxpc3RlblxuICAgICAgLy8gdG8gTXV0YXRpb25PYnNlcnZlciBtdXRhdGlvbnMgYXQgdGhlIGRvY3VtZW50IGxldmVsLlxuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidHVyYm9saW5rczpsb2FkXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5kaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzKGVsID0+IHtcbiAgICAgICAgICB0aGlzLmluaXRpYWxpemVDb21wb25lbnQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5saXN0ZW5Gb3JOZXdVbmluaXRpYWxpemVkQ29tcG9uZW50c0F0UnVuVGltZSgpO1xuICAgIH0sXG4gICAgZGlzY292ZXJDb21wb25lbnRzOiBmdW5jdGlvbiBkaXNjb3ZlckNvbXBvbmVudHMoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IHJvb3RFbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbeC1kYXRhXScpO1xuICAgICAgcm9vdEVscy5mb3JFYWNoKHJvb3RFbCA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHJvb3RFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHM6IGZ1bmN0aW9uIGRpc2NvdmVyVW5pbml0aWFsaXplZENvbXBvbmVudHMoY2FsbGJhY2ssIGVsID0gbnVsbCkge1xuICAgICAgY29uc3Qgcm9vdEVscyA9IChlbCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCgnW3gtZGF0YV0nKTtcbiAgICAgIEFycmF5LmZyb20ocm9vdEVscykuZmlsdGVyKGVsID0+IGVsLl9feCA9PT0gdW5kZWZpbmVkKS5mb3JFYWNoKHJvb3RFbCA9PiB7XG4gICAgICAgIGNhbGxiYWNrKHJvb3RFbCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGxpc3RlbkZvck5ld1VuaW5pdGlhbGl6ZWRDb21wb25lbnRzQXRSdW5UaW1lOiBmdW5jdGlvbiBsaXN0ZW5Gb3JOZXdVbmluaXRpYWxpemVkQ29tcG9uZW50c0F0UnVuVGltZSgpIHtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgICBjb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGF1c2VNdXRhdGlvbk9ic2VydmVyKSByZXR1cm47XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobXV0YXRpb25zW2ldLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbXV0YXRpb25zW2ldLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgLy8gRGlzY2FyZCBub24tZWxlbWVudCBub2RlcyAobGlrZSBsaW5lLWJyZWFrcylcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHJldHVybjsgLy8gRGlzY2FyZCBhbnkgY2hhbmdlcyBoYXBwZW5pbmcgd2l0aGluIGFuIGV4aXN0aW5nIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRha2UgY2FyZSBvZiB0aGVtc2VsdmVzLlxuXG4gICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudEVsZW1lbnQgJiYgbm9kZS5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoJ1t4LWRhdGFdJykpIHJldHVybjtcbiAgICAgICAgICAgICAgdGhpcy5kaXNjb3ZlclVuaW5pdGlhbGl6ZWRDb21wb25lbnRzKGVsID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVDb21wb25lbnQoZWwpO1xuICAgICAgICAgICAgICB9LCBub2RlLnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICB9LFxuICAgIGluaXRpYWxpemVDb21wb25lbnQ6IGZ1bmN0aW9uIGluaXRpYWxpemVDb21wb25lbnQoZWwpIHtcbiAgICAgIGlmICghZWwuX194KSB7XG4gICAgICAgIC8vIFdyYXAgaW4gYSB0cnkvY2F0Y2ggc28gdGhhdCB3ZSBkb24ndCBwcmV2ZW50IG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgLy8gZnJvbSBpbml0aWFsaXppbmcgd2hlbiBvbmUgY29tcG9uZW50IGNvbnRhaW5zIGFuIGVycm9yLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsLl9feCA9IG5ldyBDb21wb25lbnQoZWwpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShjb21wb25lbnQsIG5ld0VsKSB7XG4gICAgICBpZiAoIW5ld0VsLl9feCkge1xuICAgICAgICBuZXdFbC5fX3ggPSBuZXcgQ29tcG9uZW50KG5ld0VsLCBjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFnaWNQcm9wZXJ0eTogZnVuY3Rpb24gYWRkTWFnaWNQcm9wZXJ0eShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgdGhpcy5tYWdpY1Byb3BlcnRpZXNbbmFtZV0gPSBjYWxsYmFjaztcbiAgICB9LFxuICAgIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWQ6IGZ1bmN0aW9uIG9uQ29tcG9uZW50SW5pdGlhbGl6ZWQoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25Db21wb25lbnRJbml0aWFsaXplZHMucHVzaChjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkOiBmdW5jdGlvbiBvbkJlZm9yZUNvbXBvbmVudEluaXRpYWxpemVkKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uQmVmb3JlQ29tcG9uZW50SW5pdGlhbGl6ZWRzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBpZiAoIWlzVGVzdGluZygpKSB7XG4gICAgd2luZG93LkFscGluZSA9IEFscGluZTtcblxuICAgIGlmICh3aW5kb3cuZGVmZXJMb2FkaW5nQWxwaW5lKSB7XG4gICAgICB3aW5kb3cuZGVmZXJMb2FkaW5nQWxwaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LkFscGluZS5zdGFydCgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5BbHBpbmUuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQWxwaW5lO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/alpinejs/dist/alpine.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("__webpack_require__(/*! ./bootstrap */ \"./resources/js/bootstrap.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzPzZkNDAiXSwibmFtZXMiOlsicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBLG1CQUFPLENBQUMsZ0RBQUQsQ0FBUCIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9hcHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2Jvb3RzdHJhcCcpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/bootstrap.js":
/*!***********************************!*\
  !*** ./resources/js/bootstrap.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! alpinejs */ \"./node_modules/alpinejs/dist/alpine.js\");\n/* harmony import */ var alpinejs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(alpinejs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jaames_iro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jaames/iro */ \"./node_modules/@jaames/iro/dist/iro.es.js\");\n\n\n\ntry {\n  window.iro = _jaames_iro__WEBPACK_IMPORTED_MODULE_1__.default;\n} catch (e) {}\n/**\n * Echo exposes an expressive API for subscribing to channels and listening\n * for events that are broadcast by Laravel. Echo and event broadcasting\n * allows your team to easily build robust real-time web applications.\n */\n// import Echo from \"laravel-echo\"\n// window.Pusher = require(\"pusher-js\");\n// window.Echo = new Echo({\n//     broadcaster: \"pusher\",\n//     key: process.env.MIX_PUSHER_APP_KEY,\n//     cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n//     forceTLS: true\n// });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYm9vdHN0cmFwLmpzP2Y1NjgiXSwibmFtZXMiOlsid2luZG93IiwiaXJvIiwiZSJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBRUE7O0FBRUEsSUFBSTtBQUNBQSxRQUFNLENBQUNDLEdBQVAsR0FBYUEsZ0RBQWI7QUFDSCxDQUZELENBRUUsT0FBT0MsQ0FBUCxFQUFVLENBQUU7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9ib290c3RyYXAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJhbHBpbmVqc1wiO1xuXG5pbXBvcnQgaXJvIGZyb20gXCJAamFhbWVzL2lyb1wiO1xuXG50cnkge1xuICAgIHdpbmRvdy5pcm8gPSBpcm87XG59IGNhdGNoIChlKSB7fVxuXG4vKipcbiAqIEVjaG8gZXhwb3NlcyBhbiBleHByZXNzaXZlIEFQSSBmb3Igc3Vic2NyaWJpbmcgdG8gY2hhbm5lbHMgYW5kIGxpc3RlbmluZ1xuICogZm9yIGV2ZW50cyB0aGF0IGFyZSBicm9hZGNhc3QgYnkgTGFyYXZlbC4gRWNobyBhbmQgZXZlbnQgYnJvYWRjYXN0aW5nXG4gKiBhbGxvd3MgeW91ciB0ZWFtIHRvIGVhc2lseSBidWlsZCByb2J1c3QgcmVhbC10aW1lIHdlYiBhcHBsaWNhdGlvbnMuXG4gKi9cblxuLy8gaW1wb3J0IEVjaG8gZnJvbSBcImxhcmF2ZWwtZWNob1wiXG5cbi8vIHdpbmRvdy5QdXNoZXIgPSByZXF1aXJlKFwicHVzaGVyLWpzXCIpO1xuXG4vLyB3aW5kb3cuRWNobyA9IG5ldyBFY2hvKHtcbi8vICAgICBicm9hZGNhc3RlcjogXCJwdXNoZXJcIixcbi8vICAgICBrZXk6IHByb2Nlc3MuZW52Lk1JWF9QVVNIRVJfQVBQX0tFWSxcbi8vICAgICBjbHVzdGVyOiBwcm9jZXNzLmVudi5NSVhfUFVTSEVSX0FQUF9DTFVTVEVSLFxuLy8gICAgIGZvcmNlVExTOiB0cnVlXG4vLyB9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/bootstrap.js\n");

/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvY3NzL2FwcC5jc3M/NDFjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEiLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2FwcC5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/css/app.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					result = fn();
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			__webpack_require__.O();
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;